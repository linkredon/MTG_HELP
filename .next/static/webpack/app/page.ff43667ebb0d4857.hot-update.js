"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/storage.ts":
/*!**************************!*\
  !*** ./utils/storage.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addSpoilerCard: () => (/* binding */ addSpoilerCard),\n/* harmony export */   addSpoilerCards: () => (/* binding */ addSpoilerCards),\n/* harmony export */   clearSpoilerCards: () => (/* binding */ clearSpoilerCards),\n/* harmony export */   loadSpoilerCards: () => (/* binding */ loadSpoilerCards),\n/* harmony export */   removeSpoilerCard: () => (/* binding */ removeSpoilerCard),\n/* harmony export */   saveSpoilerCards: () => (/* binding */ saveSpoilerCards)\n/* harmony export */ });\n// Utilitários para armazenamento de dados\n// Tamanho máximo aproximado para o localStorage (em bytes)\nconst MAX_STORAGE_SIZE = 5 * 1024 * 1024 // 5MB\n;\n// Função para salvar cartas de spoiler com otimização de armazenamento\nconst saveSpoilerCards = (cards)=>{\n    try {\n        // Separar as imagens das cartas para armazenamento separado\n        const cardsWithoutImages = cards.map((card)=>{\n            // Criar uma cópia da carta sem as imagens\n            const { image_uris, ...cardWithoutImage } = card;\n            // Manter apenas referências às imagens\n            return {\n                ...cardWithoutImage,\n                image_ref: card.id // Usar o ID da carta como referência para a imagem\n            };\n        });\n        // Salvar os dados das cartas sem imagens\n        localStorage.setItem('mtg-spoiler-cards-data', JSON.stringify(cardsWithoutImages));\n        // Salvar as imagens separadamente, uma por uma\n        cards.forEach((card)=>{\n            var _card_image_uris;\n            if ((_card_image_uris = card.image_uris) === null || _card_image_uris === void 0 ? void 0 : _card_image_uris.normal) {\n                try {\n                    localStorage.setItem(\"mtg-spoiler-image-\".concat(card.id), card.image_uris.normal);\n                } catch (e) {\n                    console.warn(\"N\\xe3o foi poss\\xedvel salvar a imagem da carta \".concat(card.name, \":\"), e);\n                // Continuar mesmo se uma imagem falhar\n                }\n            }\n        });\n        return true;\n    } catch (error) {\n        console.error('Erro ao salvar cartas de spoiler:', error);\n        return false;\n    }\n};\n// Função para carregar cartas de spoiler com suas imagens\nconst loadSpoilerCards = ()=>{\n    try {\n        // Carregar os dados das cartas\n        const cardsDataJson = localStorage.getItem('mtg-spoiler-cards-data');\n        if (!cardsDataJson) return [];\n        const cardsData = JSON.parse(cardsDataJson);\n        // Reconstruir as cartas com suas imagens\n        return cardsData.map((card)=>{\n            // Tentar carregar a imagem da carta\n            let imageUri = null;\n            try {\n                imageUri = localStorage.getItem(\"mtg-spoiler-image-\".concat(card.id));\n            } catch (e) {\n                console.warn(\"N\\xe3o foi poss\\xedvel carregar a imagem da carta \".concat(card.name, \":\"), e);\n            }\n            // Remover a referência à imagem e adicionar a imagem real\n            const { image_ref, ...cardWithoutRef } = card;\n            return {\n                ...cardWithoutRef,\n                image_uris: {\n                    normal: imageUri || '',\n                    large: imageUri || '',\n                    png: imageUri || '',\n                    art_crop: imageUri || ''\n                }\n            };\n        });\n    } catch (error) {\n        console.error('Erro ao carregar cartas de spoiler:', error);\n        return [];\n    }\n};\n// Função para limpar o armazenamento de cartas de spoiler\nconst clearSpoilerCards = ()=>{\n    // Obter todas as chaves do localStorage\n    const keys = [];\n    for(let i = 0; i < localStorage.length; i++){\n        const key = localStorage.key(i);\n        if (key && (key === 'mtg-spoiler-cards-data' || key.startsWith('mtg-spoiler-image-'))) {\n            keys.push(key);\n        }\n    }\n    // Remover todas as chaves relacionadas a cartas de spoiler\n    keys.forEach((key)=>localStorage.removeItem(key));\n};\n// Função para adicionar uma nova carta de spoiler\nconst addSpoilerCard = (card)=>{\n    try {\n        // Carregar as cartas existentes\n        const cards = loadSpoilerCards();\n        // Adicionar a nova carta\n        cards.unshift(card);\n        // Salvar as cartas atualizadas\n        return saveSpoilerCards(cards);\n    } catch (error) {\n        console.error('Erro ao adicionar carta de spoiler:', error);\n        return false;\n    }\n};\n// Função para adicionar múltiplas cartas de spoiler\nconst addSpoilerCards = (newCards)=>{\n    try {\n        // Carregar as cartas existentes\n        const cards = loadSpoilerCards();\n        // Adicionar as novas cartas\n        const updatedCards = [\n            ...newCards,\n            ...cards\n        ];\n        // Salvar as cartas atualizadas\n        return saveSpoilerCards(updatedCards);\n    } catch (error) {\n        console.error('Erro ao adicionar cartas de spoiler:', error);\n        return false;\n    }\n};\n// Função para remover uma carta de spoiler\nconst removeSpoilerCard = (cardId)=>{\n    try {\n        // Carregar as cartas existentes\n        const cards = loadSpoilerCards();\n        // Remover a carta com o ID especificado\n        const updatedCards = cards.filter((card)=>card.id !== cardId);\n        // Remover a imagem da carta\n        try {\n            localStorage.removeItem(\"mtg-spoiler-image-\".concat(cardId));\n        } catch (e) {\n            console.warn(\"N\\xe3o foi poss\\xedvel remover a imagem da carta \".concat(cardId, \":\"), e);\n        }\n        // Salvar as cartas atualizadas\n        return saveSpoilerCards(updatedCards);\n    } catch (error) {\n        console.error('Erro ao remover carta de spoiler:', error);\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUcsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsT0FBTztJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiRjpcXFDDgUdJTkEgTVRHIEhFTFBFUlxcY29sZWNhby1wYWdlLW1haW5cXHV0aWxzXFxzdG9yYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFV0aWxpdMOhcmlvcyBwYXJhIGFybWF6ZW5hbWVudG8gZGUgZGFkb3NcblxuaW1wb3J0IHR5cGUgeyBNVEdDYXJkIH0gZnJvbSAnQC90eXBlcy9tdGcnXG5cbi8vIEludGVyZmFjZSBsb2NhbCBwYXJhIGNhcnRhcyBkZSBzcG9pbGVyXG5pbnRlcmZhY2UgU3BvaWxlckNhcmQgZXh0ZW5kcyBQYXJ0aWFsPE1UR0NhcmQ+IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzZXQ/OiBzdHJpbmc7XG4gIHNldF9uYW1lPzogc3RyaW5nO1xuICBzcG9pbGVyU291cmNlPzogc3RyaW5nO1xuICBpc05ldz86IGJvb2xlYW47XG4gIHJlbGVhc2VEYXRlPzogc3RyaW5nO1xuICBpbWFnZV91cmlzPzoge1xuICAgIG5vcm1hbDogc3RyaW5nO1xuICAgIHNtYWxsPzogc3RyaW5nO1xuICAgIGFydF9jcm9wPzogc3RyaW5nO1xuICAgIGxhcmdlPzogc3RyaW5nO1xuICAgIHBuZz86IHN0cmluZztcbiAgfTtcbn1cblxuLy8gVGFtYW5obyBtw6F4aW1vIGFwcm94aW1hZG8gcGFyYSBvIGxvY2FsU3RvcmFnZSAoZW0gYnl0ZXMpXG5jb25zdCBNQVhfU1RPUkFHRV9TSVpFID0gNSAqIDEwMjQgKiAxMDI0IC8vIDVNQlxuXG4vLyBGdW7Dp8OjbyBwYXJhIHNhbHZhciBjYXJ0YXMgZGUgc3BvaWxlciBjb20gb3RpbWl6YcOnw6NvIGRlIGFybWF6ZW5hbWVudG9cbmV4cG9ydCBjb25zdCBzYXZlU3BvaWxlckNhcmRzID0gKGNhcmRzOiBTcG9pbGVyQ2FyZFtdKTogYm9vbGVhbiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gU2VwYXJhciBhcyBpbWFnZW5zIGRhcyBjYXJ0YXMgcGFyYSBhcm1hemVuYW1lbnRvIHNlcGFyYWRvXG4gICAgY29uc3QgY2FyZHNXaXRob3V0SW1hZ2VzID0gY2FyZHMubWFwKGNhcmQgPT4ge1xuICAgICAgLy8gQ3JpYXIgdW1hIGPDs3BpYSBkYSBjYXJ0YSBzZW0gYXMgaW1hZ2Vuc1xuICAgICAgY29uc3QgeyBpbWFnZV91cmlzLCAuLi5jYXJkV2l0aG91dEltYWdlIH0gPSBjYXJkXG4gICAgICBcbiAgICAgIC8vIE1hbnRlciBhcGVuYXMgcmVmZXLDqm5jaWFzIMOgcyBpbWFnZW5zXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jYXJkV2l0aG91dEltYWdlLFxuICAgICAgICBpbWFnZV9yZWY6IGNhcmQuaWQgLy8gVXNhciBvIElEIGRhIGNhcnRhIGNvbW8gcmVmZXLDqm5jaWEgcGFyYSBhIGltYWdlbVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgLy8gU2FsdmFyIG9zIGRhZG9zIGRhcyBjYXJ0YXMgc2VtIGltYWdlbnNcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbXRnLXNwb2lsZXItY2FyZHMtZGF0YScsIEpTT04uc3RyaW5naWZ5KGNhcmRzV2l0aG91dEltYWdlcykpXG4gICAgXG4gICAgLy8gU2FsdmFyIGFzIGltYWdlbnMgc2VwYXJhZGFtZW50ZSwgdW1hIHBvciB1bWFcbiAgICBjYXJkcy5mb3JFYWNoKGNhcmQgPT4ge1xuICAgICAgaWYgKGNhcmQuaW1hZ2VfdXJpcz8ubm9ybWFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYG10Zy1zcG9pbGVyLWltYWdlLSR7Y2FyZC5pZH1gLCBjYXJkLmltYWdlX3VyaXMubm9ybWFsKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBOw6NvIGZvaSBwb3Nzw612ZWwgc2FsdmFyIGEgaW1hZ2VtIGRhIGNhcnRhICR7Y2FyZC5uYW1lfTpgLCBlKVxuICAgICAgICAgIC8vIENvbnRpbnVhciBtZXNtbyBzZSB1bWEgaW1hZ2VtIGZhbGhhclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gc2FsdmFyIGNhcnRhcyBkZSBzcG9pbGVyOicsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgY2FycmVnYXIgY2FydGFzIGRlIHNwb2lsZXIgY29tIHN1YXMgaW1hZ2Vuc1xuZXhwb3J0IGNvbnN0IGxvYWRTcG9pbGVyQ2FyZHMgPSAoKTogU3BvaWxlckNhcmRbXSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gQ2FycmVnYXIgb3MgZGFkb3MgZGFzIGNhcnRhc1xuICAgIGNvbnN0IGNhcmRzRGF0YUpzb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXRnLXNwb2lsZXItY2FyZHMtZGF0YScpXG4gICAgaWYgKCFjYXJkc0RhdGFKc29uKSByZXR1cm4gW11cbiAgICBcbiAgICBjb25zdCBjYXJkc0RhdGEgPSBKU09OLnBhcnNlKGNhcmRzRGF0YUpzb24pXG4gICAgXG4gICAgLy8gUmVjb25zdHJ1aXIgYXMgY2FydGFzIGNvbSBzdWFzIGltYWdlbnNcbiAgICByZXR1cm4gY2FyZHNEYXRhLm1hcCgoY2FyZDogYW55KSA9PiB7XG4gICAgICAvLyBUZW50YXIgY2FycmVnYXIgYSBpbWFnZW0gZGEgY2FydGFcbiAgICAgIGxldCBpbWFnZVVyaTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICAgIHRyeSB7XG4gICAgICAgIGltYWdlVXJpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYG10Zy1zcG9pbGVyLWltYWdlLSR7Y2FyZC5pZH1gKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE7Do28gZm9pIHBvc3PDrXZlbCBjYXJyZWdhciBhIGltYWdlbSBkYSBjYXJ0YSAke2NhcmQubmFtZX06YCwgZSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlciBhIHJlZmVyw6puY2lhIMOgIGltYWdlbSBlIGFkaWNpb25hciBhIGltYWdlbSByZWFsXG4gICAgICBjb25zdCB7IGltYWdlX3JlZiwgLi4uY2FyZFdpdGhvdXRSZWYgfSA9IGNhcmRcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY2FyZFdpdGhvdXRSZWYsXG4gICAgICAgIGltYWdlX3VyaXM6IHtcbiAgICAgICAgICBub3JtYWw6IGltYWdlVXJpIHx8ICcnLFxuICAgICAgICAgIGxhcmdlOiBpbWFnZVVyaSB8fCAnJyxcbiAgICAgICAgICBwbmc6IGltYWdlVXJpIHx8ICcnLFxuICAgICAgICAgIGFydF9jcm9wOiBpbWFnZVVyaSB8fCAnJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGNhcnRhcyBkZSBzcG9pbGVyOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8vIEZ1bsOnw6NvIHBhcmEgbGltcGFyIG8gYXJtYXplbmFtZW50byBkZSBjYXJ0YXMgZGUgc3BvaWxlclxuZXhwb3J0IGNvbnN0IGNsZWFyU3BvaWxlckNhcmRzID0gKCkgPT4ge1xuICAvLyBPYnRlciB0b2RhcyBhcyBjaGF2ZXMgZG8gbG9jYWxTdG9yYWdlXG4gIGNvbnN0IGtleXMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSlcbiAgICBpZiAoa2V5ICYmIChrZXkgPT09ICdtdGctc3BvaWxlci1jYXJkcy1kYXRhJyB8fCBrZXkuc3RhcnRzV2l0aCgnbXRnLXNwb2lsZXItaW1hZ2UtJykpKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KVxuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVtb3ZlciB0b2RhcyBhcyBjaGF2ZXMgcmVsYWNpb25hZGFzIGEgY2FydGFzIGRlIHNwb2lsZXJcbiAga2V5cy5mb3JFYWNoKGtleSA9PiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKVxufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIGFkaWNpb25hciB1bWEgbm92YSBjYXJ0YSBkZSBzcG9pbGVyXG5leHBvcnQgY29uc3QgYWRkU3BvaWxlckNhcmQgPSAoY2FyZDogU3BvaWxlckNhcmQpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBDYXJyZWdhciBhcyBjYXJ0YXMgZXhpc3RlbnRlc1xuICAgIGNvbnN0IGNhcmRzID0gbG9hZFNwb2lsZXJDYXJkcygpXG4gICAgXG4gICAgLy8gQWRpY2lvbmFyIGEgbm92YSBjYXJ0YVxuICAgIGNhcmRzLnVuc2hpZnQoY2FyZClcbiAgICBcbiAgICAvLyBTYWx2YXIgYXMgY2FydGFzIGF0dWFsaXphZGFzXG4gICAgcmV0dXJuIHNhdmVTcG9pbGVyQ2FyZHMoY2FyZHMpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgY2FydGEgZGUgc3BvaWxlcjonLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vLyBGdW7Dp8OjbyBwYXJhIGFkaWNpb25hciBtw7psdGlwbGFzIGNhcnRhcyBkZSBzcG9pbGVyXG5leHBvcnQgY29uc3QgYWRkU3BvaWxlckNhcmRzID0gKG5ld0NhcmRzOiBTcG9pbGVyQ2FyZFtdKTogYm9vbGVhbiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gQ2FycmVnYXIgYXMgY2FydGFzIGV4aXN0ZW50ZXNcbiAgICBjb25zdCBjYXJkcyA9IGxvYWRTcG9pbGVyQ2FyZHMoKVxuICAgIFxuICAgIC8vIEFkaWNpb25hciBhcyBub3ZhcyBjYXJ0YXNcbiAgICBjb25zdCB1cGRhdGVkQ2FyZHMgPSBbLi4ubmV3Q2FyZHMsIC4uLmNhcmRzXVxuICAgIFxuICAgIC8vIFNhbHZhciBhcyBjYXJ0YXMgYXR1YWxpemFkYXNcbiAgICByZXR1cm4gc2F2ZVNwb2lsZXJDYXJkcyh1cGRhdGVkQ2FyZHMpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgY2FydGFzIGRlIHNwb2lsZXI6JywgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLy8gRnVuw6fDo28gcGFyYSByZW1vdmVyIHVtYSBjYXJ0YSBkZSBzcG9pbGVyXG5leHBvcnQgY29uc3QgcmVtb3ZlU3BvaWxlckNhcmQgPSAoY2FyZElkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBDYXJyZWdhciBhcyBjYXJ0YXMgZXhpc3RlbnRlc1xuICAgIGNvbnN0IGNhcmRzID0gbG9hZFNwb2lsZXJDYXJkcygpXG4gICAgXG4gICAgLy8gUmVtb3ZlciBhIGNhcnRhIGNvbSBvIElEIGVzcGVjaWZpY2Fkb1xuICAgIGNvbnN0IHVwZGF0ZWRDYXJkcyA9IGNhcmRzLmZpbHRlcihjYXJkID0+IGNhcmQuaWQgIT09IGNhcmRJZClcbiAgICBcbiAgICAvLyBSZW1vdmVyIGEgaW1hZ2VtIGRhIGNhcnRhXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGBtdGctc3BvaWxlci1pbWFnZS0ke2NhcmRJZH1gKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTsOjbyBmb2kgcG9zc8OtdmVsIHJlbW92ZXIgYSBpbWFnZW0gZGEgY2FydGEgJHtjYXJkSWR9OmAsIGUpXG4gICAgfVxuICAgIFxuICAgIC8vIFNhbHZhciBhcyBjYXJ0YXMgYXR1YWxpemFkYXNcbiAgICByZXR1cm4gc2F2ZVNwb2lsZXJDYXJkcyh1cGRhdGVkQ2FyZHMpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJybyBhbyByZW1vdmVyIGNhcnRhIGRlIHNwb2lsZXI6JywgZXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0iXSwibmFtZXMiOlsiTUFYX1NUT1JBR0VfU0laRSIsInNhdmVTcG9pbGVyQ2FyZHMiLCJjYXJkcyIsImNhcmRzV2l0aG91dEltYWdlcyIsIm1hcCIsImNhcmQiLCJpbWFnZV91cmlzIiwiY2FyZFdpdGhvdXRJbWFnZSIsImltYWdlX3JlZiIsImlkIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JFYWNoIiwibm9ybWFsIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwibmFtZSIsImVycm9yIiwibG9hZFNwb2lsZXJDYXJkcyIsImNhcmRzRGF0YUpzb24iLCJnZXRJdGVtIiwiY2FyZHNEYXRhIiwicGFyc2UiLCJpbWFnZVVyaSIsImNhcmRXaXRob3V0UmVmIiwibGFyZ2UiLCJwbmciLCJhcnRfY3JvcCIsImNsZWFyU3BvaWxlckNhcmRzIiwia2V5cyIsImkiLCJsZW5ndGgiLCJrZXkiLCJzdGFydHNXaXRoIiwicHVzaCIsInJlbW92ZUl0ZW0iLCJhZGRTcG9pbGVyQ2FyZCIsInVuc2hpZnQiLCJhZGRTcG9pbGVyQ2FyZHMiLCJuZXdDYXJkcyIsInVwZGF0ZWRDYXJkcyIsInJlbW92ZVNwb2lsZXJDYXJkIiwiY2FyZElkIiwiZmlsdGVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/storage.ts\n"));

/***/ })

});