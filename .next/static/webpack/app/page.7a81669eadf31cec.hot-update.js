"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./contexts/AppContext.tsx":
/*!*********************************!*\
  !*** ./contexts/AppContext.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: function() { return /* binding */ AppProvider; },\n/* harmony export */   useAppContext: function() { return /* binding */ useAppContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_apiService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/apiService */ \"(app-pages-browser)/./utils/apiService.ts\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ useAppContext,AppProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useAppContext = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (!context) {\n        throw new Error(\"useAppContext deve ser usado dentro de um AppProvider\");\n    }\n    return context;\n};\n_s(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst AppProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession)();\n    const [collections, setCollections] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCollectionId, setCurrentCollectionId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [decks, setDecks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [favorites, setFavorites] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const currentCollection = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(()=>{\n        return collections.find((c)=>c.id === currentCollectionId);\n    }, [\n        collections,\n        currentCollectionId\n    ]);\n    // Carregar dados da API quando o usuário estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (session) {\n                setLoading(true);\n                try {\n                    // Carregar coleções\n                    const collectionsResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getAll();\n                    if (collectionsResponse.success && collectionsResponse.data) {\n                        setCollections(collectionsResponse.data);\n                        if (collectionsResponse.data.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(collectionsResponse.data[0].id);\n                        }\n                    }\n                    // Carregar decks\n                    const decksResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getAll();\n                    if (decksResponse.success && decksResponse.data) {\n                        setDecks(decksResponse.data);\n                    }\n                    // Carregar favoritos\n                    const favoritesResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.getAll();\n                    if (favoritesResponse.success && favoritesResponse.data) {\n                        setFavorites(favoritesResponse.data.map((fav)=>fav.card));\n                    }\n                } catch (error) {\n                    console.error(\"Erro ao carregar dados:\", error);\n                } finally{\n                    setLoading(false);\n                }\n            } else {\n                // Usuário não autenticado, usar localStorage como fallback\n                const savedCollections = localStorage.getItem(\"mtg-collections\");\n                if (savedCollections) {\n                    try {\n                        const parsedCollections = JSON.parse(savedCollections);\n                        setCollections(parsedCollections);\n                        if (parsedCollections.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(parsedCollections[0].id);\n                        }\n                    } catch (error) {\n                        console.error(\"Erro ao carregar cole\\xe7\\xf5es salvas:\", error);\n                    }\n                } else {\n                    // Criar uma coleção padrão se não houver nenhuma\n                    const defaultCollection = {\n                        id: \"1\",\n                        name: \"Minha Cole\\xe7\\xe3o\",\n                        description: \"Cole\\xe7\\xe3o principal de cartas Magic\",\n                        cards: [],\n                        createdAt: new Date().toISOString(),\n                        updatedAt: new Date().toISOString(),\n                        isPublic: false\n                    };\n                    setCollections([\n                        defaultCollection\n                    ]);\n                    setCurrentCollectionId(defaultCollection.id);\n                }\n                const savedDecks = localStorage.getItem(\"mtg-decks\");\n                if (savedDecks) {\n                    try {\n                        const parsedDecks = JSON.parse(savedDecks);\n                        setDecks(parsedDecks);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar decks salvos:\", error);\n                    }\n                }\n                const savedFavorites = localStorage.getItem(\"mtg-favorites\");\n                if (savedFavorites) {\n                    try {\n                        const parsedFavorites = JSON.parse(savedFavorites);\n                        setFavorites(parsedFavorites);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar favoritos salvos:\", error);\n                    }\n                }\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        session\n    ]);\n    // Salvar dados no localStorage quando não estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-collections\", JSON.stringify(collections));\n        }\n    }, [\n        collections,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-decks\", JSON.stringify(decks));\n        }\n    }, [\n        decks,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-favorites\", JSON.stringify(favorites));\n        }\n    }, [\n        favorites,\n        session\n    ]);\n    // Funções de gerenciamento de coleção\n    const createCollection = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.create({\n                    name,\n                    description\n                });\n                if (response.success && response.data) {\n                    setCollections((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    setCurrentCollectionId(response.data.id);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar cole\\xe7\\xe3o\");\n            } catch (error) {\n                console.error(\"Erro ao criar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                id: Date.now().toString(),\n                name,\n                description,\n                cards: [],\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n                isPublic: false\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n            setCurrentCollectionId(newCollection.id);\n            return newCollection.id;\n        }\n    };\n    const updateCollection = async (id, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.update(id, updates);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                                ...c,\n                                ...updates\n                            } : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                        ...c,\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    } : c));\n        }\n    };\n    const deleteCollection = async (id)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.delete(id);\n                if (response.success) {\n                    setCollections((prev)=>{\n                        const newCollections = prev.filter((c)=>c.id !== id);\n                        if (currentCollectionId === id) {\n                            setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                        }\n                        return newCollections;\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erro ao excluir cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>{\n                const newCollections = prev.filter((c)=>c.id !== id);\n                if (currentCollectionId === id) {\n                    setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                }\n                return newCollections;\n            });\n        }\n    };\n    const duplicateCollection = async (id)=>{\n        const collectionToDuplicate = collections.find((c)=>c.id === id);\n        if (!collectionToDuplicate) return;\n        if (session) {\n            try {\n                const newCollection = {\n                    name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\"),\n                    description: collectionToDuplicate.description,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.create(newCollection);\n                if (response.success && response.data) {\n                    // Adicionar cartas à nova coleção\n                    for (const cardItem of collectionToDuplicate.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            condition: cardItem.condition,\n                            foil: cardItem.foil,\n                            language: cardItem.language\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setCollections((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Erro ao duplicar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                ...collectionToDuplicate,\n                id: Date.now().toString(),\n                name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\")\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n        }\n    };\n    // Função para adicionar carta à coleção\n    const adicionarCarta = async function(card) {\n        let quantidade = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.addCard(currentCollectionId, {\n                    card,\n                    quantity: quantidade,\n                    condition: \"Near Mint\",\n                    foil: false,\n                    language: \"English\"\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity + quantidade\n                            } : cc);\n                    } else {\n                        newCards = [\n                            ...c.cards,\n                            {\n                                card,\n                                quantity: quantidade,\n                                condition: \"Near Mint\",\n                                foil: false\n                            }\n                        ];\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para remover carta da coleção\n    const removerCarta = async (card)=>{\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                // Encontrar o ID da carta na coleção\n                const collection = collections.find((c)=>c.id === currentCollectionId);\n                if (!collection) return;\n                const cardInCollection = collection.cards.find((cc)=>cc.card.id === card.id);\n                if (!cardInCollection) return;\n                if (cardInCollection.quantity > 1) {\n                    // Atualizar quantidade\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.updateCard(currentCollectionId, cardInCollection._id, {\n                        quantity: cardInCollection.quantity - 1\n                    });\n                } else {\n                    // Remover carta\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.removeCard(currentCollectionId, cardInCollection._id);\n                }\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard && existingCard.quantity > 1) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity - 1\n                            } : cc);\n                    } else {\n                        newCards = c.cards.filter((cc)=>cc.card.id !== card.id);\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para obter quantidade de uma carta na coleção\n    const getQuantidadeNaColecao = (cardId)=>{\n        var _currentCollection_cards;\n        const card = currentCollection === null || currentCollection === void 0 ? void 0 : (_currentCollection_cards = currentCollection.cards) === null || _currentCollection_cards === void 0 ? void 0 : _currentCollection_cards.find((c)=>c.card.id === cardId);\n        return card ? card.quantity : 0;\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE DECKS ======\n    // Criar novo deck\n    const criarDeck = async (deckData)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.create(deckData);\n                if (response.success && response.data) {\n                    setDecks((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar deck\");\n            } catch (error) {\n                console.error(\"Erro ao criar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newDeck = {\n                ...deckData,\n                id: Date.now().toString(),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    newDeck\n                ]);\n            return newDeck.id;\n        }\n    };\n    // Editar deck existente\n    const editarDeck = async (deckId, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.update(deckId, updates);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                                ...deck,\n                                ...updates\n                            } : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao editar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                        ...deck,\n                        ...updates,\n                        lastModified: new Date().toISOString()\n                    } : deck));\n        }\n    };\n    // Deletar deck\n    const deletarDeck = async (deckId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.delete(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao deletar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n        }\n    };\n    // Duplicar deck\n    const duplicarDeck = async (deckId, newName)=>{\n        const originalDeck = decks.find((deck)=>deck.id === deckId);\n        if (!originalDeck) return undefined;\n        if (session) {\n            try {\n                const newDeckData = {\n                    name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                    description: originalDeck.description,\n                    format: originalDeck.format,\n                    colors: originalDeck.colors,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.create(newDeckData);\n                if (response.success && response.data) {\n                    // Adicionar cartas ao novo deck\n                    for (const cardItem of originalDeck.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            isSideboard: cardItem.category === \"sideboard\",\n                            isCommander: cardItem.category === \"commander\",\n                            category: cardItem.category\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setDecks((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                        return updatedResponse.data.id;\n                    }\n                }\n                return undefined;\n            } catch (error) {\n                console.error(\"Erro ao duplicar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const duplicatedDeck = {\n                ...originalDeck,\n                id: Date.now().toString(),\n                name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    duplicatedDeck\n                ]);\n            return duplicatedDeck.id;\n        }\n    };\n    // Adicionar carta ao deck\n    const adicionarCartaAoDeck = async function(deckId, card) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\", quantity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.addCard(deckId, {\n                    card,\n                    quantity,\n                    isSideboard: category === \"sideboard\",\n                    isCommander: category === \"commander\",\n                    category\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta ao deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        const existingCard = deck.cards.find((c)=>c.card.id === card.id && c.category === category);\n                        if (existingCard) {\n                            return {\n                                ...deck,\n                                cards: deck.cards.map((c)=>c.card.id === card.id && c.category === category ? {\n                                        ...c,\n                                        quantity: c.quantity + quantity\n                                    } : c),\n                                lastModified: new Date().toISOString()\n                            };\n                        } else {\n                            return {\n                                ...deck,\n                                cards: [\n                                    ...deck.cards,\n                                    {\n                                        card,\n                                        quantity,\n                                        category\n                                    }\n                                ],\n                                lastModified: new Date().toISOString()\n                            };\n                        }\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Remover carta do deck\n    const removerCartaDoDeck = async function(deckId, cardId) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\";\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.removeCard(deckId, cardInDeck._id);\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta do deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.filter((c)=>!(c.card.id === cardId && c.category === category)),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Atualizar quantidade de carta no deck\n    const atualizarQuantidadeNoDeck = async function(deckId, cardId, novaQuantidade) {\n        let category = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"mainboard\";\n        if (novaQuantidade <= 0) {\n            await removerCartaDoDeck(deckId, cardId, category);\n            return;\n        }\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.updateCard(deckId, cardInDeck._id, {\n                    quantity: novaQuantidade\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar quantidade no deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.map((c)=>c.card.id === cardId && c.category === category ? {\n                                    ...c,\n                                    quantity: novaQuantidade\n                                } : c),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Obter cartas que estão sendo usadas em decks\n    const getCartasUsadasEmDecks = (cardId)=>{\n        const result = [];\n        decks.forEach((deck)=>{\n            deck.cards.forEach((deckCard)=>{\n                if (deckCard.card.id === cardId) {\n                    result.push({\n                        deck,\n                        quantity: deckCard.quantity,\n                        category: deckCard.category\n                    });\n                }\n            });\n        });\n        return result;\n    };\n    // Função para importar deck a partir de uma lista de texto\n    const importarDeckDeLista = async (deckList, deckData)=>{\n        try {\n            // Criar o deck vazio primeiro\n            const deckId = await criarDeck({\n                name: deckData.name,\n                format: deckData.format,\n                description: deckData.description || \"\",\n                colors: deckData.colors || [],\n                cards: [],\n                isPublic: deckData.isPublic || false,\n                tags: deckData.tags || []\n            });\n            // Processar a lista de cartas\n            const lines = deckList.split(\"\\n\").filter((line)=>line.trim());\n            let currentSection = \"mainboard\";\n            const cardPromises = [];\n            for (const line of lines){\n                const trimmedLine = line.trim().toLowerCase();\n                // Verificar se é uma linha de seção\n                if (trimmedLine.includes(\"sideboard\")) {\n                    currentSection = \"sideboard\";\n                    continue;\n                }\n                if (trimmedLine.includes(\"commander\")) {\n                    currentSection = \"commander\";\n                    continue;\n                }\n                // Verificar se é uma linha de carta\n                const match = line.match(/^(\\d+)x?\\s+(.+)$/);\n                if (match) {\n                    const quantity = parseInt(match[1]);\n                    const cardName = match[2].trim();\n                    // Buscar a carta na API do Scryfall\n                    cardPromises.push((async ()=>{\n                        try {\n                            const response = await fetch(\"https://api.scryfall.com/cards/named?fuzzy=\".concat(encodeURIComponent(cardName)));\n                            if (response.ok) {\n                                const cardData = await response.json();\n                                // Adicionar a carta ao deck\n                                await adicionarCartaAoDeck(deckId, cardData, currentSection, quantity);\n                                return {\n                                    success: true,\n                                    card: cardName\n                                };\n                            } else {\n                                console.error(\"Carta n\\xe3o encontrada: \".concat(cardName));\n                                return {\n                                    success: false,\n                                    card: cardName\n                                };\n                            }\n                        } catch (error) {\n                            console.error(\"Erro ao buscar carta \".concat(cardName, \":\"), error);\n                            return {\n                                success: false,\n                                card: cardName\n                            };\n                        }\n                    })());\n                }\n            }\n            // Aguardar todas as cartas serem processadas\n            const results = await Promise.allSettled(cardPromises);\n            const failedCards = results.filter((result)=>result.status === \"fulfilled\" && !result.value.success).map((result)=>result.status === \"fulfilled\" ? result.value.card : \"Unknown\");\n            if (failedCards.length > 0) {\n                console.warn(\"Algumas cartas n\\xe3o foram encontradas: \".concat(failedCards.join(\", \")));\n            }\n            return deckId;\n        } catch (error) {\n            console.error(\"Erro ao importar deck:\", error);\n            throw new Error(\"Falha ao importar deck. Verifique o formato da lista.\");\n        }\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE FAVORITOS ======\n    // Adicionar carta aos favoritos\n    const addFavorite = async (card)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.add(card);\n                if (response.success) {\n                    setFavorites((prev)=>[\n                            ...prev,\n                            card\n                        ]);\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>{\n                if (prev.some((c)=>c.id === card.id)) return prev;\n                return [\n                    ...prev,\n                    card\n                ];\n            });\n        }\n    };\n    // Remover carta dos favoritos\n    const removeFavorite = async (cardId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.removeCard(cardId);\n                if (response.success) {\n                    setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n        }\n    };\n    // Verificar se uma carta está nos favoritos\n    const isFavorite = (cardId)=>{\n        return favorites.some((card)=>card.id === cardId);\n    };\n    // Função para exportar coleção para CSV no formato Manabox\n    const exportCollectionToCSV = (collection)=>{\n        // Formato Manabox: Name,Set,Quantity,Foil,Condition,Language\n        const csvContent = [\n            [\n                \"Name\",\n                \"Set\",\n                \"Quantity\",\n                \"Foil\",\n                \"Condition\",\n                \"Language\"\n            ],\n            ...collection.cards.map((c)=>[\n                    c.card.name,\n                    c.card.set_code,\n                    c.quantity.toString(),\n                    c.foil ? \"Foil\" : \"Non-foil\",\n                    c.condition || \"Near Mint\",\n                    c.language || \"English\"\n                ])\n        ].map((row)=>row.join(\",\")).join(\"\\n\");\n        const blob = new Blob([\n            csvContent\n        ], {\n            type: \"text/csv\"\n        });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"\".concat(collection.name, \"_manabox.csv\");\n        a.click();\n        window.URL.revokeObjectURL(url);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: {\n            collections,\n            currentCollection,\n            setCurrentCollection: setCollections,\n            currentCollectionId,\n            setCurrentCollectionId,\n            createCollection,\n            updateCollection,\n            deleteCollection,\n            duplicateCollection,\n            adicionarCarta,\n            removerCarta,\n            getQuantidadeNaColecao,\n            decks,\n            setDecks,\n            criarDeck,\n            editarDeck,\n            deletarDeck,\n            duplicarDeck,\n            adicionarCartaAoDeck,\n            removerCartaDoDeck,\n            atualizarQuantidadeNoDeck,\n            getCartasUsadasEmDecks,\n            importarDeckDeLista,\n            favorites,\n            addFavorite,\n            removeFavorite,\n            isFavorite,\n            loading,\n            exportCollectionToCSV\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Rodrigo\\\\Downloads\\\\MTG HELP\\\\contexts\\\\AppContext.tsx\",\n        lineNumber: 853,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(AppProvider, \"P5slHoOyqMDp2BOUreOP8tfxRtM=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession\n    ];\n});\n_c = AppProvider;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL0FwcENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFeUY7QUFHSjtBQUN4QztBQTBDN0MsTUFBTVMsMkJBQWFSLG9EQUFhQSxDQUF3QjtBQUVqRCxNQUFNUyxnQkFBZ0I7O0lBQzNCLE1BQU1DLFVBQVVULGlEQUFVQSxDQUFDTztJQUMzQixJQUFJLENBQUNFLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7R0FOV0Q7QUFZTixNQUFNRyxjQUEwQztRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDbEUsTUFBTSxFQUFFQyxNQUFNQyxPQUFPLEVBQUUsR0FBR1IsMkRBQVVBO0lBQ3BDLE1BQU0sQ0FBQ1MsYUFBYUMsZUFBZSxHQUFHZiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUNuRSxNQUFNLENBQUNnQixxQkFBcUJDLHVCQUF1QixHQUFHakIsK0NBQVFBLENBQWdCO0lBQzlFLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDb0IsV0FBV0MsYUFBYSxHQUFHckIsK0NBQVFBLENBQVksRUFBRTtJQUN4RCxNQUFNLENBQUNzQixTQUFTQyxXQUFXLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUV2QyxNQUFNd0Isb0JBQW9CM0Isb0RBQWEsQ0FBQztRQUN0QyxPQUFPaUIsWUFBWVksSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaO0lBQ3hDLEdBQUc7UUFBQ0Y7UUFBYUU7S0FBb0I7SUFFckMsNkRBQTZEO0lBQzdEZixnREFBU0EsQ0FBQztRQUNSLE1BQU00QixXQUFXO1lBQ2YsSUFBSWhCLFNBQVM7Z0JBQ1hVLFdBQVc7Z0JBQ1gsSUFBSTtvQkFDRixvQkFBb0I7b0JBQ3BCLE1BQU1PLHNCQUFzQixNQUFNNUIsZ0VBQWlCQSxDQUFDNkIsTUFBTTtvQkFDMUQsSUFBSUQsb0JB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WUFDQUk7WUFDQUc7WUFDQUM7WUFDQVc7WUFDQUM7WUFDQUc7WUFDQUU7WUFDQUs7WUFDQTdHO1lBQ0F5STtZQUNBRztZQUNBQztZQUNBM0k7WUFDQTRJO1FBQ0Y7a0JBQ0d2Sjs7Ozs7O0FBR1AsRUFBRTtJQXh6QldEOztRQUNlTCx1REFBVUE7OztLQUR6QksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvQXBwQ29udGV4dC50c3g/MjUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRydW5jYXRlQ2FyZERhdGEgfSBmcm9tICdAL3V0aWxzL3N0b3JhZ2VVdGlscyc7XG5pbXBvcnQgdHlwZSB7IE1UR0NhcmQsIFVzZXJDb2xsZWN0aW9uLCBDb2xsZWN0aW9uQ2FyZCwgRGVjaywgRGVja0NhcmQgfSBmcm9tICdAL3R5cGVzL210Zyc7XG5pbXBvcnQgeyBjb2xsZWN0aW9uU2VydmljZSwgZGVja1NlcnZpY2UsIGZhdm9yaXRlU2VydmljZSB9IGZyb20gJ0AvdXRpbHMvYXBpU2VydmljZSc7XG5pbXBvcnQgeyB1c2VTZXNzaW9uIH0gZnJvbSAnbmV4dC1hdXRoL3JlYWN0JztcblxuaW50ZXJmYWNlIEFwcENvbnRleHRUeXBlIHtcbiAgY29sbGVjdGlvbnM6IFVzZXJDb2xsZWN0aW9uW107XG4gIGN1cnJlbnRDb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbiB8IHVuZGVmaW5lZDtcbiAgc2V0Q3VycmVudENvbGxlY3Rpb246IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPFVzZXJDb2xsZWN0aW9uW10+PjtcbiAgY3VycmVudENvbGxlY3Rpb25JZDogc3RyaW5nIHwgbnVsbDtcbiAgc2V0Q3VycmVudENvbGxlY3Rpb25JZDogKGlkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBjcmVhdGVDb2xsZWN0aW9uOiAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICB1cGRhdGVDb2xsZWN0aW9uOiAoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxVc2VyQ29sbGVjdGlvbj4pID0+IFByb21pc2U8dm9pZD47XG4gIGRlbGV0ZUNvbGxlY3Rpb246IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkdXBsaWNhdGVDb2xsZWN0aW9uOiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgYWRpY2lvbmFyQ2FydGE6IChjYXJkOiBNVEdDYXJkLCBxdWFudGlkYWRlPzogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZW1vdmVyQ2FydGE6IChjYXJkOiBNVEdDYXJkKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBnZXRRdWFudGlkYWRlTmFDb2xlY2FvOiAoY2FyZElkOiBzdHJpbmcpID0+IG51bWJlcjtcbiAgXG4gIC8vIEdlcmVuY2lhbWVudG8gZGUgRGVja3NcbiAgZGVja3M6IERlY2tbXTtcbiAgc2V0RGVja3M6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPERlY2tbXT4+O1xuICBjcmlhckRlY2s6IChkZWNrOiBPbWl0PERlY2ssICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdsYXN0TW9kaWZpZWQnPikgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICBlZGl0YXJEZWNrOiAoZGVja0lkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8RGVjaz4pID0+IFByb21pc2U8dm9pZD47XG4gIGRlbGV0YXJEZWNrOiAoZGVja0lkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGR1cGxpY2FyRGVjazogKGRlY2tJZDogc3RyaW5nLCBuZXdOYW1lPzogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD47XG4gIGFkaWNpb25hckNhcnRhQW9EZWNrOiAoZGVja0lkOiBzdHJpbmcsIGNhcmQ6IE1UR0NhcmQsIGNhdGVnb3J5PzogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInLCBxdWFudGl0eT86IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVtb3ZlckNhcnRhRG9EZWNrOiAoZGVja0lkOiBzdHJpbmcsIGNhcmRJZDogc3RyaW5nLCBjYXRlZ29yeT86ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgYXR1YWxpemFyUXVhbnRpZGFkZU5vRGVjazogKGRlY2tJZDogc3RyaW5nLCBjYXJkSWQ6IHN0cmluZywgbm92YVF1YW50aWRhZGU6IG51bWJlciwgY2F0ZWdvcnk/OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicpID0+IFByb21pc2U8dm9pZD47XG4gIGdldENhcnRhc1VzYWRhc0VtRGVja3M6IChjYXJkSWQ6IHN0cmluZykgPT4gQXJyYXk8e2RlY2s6IERlY2ssIHF1YW50aXR5OiBudW1iZXIsIGNhdGVnb3J5OiBzdHJpbmd9PjtcbiAgaW1wb3J0YXJEZWNrRGVMaXN0YTogKGRlY2tMaXN0OiBzdHJpbmcsIGRlY2tEYXRhOiBhbnkpID0+IFByb21pc2U8c3RyaW5nPjtcbiAgXG4gIC8vIEZhdm9yaXRvc1xuICBmYXZvcml0ZXM6IE1UR0NhcmRbXTtcbiAgYWRkRmF2b3JpdGU6IChjYXJkOiBNVEdDYXJkKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZW1vdmVGYXZvcml0ZTogKGNhcmRJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBpc0Zhdm9yaXRlOiAoY2FyZElkOiBzdHJpbmcpID0+IGJvb2xlYW47XG4gIFxuICAvLyBFc3RhZG8gZGUgY2FycmVnYW1lbnRvXG4gIGxvYWRpbmc6IGJvb2xlYW47XG4gIFxuICAvLyBFeHBvcnRhw6fDo29cbiAgZXhwb3J0Q29sbGVjdGlvblRvQ1NWOiAoY29sbGVjdGlvbjogVXNlckNvbGxlY3Rpb24pID0+IHZvaWQ7XG59XG5cbmNvbnN0IEFwcENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEFwcENvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG5cbmV4cG9ydCBjb25zdCB1c2VBcHBDb250ZXh0ID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBcHBDb250ZXh0IGRldmUgc2VyIHVzYWRvIGRlbnRybyBkZSB1bSBBcHBQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuaW50ZXJmYWNlIEFwcFByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgY29uc3QgQXBwUHJvdmlkZXI6IFJlYWN0LkZDPEFwcFByb3ZpZGVyUHJvcHM+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcbiAgY29uc3QgW2NvbGxlY3Rpb25zLCBzZXRDb2xsZWN0aW9uc10gPSB1c2VTdGF0ZTxVc2VyQ29sbGVjdGlvbltdPihbXSk7XG4gIGNvbnN0IFtjdXJyZW50Q29sbGVjdGlvbklkLCBzZXRDdXJyZW50Q29sbGVjdGlvbklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZGVja3MsIHNldERlY2tzXSA9IHVzZVN0YXRlPERlY2tbXT4oW10pO1xuICBjb25zdCBbZmF2b3JpdGVzLCBzZXRGYXZvcml0ZXNdID0gdXNlU3RhdGU8TVRHQ2FyZFtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIGNvbnN0IGN1cnJlbnRDb2xsZWN0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBjdXJyZW50Q29sbGVjdGlvbklkKTtcbiAgfSwgW2NvbGxlY3Rpb25zLCBjdXJyZW50Q29sbGVjdGlvbklkXSk7XG5cbiAgLy8gQ2FycmVnYXIgZGFkb3MgZGEgQVBJIHF1YW5kbyBvIHVzdcOhcmlvIGVzdGl2ZXIgYXV0ZW50aWNhZG9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ2FycmVnYXIgY29sZcOnw7Vlc1xuICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25zUmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5nZXRBbGwoKTtcbiAgICAgICAgICBpZiAoY29sbGVjdGlvbnNSZXNwb25zZS5zdWNjZXNzICYmIGNvbGxlY3Rpb25zUmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgc2V0Q29sbGVjdGlvbnMoY29sbGVjdGlvbnNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uc1Jlc3BvbnNlLmRhdGEubGVuZ3RoID4gMCAmJiAhY3VycmVudENvbGxlY3Rpb25JZCkge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKGNvbGxlY3Rpb25zUmVzcG9uc2UuZGF0YVswXS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2FycmVnYXIgZGVja3NcbiAgICAgICAgICBjb25zdCBkZWNrc1Jlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuZ2V0QWxsKCk7XG4gICAgICAgICAgaWYgKGRlY2tzUmVzcG9uc2Uuc3VjY2VzcyAmJiBkZWNrc1Jlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHNldERlY2tzKGRlY2tzUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2FycmVnYXIgZmF2b3JpdG9zXG4gICAgICAgICAgY29uc3QgZmF2b3JpdGVzUmVzcG9uc2UgPSBhd2FpdCBmYXZvcml0ZVNlcnZpY2UuZ2V0QWxsKCk7XG4gICAgICAgICAgaWYgKGZhdm9yaXRlc1Jlc3BvbnNlLnN1Y2Nlc3MgJiYgZmF2b3JpdGVzUmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgc2V0RmF2b3JpdGVzKGZhdm9yaXRlc1Jlc3BvbnNlLmRhdGEubWFwKChmYXY6IGFueSkgPT4gZmF2LmNhcmQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBkYWRvczonLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzdcOhcmlvIG7Do28gYXV0ZW50aWNhZG8sIHVzYXIgbG9jYWxTdG9yYWdlIGNvbW8gZmFsbGJhY2tcbiAgICAgICAgY29uc3Qgc2F2ZWRDb2xsZWN0aW9ucyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdtdGctY29sbGVjdGlvbnMnKTtcbiAgICAgICAgaWYgKHNhdmVkQ29sbGVjdGlvbnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQ29sbGVjdGlvbnMgPSBKU09OLnBhcnNlKHNhdmVkQ29sbGVjdGlvbnMpO1xuICAgICAgICAgICAgc2V0Q29sbGVjdGlvbnMocGFyc2VkQ29sbGVjdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZENvbGxlY3Rpb25zLmxlbmd0aCA+IDAgJiYgIWN1cnJlbnRDb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChwYXJzZWRDb2xsZWN0aW9uc1swXS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY2FycmVnYXIgY29sZcOnw7VlcyBzYWx2YXM6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDcmlhciB1bWEgY29sZcOnw6NvIHBhZHLDo28gc2UgbsOjbyBob3V2ZXIgbmVuaHVtYVxuICAgICAgICAgIGNvbnN0IGRlZmF1bHRDb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgICBuYW1lOiAnTWluaGEgQ29sZcOnw6NvJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ29sZcOnw6NvIHByaW5jaXBhbCBkZSBjYXJ0YXMgTWFnaWMnLFxuICAgICAgICAgICAgY2FyZHM6IFtdLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlzUHVibGljOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMoW2RlZmF1bHRDb2xsZWN0aW9uXSk7XG4gICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChkZWZhdWx0Q29sbGVjdGlvbi5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzYXZlZERlY2tzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ210Zy1kZWNrcycpO1xuICAgICAgICBpZiAoc2F2ZWREZWNrcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREZWNrcyA9IEpTT04ucGFyc2Uoc2F2ZWREZWNrcyk7XG4gICAgICAgICAgICBzZXREZWNrcyhwYXJzZWREZWNrcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY2FycmVnYXIgZGVja3Mgc2Fsdm9zOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzYXZlZEZhdm9yaXRlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdtdGctZmF2b3JpdGVzJyk7XG4gICAgICAgIGlmIChzYXZlZEZhdm9yaXRlcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRGYXZvcml0ZXMgPSBKU09OLnBhcnNlKHNhdmVkRmF2b3JpdGVzKTtcbiAgICAgICAgICAgIHNldEZhdm9yaXRlcyhwYXJzZWRGYXZvcml0ZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGZhdm9yaXRvcyBzYWx2b3M6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxvYWREYXRhKCk7XG4gIH0sIFtzZXNzaW9uXSk7XG5cbiAgLy8gU2FsdmFyIGRhZG9zIG5vIGxvY2FsU3RvcmFnZSBxdWFuZG8gbsOjbyBlc3RpdmVyIGF1dGVudGljYWRvXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbXRnLWNvbGxlY3Rpb25zJywgSlNPTi5zdHJpbmdpZnkoY29sbGVjdGlvbnMpKTtcbiAgICB9XG4gIH0sIFtjb2xsZWN0aW9ucywgc2Vzc2lvbl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbXRnLWRlY2tzJywgSlNPTi5zdHJpbmdpZnkoZGVja3MpKTtcbiAgICB9XG4gIH0sIFtkZWNrcywgc2Vzc2lvbl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbXRnLWZhdm9yaXRlcycsIEpTT04uc3RyaW5naWZ5KGZhdm9yaXRlcykpO1xuICAgIH1cbiAgfSwgW2Zhdm9yaXRlcywgc2Vzc2lvbl0pO1xuXG4gIC8vIEZ1bsOnw7VlcyBkZSBnZXJlbmNpYW1lbnRvIGRlIGNvbGXDp8Ojb1xuICBjb25zdCBjcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZyA9ICcnKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5jcmVhdGUoeyBuYW1lLCBkZXNjcmlwdGlvbiB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gWy4uLnByZXYsIHJlc3BvbnNlLmRhdGFdKTtcbiAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKHJlc3BvbnNlLmRhdGEuaWQpO1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJybyBhbyBjcmlhciBjb2xlw6fDo28nKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY3JpYXIgY29sZcOnw6NvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBuZXdDb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbiA9IHtcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGNhcmRzOiBbXSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBpc1B1YmxpYzogZmFsc2UsXG4gICAgICB9O1xuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBbLi4ucHJldiwgbmV3Q29sbGVjdGlvbl0pO1xuICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChuZXdDb2xsZWN0aW9uLmlkKTtcbiAgICAgIHJldHVybiBuZXdDb2xsZWN0aW9uLmlkO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVDb2xsZWN0aW9uID0gYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VXNlckNvbGxlY3Rpb24+KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UudXBkYXRlKGlkLCB1cGRhdGVzKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gaWQgPyB7IC4uLmMsIC4uLnVwZGF0ZXMgfSA6IGMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhdHVhbGl6YXIgY29sZcOnw6NvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gaWQgPyB7IC4uLmMsIC4uLnVwZGF0ZXMsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0gOiBjKSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRlbGV0ZUNvbGxlY3Rpb24gPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmRlbGV0ZShpZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb2xsZWN0aW9ucyA9IHByZXYuZmlsdGVyKGMgPT4gYy5pZCAhPT0gaWQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb2xsZWN0aW9uSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQobmV3Q29sbGVjdGlvbnMubGVuZ3RoID4gMCA/IG5ld0NvbGxlY3Rpb25zWzBdLmlkIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3Q29sbGVjdGlvbnM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZXhjbHVpciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4ge1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aW9ucyA9IHByZXYuZmlsdGVyKGMgPT4gYy5pZCAhPT0gaWQpO1xuICAgICAgICBpZiAoY3VycmVudENvbGxlY3Rpb25JZCA9PT0gaWQpIHtcbiAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKG5ld0NvbGxlY3Rpb25zLmxlbmd0aCA+IDAgPyBuZXdDb2xsZWN0aW9uc1swXS5pZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdDb2xsZWN0aW9ucztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBkdXBsaWNhdGVDb2xsZWN0aW9uID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCBjb2xsZWN0aW9uVG9EdXBsaWNhdGUgPSBjb2xsZWN0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gaWQpO1xuICAgIGlmICghY29sbGVjdGlvblRvRHVwbGljYXRlKSByZXR1cm47XG5cbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlvbiA9IHtcbiAgICAgICAgICBuYW1lOiBgJHtjb2xsZWN0aW9uVG9EdXBsaWNhdGUubmFtZX0gKEPDs3BpYSlgLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBjb2xsZWN0aW9uVG9EdXBsaWNhdGUuZGVzY3JpcHRpb24sXG4gICAgICAgICAgaXNQdWJsaWM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmNyZWF0ZShuZXdDb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIC8vIEFkaWNpb25hciBjYXJ0YXMgw6Agbm92YSBjb2xlw6fDo29cbiAgICAgICAgICBmb3IgKGNvbnN0IGNhcmRJdGVtIG9mIGNvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5jYXJkcykge1xuICAgICAgICAgICAgYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuYWRkQ2FyZChyZXNwb25zZS5kYXRhLmlkLCB7XG4gICAgICAgICAgICAgIGNhcmQ6IGNhcmRJdGVtLmNhcmQsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiBjYXJkSXRlbS5xdWFudGl0eSxcbiAgICAgICAgICAgICAgY29uZGl0aW9uOiBjYXJkSXRlbS5jb25kaXRpb24sXG4gICAgICAgICAgICAgIGZvaWw6IGNhcmRJdGVtLmZvaWwsXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiBjYXJkSXRlbS5sYW5ndWFnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5nZXRCeUlkKHJlc3BvbnNlLmRhdGEuaWQpO1xuICAgICAgICAgIGlmICh1cGRhdGVkUmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBbLi4ucHJldiwgdXBkYXRlZFJlc3BvbnNlLmRhdGFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZHVwbGljYXIgY29sZcOnw6NvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBuZXdDb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbiA9IHtcbiAgICAgICAgLi4uY29sbGVjdGlvblRvRHVwbGljYXRlLFxuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBuYW1lOiBgJHtjb2xsZWN0aW9uVG9EdXBsaWNhdGUubmFtZX0gKEPDs3BpYSlgLFxuICAgICAgfTtcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gWy4uLnByZXYsIG5ld0NvbGxlY3Rpb25dKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuw6fDo28gcGFyYSBhZGljaW9uYXIgY2FydGEgw6AgY29sZcOnw6NvXG4gIGNvbnN0IGFkaWNpb25hckNhcnRhID0gYXN5bmMgKGNhcmQ6IE1UR0NhcmQsIHF1YW50aWRhZGU6IG51bWJlciA9IDEpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWN1cnJlbnRDb2xsZWN0aW9uSWQpIHJldHVybjtcbiAgICBcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuYWRkQ2FyZChjdXJyZW50Q29sbGVjdGlvbklkLCB7XG4gICAgICAgICAgY2FyZCxcbiAgICAgICAgICBxdWFudGl0eTogcXVhbnRpZGFkZSxcbiAgICAgICAgICBjb25kaXRpb246ICdOZWFyIE1pbnQnLFxuICAgICAgICAgIGZvaWw6IGZhbHNlLFxuICAgICAgICAgIGxhbmd1YWdlOiAnRW5nbGlzaCdcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuZ2V0QnlJZChjdXJyZW50Q29sbGVjdGlvbklkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbGxlY3Rpb25JZCA/IHJlc3BvbnNlLmRhdGEgOiBjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYWRpY2lvbmFyIGNhcnRhOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHByZXYubWFwKGMgPT4ge1xuICAgICAgICBpZiAoYy5pZCAhPT0gY3VycmVudENvbGxlY3Rpb25JZCkgcmV0dXJuIGM7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBleGlzdGluZ0NhcmQgPSBjLmNhcmRzLmZpbmQoY2MgPT4gY2MuY2FyZC5pZCA9PT0gY2FyZC5pZCk7XG4gICAgICAgIGxldCBuZXdDYXJkcztcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FyZCkge1xuICAgICAgICAgIG5ld0NhcmRzID0gYy5jYXJkcy5tYXAoY2MgPT5cbiAgICAgICAgICAgIGNjLmNhcmQuaWQgPT09IGNhcmQuaWRcbiAgICAgICAgICAgICAgPyB7IC4uLmNjLCBxdWFudGl0eTogY2MucXVhbnRpdHkgKyBxdWFudGlkYWRlIH1cbiAgICAgICAgICAgICAgOiBjY1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2FyZHMgPSBbLi4uYy5jYXJkcywge1xuICAgICAgICAgICAgY2FyZCxcbiAgICAgICAgICAgIHF1YW50aXR5OiBxdWFudGlkYWRlLFxuICAgICAgICAgICAgY29uZGl0aW9uOiAnTmVhciBNaW50JyxcbiAgICAgICAgICAgIGZvaWw6IGZhbHNlXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uYywgY2FyZHM6IG5ld0NhcmRzLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9O1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW7Dp8OjbyBwYXJhIHJlbW92ZXIgY2FydGEgZGEgY29sZcOnw6NvXG4gIGNvbnN0IHJlbW92ZXJDYXJ0YSA9IGFzeW5jIChjYXJkOiBNVEdDYXJkKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKCFjdXJyZW50Q29sbGVjdGlvbklkKSByZXR1cm47XG4gICAgXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEVuY29udHJhciBvIElEIGRhIGNhcnRhIG5hIGNvbGXDp8Ojb1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gY29sbGVjdGlvbnMuZmluZChjID0+IGMuaWQgPT09IGN1cnJlbnRDb2xsZWN0aW9uSWQpO1xuICAgICAgICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcmRJbkNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmNhcmRzLmZpbmQoY2MgPT4gY2MuY2FyZC5pZCA9PT0gY2FyZC5pZCk7XG4gICAgICAgIGlmICghY2FyZEluQ29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNhcmRJbkNvbGxlY3Rpb24ucXVhbnRpdHkgPiAxKSB7XG4gICAgICAgICAgLy8gQXR1YWxpemFyIHF1YW50aWRhZGVcbiAgICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS51cGRhdGVDYXJkKGN1cnJlbnRDb2xsZWN0aW9uSWQsIGNhcmRJbkNvbGxlY3Rpb24uX2lkLCB7XG4gICAgICAgICAgICBxdWFudGl0eTogY2FyZEluQ29sbGVjdGlvbi5xdWFudGl0eSAtIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmVyIGNhcnRhXG4gICAgICAgICAgYXdhaXQgY29sbGVjdGlvblNlcnZpY2UucmVtb3ZlQ2FyZChjdXJyZW50Q29sbGVjdGlvbklkLCBjYXJkSW5Db2xsZWN0aW9uLl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5nZXRCeUlkKGN1cnJlbnRDb2xsZWN0aW9uSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBjdXJyZW50Q29sbGVjdGlvbklkID8gcmVzcG9uc2UuZGF0YSA6IGMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyByZW1vdmVyIGNhcnRhOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHByZXYubWFwKGMgPT4ge1xuICAgICAgICBpZiAoYy5pZCAhPT0gY3VycmVudENvbGxlY3Rpb25JZCkgcmV0dXJuIGM7XG5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYXJkID0gYy5jYXJkcy5maW5kKGNjID0+IGNjLmNhcmQuaWQgPT09IGNhcmQuaWQpO1xuICAgICAgICBsZXQgbmV3Q2FyZHM7XG4gICAgICAgIGlmIChleGlzdGluZ0NhcmQgJiYgZXhpc3RpbmdDYXJkLnF1YW50aXR5ID4gMSkge1xuICAgICAgICAgIG5ld0NhcmRzID0gYy5jYXJkcy5tYXAoY2MgPT5cbiAgICAgICAgICAgIGNjLmNhcmQuaWQgPT09IGNhcmQuaWRcbiAgICAgICAgICAgICAgPyB7IC4uLmNjLCBxdWFudGl0eTogY2MucXVhbnRpdHkgLSAxIH1cbiAgICAgICAgICAgICAgOiBjY1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q2FyZHMgPSBjLmNhcmRzLmZpbHRlcihjYyA9PiBjYy5jYXJkLmlkICE9PSBjYXJkLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5jLCBjYXJkczogbmV3Q2FyZHMsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH07XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bsOnw6NvIHBhcmEgb2J0ZXIgcXVhbnRpZGFkZSBkZSB1bWEgY2FydGEgbmEgY29sZcOnw6NvXG4gIGNvbnN0IGdldFF1YW50aWRhZGVOYUNvbGVjYW8gPSAoY2FyZElkOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IGNhcmQgPSBjdXJyZW50Q29sbGVjdGlvbj8uY2FyZHM/LmZpbmQoYyA9PiBjLmNhcmQuaWQgPT09IGNhcmRJZCk7XG4gICAgcmV0dXJuIGNhcmQgPyBjYXJkLnF1YW50aXR5IDogMDtcbiAgfTtcblxuICAvLyA9PT09PT0gRlVOw4fDlUVTIERFIEdFUkVOQ0lBTUVOVE8gREUgREVDS1MgPT09PT09XG5cbiAgLy8gQ3JpYXIgbm92byBkZWNrXG4gIGNvbnN0IGNyaWFyRGVjayA9IGFzeW5jIChkZWNrRGF0YTogT21pdDxEZWNrLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAnbGFzdE1vZGlmaWVkJz4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmNyZWF0ZShkZWNrRGF0YSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IFsuLi5wcmV2LCByZXNwb25zZS5kYXRhXSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvIGFvIGNyaWFyIGRlY2snKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY3JpYXIgZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3QgbmV3RGVjazogRGVjayA9IHtcbiAgICAgICAgLi4uZGVja0RhdGEsXG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBzZXREZWNrcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdEZWNrXSk7XG4gICAgICByZXR1cm4gbmV3RGVjay5pZDtcbiAgICB9XG4gIH07XG5cbiAgLy8gRWRpdGFyIGRlY2sgZXhpc3RlbnRlXG4gIGNvbnN0IGVkaXRhckRlY2sgPSBhc3luYyAoZGVja0lkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8RGVjaz4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS51cGRhdGUoZGVja0lkLCB1cGRhdGVzKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gXG4gICAgICAgICAgICBkZWNrLmlkID09PSBkZWNrSWQgXG4gICAgICAgICAgICAgID8geyAuLi5kZWNrLCAuLi51cGRhdGVzIH1cbiAgICAgICAgICAgICAgOiBkZWNrXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZWRpdGFyIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiBcbiAgICAgICAgZGVjay5pZCA9PT0gZGVja0lkIFxuICAgICAgICAgID8geyAuLi5kZWNrLCAuLi51cGRhdGVzLCBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XG4gICAgICAgICAgOiBkZWNrXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVsZXRhciBkZWNrXG4gIGNvbnN0IGRlbGV0YXJEZWNrID0gYXN5bmMgKGRlY2tJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuZGVsZXRlKGRlY2tJZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2LmZpbHRlcihkZWNrID0+IGRlY2suaWQgIT09IGRlY2tJZCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGRlbGV0YXIgZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2LmZpbHRlcihkZWNrID0+IGRlY2suaWQgIT09IGRlY2tJZCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEdXBsaWNhciBkZWNrXG4gIGNvbnN0IGR1cGxpY2FyRGVjayA9IGFzeW5jIChkZWNrSWQ6IHN0cmluZywgbmV3TmFtZT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxEZWNrID0gZGVja3MuZmluZChkZWNrID0+IGRlY2suaWQgPT09IGRlY2tJZCk7XG4gICAgaWYgKCFvcmlnaW5hbERlY2spIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3RGVja0RhdGEgPSB7XG4gICAgICAgICAgbmFtZTogbmV3TmFtZSB8fCBgJHtvcmlnaW5hbERlY2submFtZX0gKEPDs3BpYSlgLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcmlnaW5hbERlY2suZGVzY3JpcHRpb24sXG4gICAgICAgICAgZm9ybWF0OiBvcmlnaW5hbERlY2suZm9ybWF0LFxuICAgICAgICAgIGNvbG9yczogb3JpZ2luYWxEZWNrLmNvbG9ycyxcbiAgICAgICAgICBpc1B1YmxpYzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuY3JlYXRlKG5ld0RlY2tEYXRhKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIC8vIEFkaWNpb25hciBjYXJ0YXMgYW8gbm92byBkZWNrXG4gICAgICAgICAgZm9yIChjb25zdCBjYXJkSXRlbSBvZiBvcmlnaW5hbERlY2suY2FyZHMpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlY2tTZXJ2aWNlLmFkZENhcmQocmVzcG9uc2UuZGF0YS5pZCwge1xuICAgICAgICAgICAgICBjYXJkOiBjYXJkSXRlbS5jYXJkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogY2FyZEl0ZW0ucXVhbnRpdHksXG4gICAgICAgICAgICAgIGlzU2lkZWJvYXJkOiBjYXJkSXRlbS5jYXRlZ29yeSA9PT0gJ3NpZGVib2FyZCcsXG4gICAgICAgICAgICAgIGlzQ29tbWFuZGVyOiBjYXJkSXRlbS5jYXRlZ29yeSA9PT0gJ2NvbW1hbmRlcicsXG4gICAgICAgICAgICAgIGNhdGVnb3J5OiBjYXJkSXRlbS5jYXRlZ29yeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5nZXRCeUlkKHJlc3BvbnNlLmRhdGEuaWQpO1xuICAgICAgICAgIGlmICh1cGRhdGVkUmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgc2V0RGVja3MocHJldiA9PiBbLi4ucHJldiwgdXBkYXRlZFJlc3BvbnNlLmRhdGFdKTtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkUmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZHVwbGljYXIgZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3QgZHVwbGljYXRlZERlY2s6IERlY2sgPSB7XG4gICAgICAgIC4uLm9yaWdpbmFsRGVjayxcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZTogbmV3TmFtZSB8fCBgJHtvcmlnaW5hbERlY2submFtZX0gKEPDs3BpYSlgLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgc2V0RGVja3MocHJldiA9PiBbLi4ucHJldiwgZHVwbGljYXRlZERlY2tdKTtcbiAgICAgIHJldHVybiBkdXBsaWNhdGVkRGVjay5pZDtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRpY2lvbmFyIGNhcnRhIGFvIGRlY2tcbiAgY29uc3QgYWRpY2lvbmFyQ2FydGFBb0RlY2sgPSBhc3luYyAoXG4gICAgZGVja0lkOiBzdHJpbmcsIFxuICAgIGNhcmQ6IE1UR0NhcmQsIFxuICAgIGNhdGVnb3J5OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicgPSAnbWFpbmJvYXJkJyxcbiAgICBxdWFudGl0eTogbnVtYmVyID0gMVxuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGVja1NlcnZpY2UuYWRkQ2FyZChkZWNrSWQsIHtcbiAgICAgICAgICBjYXJkLFxuICAgICAgICAgIHF1YW50aXR5LFxuICAgICAgICAgIGlzU2lkZWJvYXJkOiBjYXRlZ29yeSA9PT0gJ3NpZGVib2FyZCcsXG4gICAgICAgICAgaXNDb21tYW5kZXI6IGNhdGVnb3J5ID09PSAnY29tbWFuZGVyJyxcbiAgICAgICAgICBjYXRlZ29yeVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5nZXRCeUlkKGRlY2tJZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IGRlY2suaWQgPT09IGRlY2tJZCA/IHJlc3BvbnNlLmRhdGEgOiBkZWNrKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYWRpY2lvbmFyIGNhcnRhIGFvIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiB7XG4gICAgICAgIGlmIChkZWNrLmlkID09PSBkZWNrSWQpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NhcmQgPSBkZWNrLmNhcmRzLmZpbmQoYyA9PiBjLmNhcmQuaWQgPT09IGNhcmQuaWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpO1xuICAgICAgICAgIGlmIChleGlzdGluZ0NhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmRlY2ssXG4gICAgICAgICAgICAgIGNhcmRzOiBkZWNrLmNhcmRzLm1hcChjID0+IFxuICAgICAgICAgICAgICAgIGMuY2FyZC5pZCA9PT0gY2FyZC5pZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeVxuICAgICAgICAgICAgICAgICAgPyB7IC4uLmMsIHF1YW50aXR5OiBjLnF1YW50aXR5ICsgcXVhbnRpdHkgfVxuICAgICAgICAgICAgICAgICAgOiBjXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5kZWNrLFxuICAgICAgICAgICAgICBjYXJkczogWy4uLmRlY2suY2FyZHMsIHsgY2FyZCwgcXVhbnRpdHksIGNhdGVnb3J5IH1dLFxuICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY2s7XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZXIgY2FydGEgZG8gZGVja1xuICBjb25zdCByZW1vdmVyQ2FydGFEb0RlY2sgPSBhc3luYyAoXG4gICAgZGVja0lkOiBzdHJpbmcsIFxuICAgIGNhcmRJZDogc3RyaW5nLCBcbiAgICBjYXRlZ29yeTogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInID0gJ21haW5ib2FyZCdcbiAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEVuY29udHJhciBvIElEIGRhIGNhcnRhIG5vIGRlY2tcbiAgICAgICAgY29uc3QgZGVjayA9IGRlY2tzLmZpbmQoZCA9PiBkLmlkID09PSBkZWNrSWQpO1xuICAgICAgICBpZiAoIWRlY2spIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcmRJbkRlY2sgPSBkZWNrLmNhcmRzLmZpbmQoYyA9PiBjLmNhcmQuaWQgPT09IGNhcmRJZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeSk7XG4gICAgICAgIGlmICghY2FyZEluRGVjaykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgZGVja1NlcnZpY2UucmVtb3ZlQ2FyZChkZWNrSWQsIGNhcmRJbkRlY2suX2lkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5nZXRCeUlkKGRlY2tJZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IGRlY2suaWQgPT09IGRlY2tJZCA/IHJlc3BvbnNlLmRhdGEgOiBkZWNrKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gcmVtb3ZlciBjYXJ0YSBkbyBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4ge1xuICAgICAgICBpZiAoZGVjay5pZCA9PT0gZGVja0lkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRlY2ssXG4gICAgICAgICAgICBjYXJkczogZGVjay5jYXJkcy5maWx0ZXIoYyA9PiAhKGMuY2FyZC5pZCA9PT0gY2FyZElkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KSksXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY2s7XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEF0dWFsaXphciBxdWFudGlkYWRlIGRlIGNhcnRhIG5vIGRlY2tcbiAgY29uc3QgYXR1YWxpemFyUXVhbnRpZGFkZU5vRGVjayA9IGFzeW5jIChcbiAgICBkZWNrSWQ6IHN0cmluZywgXG4gICAgY2FyZElkOiBzdHJpbmcsIFxuICAgIG5vdmFRdWFudGlkYWRlOiBudW1iZXIsIFxuICAgIGNhdGVnb3J5OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicgPSAnbWFpbmJvYXJkJ1xuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAobm92YVF1YW50aWRhZGUgPD0gMCkge1xuICAgICAgYXdhaXQgcmVtb3ZlckNhcnRhRG9EZWNrKGRlY2tJZCwgY2FyZElkLCBjYXRlZ29yeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEVuY29udHJhciBvIElEIGRhIGNhcnRhIG5vIGRlY2tcbiAgICAgICAgY29uc3QgZGVjayA9IGRlY2tzLmZpbmQoZCA9PiBkLmlkID09PSBkZWNrSWQpO1xuICAgICAgICBpZiAoIWRlY2spIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcmRJbkRlY2sgPSBkZWNrLmNhcmRzLmZpbmQoYyA9PiBjLmNhcmQuaWQgPT09IGNhcmRJZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeSk7XG4gICAgICAgIGlmICghY2FyZEluRGVjaykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgZGVja1NlcnZpY2UudXBkYXRlQ2FyZChkZWNrSWQsIGNhcmRJbkRlY2suX2lkLCB7IHF1YW50aXR5OiBub3ZhUXVhbnRpZGFkZSB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5nZXRCeUlkKGRlY2tJZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IGRlY2suaWQgPT09IGRlY2tJZCA/IHJlc3BvbnNlLmRhdGEgOiBkZWNrKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYXR1YWxpemFyIHF1YW50aWRhZGUgbm8gZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IHtcbiAgICAgICAgaWYgKGRlY2suaWQgPT09IGRlY2tJZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kZWNrLFxuICAgICAgICAgICAgY2FyZHM6IGRlY2suY2FyZHMubWFwKGMgPT4gXG4gICAgICAgICAgICAgIGMuY2FyZC5pZCA9PT0gY2FyZElkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgPyB7IC4uLmMsIHF1YW50aXR5OiBub3ZhUXVhbnRpZGFkZSB9XG4gICAgICAgICAgICAgICAgOiBjXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNrO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBPYnRlciBjYXJ0YXMgcXVlIGVzdMOjbyBzZW5kbyB1c2FkYXMgZW0gZGVja3NcbiAgY29uc3QgZ2V0Q2FydGFzVXNhZGFzRW1EZWNrcyA9IChjYXJkSWQ6IHN0cmluZyk6IEFycmF5PHtkZWNrOiBEZWNrLCBxdWFudGl0eTogbnVtYmVyLCBjYXRlZ29yeTogc3RyaW5nfT4gPT4ge1xuICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8e2RlY2s6IERlY2ssIHF1YW50aXR5OiBudW1iZXIsIGNhdGVnb3J5OiBzdHJpbmd9PiA9IFtdO1xuICAgIFxuICAgIGRlY2tzLmZvckVhY2goZGVjayA9PiB7XG4gICAgICBkZWNrLmNhcmRzLmZvckVhY2goZGVja0NhcmQgPT4ge1xuICAgICAgICBpZiAoZGVja0NhcmQuY2FyZC5pZCA9PT0gY2FyZElkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgZGVjayxcbiAgICAgICAgICAgIHF1YW50aXR5OiBkZWNrQ2FyZC5xdWFudGl0eSxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBkZWNrQ2FyZC5jYXRlZ29yeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBcbiAgLy8gRnVuw6fDo28gcGFyYSBpbXBvcnRhciBkZWNrIGEgcGFydGlyIGRlIHVtYSBsaXN0YSBkZSB0ZXh0b1xuICBjb25zdCBpbXBvcnRhckRlY2tEZUxpc3RhID0gYXN5bmMgKGRlY2tMaXN0OiBzdHJpbmcsIGRlY2tEYXRhOiBhbnkpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmlhciBvIGRlY2sgdmF6aW8gcHJpbWVpcm9cbiAgICAgIGNvbnN0IGRlY2tJZCA9IGF3YWl0IGNyaWFyRGVjayh7XG4gICAgICAgIG5hbWU6IGRlY2tEYXRhLm5hbWUsXG4gICAgICAgIGZvcm1hdDogZGVja0RhdGEuZm9ybWF0LFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVja0RhdGEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgIGNvbG9yczogZGVja0RhdGEuY29sb3JzIHx8IFtdLFxuICAgICAgICBjYXJkczogW10sXG4gICAgICAgIGlzUHVibGljOiBkZWNrRGF0YS5pc1B1YmxpYyB8fCBmYWxzZSxcbiAgICAgICAgdGFnczogZGVja0RhdGEudGFncyB8fCBbXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3NhciBhIGxpc3RhIGRlIGNhcnRhc1xuICAgICAgY29uc3QgbGluZXMgPSBkZWNrTGlzdC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICAgICAgbGV0IGN1cnJlbnRTZWN0aW9uOiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicgPSAnbWFpbmJvYXJkJztcbiAgICAgIGNvbnN0IGNhcmRQcm9taXNlcyA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZpY2FyIHNlIMOpIHVtYSBsaW5oYSBkZSBzZcOnw6NvXG4gICAgICAgIGlmICh0cmltbWVkTGluZS5pbmNsdWRlcygnc2lkZWJvYXJkJykpIHtcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9ICdzaWRlYm9hcmQnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmltbWVkTGluZS5pbmNsdWRlcygnY29tbWFuZGVyJykpIHtcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9ICdjb21tYW5kZXInO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZmljYXIgc2Ugw6kgdW1hIGxpbmhhIGRlIGNhcnRhXG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvXihcXGQrKXg/XFxzKyguKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IHF1YW50aXR5ID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgIGNvbnN0IGNhcmROYW1lID0gbWF0Y2hbMl0udHJpbSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEJ1c2NhciBhIGNhcnRhIG5hIEFQSSBkbyBTY3J5ZmFsbFxuICAgICAgICAgIGNhcmRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5zY3J5ZmFsbC5jb20vY2FyZHMvbmFtZWQ/ZnV6enk9JHtlbmNvZGVVUklDb21wb25lbnQoY2FyZE5hbWUpfWApO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZERhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAvLyBBZGljaW9uYXIgYSBjYXJ0YSBhbyBkZWNrXG4gICAgICAgICAgICAgICAgICBhd2FpdCBhZGljaW9uYXJDYXJ0YUFvRGVjayhkZWNrSWQsIGNhcmREYXRhLCBjdXJyZW50U2VjdGlvbiwgcXVhbnRpdHkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY2FyZDogY2FyZE5hbWUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ2FydGEgbsOjbyBlbmNvbnRyYWRhOiAke2NhcmROYW1lfWApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGNhcmQ6IGNhcmROYW1lIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm8gYW8gYnVzY2FyIGNhcnRhICR7Y2FyZE5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgY2FyZDogY2FyZE5hbWUgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWd1YXJkYXIgdG9kYXMgYXMgY2FydGFzIHNlcmVtIHByb2Nlc3NhZGFzXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNhcmRQcm9taXNlcyk7XG4gICAgICBjb25zdCBmYWlsZWRDYXJkcyA9IHJlc3VsdHNcbiAgICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgIShyZXN1bHQudmFsdWUgYXMgYW55KS5zdWNjZXNzKVxuICAgICAgICAubWFwKHJlc3VsdCA9PiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyAocmVzdWx0LnZhbHVlIGFzIGFueSkuY2FyZCA6ICdVbmtub3duJykpO1xuICAgICAgXG4gICAgICBpZiAoZmFpbGVkQ2FyZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEFsZ3VtYXMgY2FydGFzIG7Do28gZm9yYW0gZW5jb250cmFkYXM6ICR7ZmFpbGVkQ2FyZHMuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGRlY2tJZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBpbXBvcnRhciBkZWNrOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gaW1wb3J0YXIgZGVjay4gVmVyaWZpcXVlIG8gZm9ybWF0byBkYSBsaXN0YS4nKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gPT09PT09IEZVTsOHw5VFUyBERSBHRVJFTkNJQU1FTlRPIERFIEZBVk9SSVRPUyA9PT09PT1cblxuICAvLyBBZGljaW9uYXIgY2FydGEgYW9zIGZhdm9yaXRvc1xuICBjb25zdCBhZGRGYXZvcml0ZSA9IGFzeW5jIChjYXJkOiBNVEdDYXJkKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmF2b3JpdGVTZXJ2aWNlLmFkZChjYXJkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiBbLi4ucHJldiwgY2FyZF0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGFkaWNpb25hciBmYXZvcml0bzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RmF2b3JpdGVzKHByZXYgPT4ge1xuICAgICAgICBpZiAocHJldi5zb21lKGMgPT4gYy5pZCA9PT0gY2FyZC5pZCkpIHJldHVybiBwcmV2O1xuICAgICAgICByZXR1cm4gWy4uLnByZXYsIGNhcmRdO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZXIgY2FydGEgZG9zIGZhdm9yaXRvc1xuICBjb25zdCByZW1vdmVGYXZvcml0ZSA9IGFzeW5jIChjYXJkSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZhdm9yaXRlU2VydmljZS5yZW1vdmVDYXJkKGNhcmRJZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RmF2b3JpdGVzKHByZXYgPT4gcHJldi5maWx0ZXIoY2FyZCA9PiBjYXJkLmlkICE9PSBjYXJkSWQpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyByZW1vdmVyIGZhdm9yaXRvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiBwcmV2LmZpbHRlcihjYXJkID0+IGNhcmQuaWQgIT09IGNhcmRJZCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBWZXJpZmljYXIgc2UgdW1hIGNhcnRhIGVzdMOhIG5vcyBmYXZvcml0b3NcbiAgY29uc3QgaXNGYXZvcml0ZSA9IChjYXJkSWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBmYXZvcml0ZXMuc29tZShjYXJkID0+IGNhcmQuaWQgPT09IGNhcmRJZCk7XG4gIH07XG5cbiAgLy8gRnVuw6fDo28gcGFyYSBleHBvcnRhciBjb2xlw6fDo28gcGFyYSBDU1Ygbm8gZm9ybWF0byBNYW5hYm94XG4gIGNvbnN0IGV4cG9ydENvbGxlY3Rpb25Ub0NTViA9IChjb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbikgPT4ge1xuICAgIC8vIEZvcm1hdG8gTWFuYWJveDogTmFtZSxTZXQsUXVhbnRpdHksRm9pbCxDb25kaXRpb24sTGFuZ3VhZ2VcbiAgICBjb25zdCBjc3ZDb250ZW50ID0gW1xuICAgICAgWydOYW1lJywgJ1NldCcsICdRdWFudGl0eScsICdGb2lsJywgJ0NvbmRpdGlvbicsICdMYW5ndWFnZSddLFxuICAgICAgLi4uY29sbGVjdGlvbi5jYXJkcy5tYXAoYyA9PiBbXG4gICAgICAgIGMuY2FyZC5uYW1lLFxuICAgICAgICBjLmNhcmQuc2V0X2NvZGUsXG4gICAgICAgIGMucXVhbnRpdHkudG9TdHJpbmcoKSxcbiAgICAgICAgYy5mb2lsID8gJ0ZvaWwnIDogJ05vbi1mb2lsJyxcbiAgICAgICAgYy5jb25kaXRpb24gfHwgJ05lYXIgTWludCcsXG4gICAgICAgIGMubGFuZ3VhZ2UgfHwgJ0VuZ2xpc2gnXG4gICAgICBdKVxuICAgIF0ubWFwKHJvdyA9PiByb3cuam9pbignLCcpKS5qb2luKCdcXG4nKTtcblxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICBhLmRvd25sb2FkID0gYCR7Y29sbGVjdGlvbi5uYW1lfV9tYW5hYm94LmNzdmA7XG4gICAgYS5jbGljaygpO1xuICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8QXBwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xuICAgICAgY29sbGVjdGlvbnMsXG4gICAgICBjdXJyZW50Q29sbGVjdGlvbixcbiAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uOiBzZXRDb2xsZWN0aW9ucyxcbiAgICAgIGN1cnJlbnRDb2xsZWN0aW9uSWQsXG4gICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkLFxuICAgICAgY3JlYXRlQ29sbGVjdGlvbixcbiAgICAgIHVwZGF0ZUNvbGxlY3Rpb24sXG4gICAgICBkZWxldGVDb2xsZWN0aW9uLFxuICAgICAgZHVwbGljYXRlQ29sbGVjdGlvbixcbiAgICAgIGFkaWNpb25hckNhcnRhLFxuICAgICAgcmVtb3ZlckNhcnRhLFxuICAgICAgZ2V0UXVhbnRpZGFkZU5hQ29sZWNhbyxcbiAgICAgIGRlY2tzLFxuICAgICAgc2V0RGVja3MsXG4gICAgICBjcmlhckRlY2ssXG4gICAgICBlZGl0YXJEZWNrLFxuICAgICAgZGVsZXRhckRlY2ssXG4gICAgICBkdXBsaWNhckRlY2ssXG4gICAgICBhZGljaW9uYXJDYXJ0YUFvRGVjayxcbiAgICAgIHJlbW92ZXJDYXJ0YURvRGVjayxcbiAgICAgIGF0dWFsaXphclF1YW50aWRhZGVOb0RlY2ssXG4gICAgICBnZXRDYXJ0YXNVc2FkYXNFbURlY2tzLFxuICAgICAgaW1wb3J0YXJEZWNrRGVMaXN0YSxcbiAgICAgIGZhdm9yaXRlcyxcbiAgICAgIGFkZEZhdm9yaXRlLFxuICAgICAgcmVtb3ZlRmF2b3JpdGUsXG4gICAgICBpc0Zhdm9yaXRlLFxuICAgICAgbG9hZGluZyxcbiAgICAgIGV4cG9ydENvbGxlY3Rpb25Ub0NTVlxuICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXBwQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNvbGxlY3Rpb25TZXJ2aWNlIiwiZGVja1NlcnZpY2UiLCJmYXZvcml0ZVNlcnZpY2UiLCJ1c2VTZXNzaW9uIiwiQXBwQ29udGV4dCIsInVzZUFwcENvbnRleHQiLCJjb250ZXh0IiwiRXJyb3IiLCJBcHBQcm92aWRlciIsImNoaWxkcmVuIiwiZGF0YSIsInNlc3Npb24iLCJjb2xsZWN0aW9ucyIsInNldENvbGxlY3Rpb25zIiwiY3VycmVudENvbGxlY3Rpb25JZCIsInNldEN1cnJlbnRDb2xsZWN0aW9uSWQiLCJkZWNrcyIsInNldERlY2tzIiwiZmF2b3JpdGVzIiwic2V0RmF2b3JpdGVzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50Q29sbGVjdGlvbiIsInVzZU1lbW8iLCJmaW5kIiwiYyIsImlkIiwibG9hZERhdGEiLCJjb2xsZWN0aW9uc1Jlc3BvbnNlIiwiZ2V0QWxsIiwic3VjY2VzcyIsImxlbmd0aCIsImRlY2tzUmVzcG9uc2UiLCJmYXZvcml0ZXNSZXNwb25zZSIsIm1hcCIsImZhdiIsImNhcmQiLCJlcnJvciIsImNvbnNvbGUiLCJzYXZlZENvbGxlY3Rpb25zIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZENvbGxlY3Rpb25zIiwiSlNPTiIsInBhcnNlIiwiZGVmYXVsdENvbGxlY3Rpb24iLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJjYXJkcyIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRBdCIsImlzUHVibGljIiwic2F2ZWREZWNrcyIsInBhcnNlZERlY2tzIiwic2F2ZWRGYXZvcml0ZXMiLCJwYXJzZWRGYXZvcml0ZXMiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY3JlYXRlQ29sbGVjdGlvbiIsInJlc3BvbnNlIiwiY3JlYXRlIiwicHJldiIsIm5ld0NvbGxlY3Rpb24iLCJub3ciLCJ0b1N0cmluZyIsInVwZGF0ZUNvbGxlY3Rpb24iLCJ1cGRhdGVzIiwidXBkYXRlIiwiZGVsZXRlQ29sbGVjdGlvbiIsImRlbGV0ZSIsIm5ld0NvbGxlY3Rpb25zIiwiZmlsdGVyIiwiZHVwbGljYXRlQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25Ub0R1cGxpY2F0ZSIsImNhcmRJdGVtIiwiYWRkQ2FyZCIsInF1YW50aXR5IiwiY29uZGl0aW9uIiwiZm9pbCIsImxhbmd1YWdlIiwidXBkYXRlZFJlc3BvbnNlIiwiZ2V0QnlJZCIsImFkaWNpb25hckNhcnRhIiwicXVhbnRpZGFkZSIsImV4aXN0aW5nQ2FyZCIsImNjIiwibmV3Q2FyZHMiLCJyZW1vdmVyQ2FydGEiLCJjb2xsZWN0aW9uIiwiY2FyZEluQ29sbGVjdGlvbiIsInVwZGF0ZUNhcmQiLCJfaWQiLCJyZW1vdmVDYXJkIiwiZ2V0UXVhbnRpZGFkZU5hQ29sZWNhbyIsImNhcmRJZCIsImNyaWFyRGVjayIsImRlY2tEYXRhIiwibmV3RGVjayIsImxhc3RNb2RpZmllZCIsImVkaXRhckRlY2siLCJkZWNrSWQiLCJkZWNrIiwiZGVsZXRhckRlY2siLCJkdXBsaWNhckRlY2siLCJuZXdOYW1lIiwib3JpZ2luYWxEZWNrIiwidW5kZWZpbmVkIiwibmV3RGVja0RhdGEiLCJmb3JtYXQiLCJjb2xvcnMiLCJpc1NpZGVib2FyZCIsImNhdGVnb3J5IiwiaXNDb21tYW5kZXIiLCJkdXBsaWNhdGVkRGVjayIsImFkaWNpb25hckNhcnRhQW9EZWNrIiwicmVtb3ZlckNhcnRhRG9EZWNrIiwiZCIsImNhcmRJbkRlY2siLCJhdHVhbGl6YXJRdWFudGlkYWRlTm9EZWNrIiwibm92YVF1YW50aWRhZGUiLCJnZXRDYXJ0YXNVc2FkYXNFbURlY2tzIiwicmVzdWx0IiwiZm9yRWFjaCIsImRlY2tDYXJkIiwicHVzaCIsImltcG9ydGFyRGVja0RlTGlzdGEiLCJkZWNrTGlzdCIsInRhZ3MiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsInRyaW0iLCJjdXJyZW50U2VjdGlvbiIsImNhcmRQcm9taXNlcyIsInRyaW1tZWRMaW5lIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIm1hdGNoIiwicGFyc2VJbnQiLCJjYXJkTmFtZSIsImZldGNoIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwib2siLCJjYXJkRGF0YSIsImpzb24iLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJmYWlsZWRDYXJkcyIsInN0YXR1cyIsInZhbHVlIiwid2FybiIsImpvaW4iLCJhZGRGYXZvcml0ZSIsImFkZCIsInNvbWUiLCJyZW1vdmVGYXZvcml0ZSIsImlzRmF2b3JpdGUiLCJleHBvcnRDb2xsZWN0aW9uVG9DU1YiLCJjc3ZDb250ZW50Iiwic2V0X2NvZGUiLCJyb3ciLCJibG9iIiwiQmxvYiIsInR5cGUiLCJ1cmwiLCJ3aW5kb3ciLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsImRvd25sb2FkIiwiY2xpY2siLCJyZXZva2VPYmplY3RVUkwiLCJQcm92aWRlciIsInNldEN1cnJlbnRDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/AppContext.tsx\n"));

/***/ })

});