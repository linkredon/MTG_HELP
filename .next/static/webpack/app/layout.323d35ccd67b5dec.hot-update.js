"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"fab338e3032f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzZmZjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmYWIzMzhlMzAzMmZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./contexts/AppContext.tsx":
/*!*********************************!*\
  !*** ./contexts/AppContext.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: function() { return /* binding */ AppProvider; },\n/* harmony export */   useAppContext: function() { return /* binding */ useAppContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_apiService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/apiService */ \"(app-pages-browser)/./utils/apiService.ts\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ useAppContext,AppProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useAppContext = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (!context) {\n        throw new Error(\"useAppContext deve ser usado dentro de um AppProvider\");\n    }\n    return context;\n};\n_s(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst AppProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession)();\n    const [collections, setCollections] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCollectionId, setCurrentCollectionId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [decks, setDecks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [favorites, setFavorites] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const currentCollection = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(()=>{\n        return collections.find((c)=>c.id === currentCollectionId);\n    }, [\n        collections,\n        currentCollectionId\n    ]);\n    // Carregar dados da API quando o usuário estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (session) {\n                setLoading(true);\n                try {\n                    // Carregar coleções\n                    const collectionsResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getAll();\n                    if (collectionsResponse.success && collectionsResponse.data) {\n                        setCollections(collectionsResponse.data);\n                        if (collectionsResponse.data.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(collectionsResponse.data[0].id);\n                        }\n                    }\n                    // Carregar decks\n                    const decksResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getAll();\n                    if (decksResponse.success && decksResponse.data) {\n                        setDecks(decksResponse.data);\n                    }\n                    // Carregar favoritos\n                    const favoritesResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.getAll();\n                    if (favoritesResponse.success && favoritesResponse.data) {\n                        setFavorites(favoritesResponse.data.map((fav)=>fav.card));\n                    }\n                } catch (error) {\n                    console.error(\"Erro ao carregar dados:\", error);\n                } finally{\n                    setLoading(false);\n                }\n            } else {\n                // Usuário não autenticado, usar localStorage como fallback\n                const savedCollections = localStorage.getItem(\"mtg-collections\");\n                if (savedCollections) {\n                    try {\n                        const parsedCollections = JSON.parse(savedCollections);\n                        setCollections(parsedCollections);\n                        if (parsedCollections.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(parsedCollections[0].id);\n                        }\n                    } catch (error) {\n                        console.error(\"Erro ao carregar cole\\xe7\\xf5es salvas:\", error);\n                    }\n                } else {\n                    // Criar uma coleção padrão se não houver nenhuma\n                    const defaultCollection = {\n                        id: \"1\",\n                        name: \"Minha Cole\\xe7\\xe3o\",\n                        description: \"Cole\\xe7\\xe3o principal de cartas Magic\",\n                        cards: [],\n                        createdAt: new Date().toISOString(),\n                        updatedAt: new Date().toISOString(),\n                        isPublic: false\n                    };\n                    setCollections([\n                        defaultCollection\n                    ]);\n                    setCurrentCollectionId(defaultCollection.id);\n                }\n                const savedDecks = localStorage.getItem(\"mtg-decks\");\n                if (savedDecks) {\n                    try {\n                        const parsedDecks = JSON.parse(savedDecks);\n                        setDecks(parsedDecks);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar decks salvos:\", error);\n                    }\n                }\n                const savedFavorites = localStorage.getItem(\"mtg-favorites\");\n                if (savedFavorites) {\n                    try {\n                        const parsedFavorites = JSON.parse(savedFavorites);\n                        setFavorites(parsedFavorites);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar favoritos salvos:\", error);\n                    }\n                }\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        session\n    ]);\n    // Salvar dados no localStorage quando não estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-collections\", JSON.stringify(collections));\n        }\n    }, [\n        collections,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-decks\", JSON.stringify(decks));\n        }\n    }, [\n        decks,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-favorites\", JSON.stringify(favorites));\n        }\n    }, [\n        favorites,\n        session\n    ]);\n    // Funções de gerenciamento de coleção\n    const createCollection = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.create({\n                    name,\n                    description\n                });\n                if (response.success && response.data) {\n                    setCollections((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    setCurrentCollectionId(response.data.id);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar cole\\xe7\\xe3o\");\n            } catch (error) {\n                console.error(\"Erro ao criar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                id: Date.now().toString(),\n                name,\n                description,\n                cards: [],\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n                isPublic: false\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n            setCurrentCollectionId(newCollection.id);\n            return newCollection.id;\n        }\n    };\n    const updateCollection = async (id, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.update(id, updates);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                                ...c,\n                                ...updates\n                            } : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                        ...c,\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    } : c));\n        }\n    };\n    const deleteCollection = async (id)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.delete(id);\n                if (response.success) {\n                    setCollections((prev)=>{\n                        const newCollections = prev.filter((c)=>c.id !== id);\n                        if (currentCollectionId === id) {\n                            setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                        }\n                        return newCollections;\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erro ao excluir cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>{\n                const newCollections = prev.filter((c)=>c.id !== id);\n                if (currentCollectionId === id) {\n                    setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                }\n                return newCollections;\n            });\n        }\n    };\n    const duplicateCollection = async (id)=>{\n        const collectionToDuplicate = collections.find((c)=>c.id === id);\n        if (!collectionToDuplicate) return;\n        if (session) {\n            try {\n                const newCollection = {\n                    name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\"),\n                    description: collectionToDuplicate.description,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.create(newCollection);\n                if (response.success && response.data) {\n                    // Adicionar cartas à nova coleção\n                    for (const cardItem of collectionToDuplicate.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            condition: cardItem.condition,\n                            foil: cardItem.foil,\n                            language: cardItem.language\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setCollections((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Erro ao duplicar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                ...collectionToDuplicate,\n                id: Date.now().toString(),\n                name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\")\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n        }\n    };\n    // Função para adicionar carta à coleção\n    const adicionarCarta = async function(card) {\n        let quantidade = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.addCard(currentCollectionId, {\n                    card,\n                    quantity: quantidade,\n                    condition: \"Near Mint\",\n                    foil: false,\n                    language: \"English\"\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity + quantidade\n                            } : cc);\n                    } else {\n                        newCards = [\n                            ...c.cards,\n                            {\n                                card,\n                                quantity: quantidade,\n                                condition: \"Near Mint\",\n                                foil: false\n                            }\n                        ];\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para remover carta da coleção\n    const removerCarta = async (card)=>{\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                // Encontrar o ID da carta na coleção\n                const collection = collections.find((c)=>c.id === currentCollectionId);\n                if (!collection) return;\n                const cardInCollection = collection.cards.find((cc)=>cc.card.id === card.id);\n                if (!cardInCollection) return;\n                if (cardInCollection.quantity > 1) {\n                    // Atualizar quantidade\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.updateCard(currentCollectionId, cardInCollection._id, {\n                        quantity: cardInCollection.quantity - 1\n                    });\n                } else {\n                    // Remover carta\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.removeCard(currentCollectionId, cardInCollection._id);\n                }\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard && existingCard.quantity > 1) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity - 1\n                            } : cc);\n                    } else {\n                        newCards = c.cards.filter((cc)=>cc.card.id !== card.id);\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para obter quantidade de uma carta na coleção\n    const getQuantidadeNaColecao = (cardId)=>{\n        var _currentCollection_cards;\n        const card = currentCollection === null || currentCollection === void 0 ? void 0 : (_currentCollection_cards = currentCollection.cards) === null || _currentCollection_cards === void 0 ? void 0 : _currentCollection_cards.find((c)=>c.card.id === cardId);\n        return card ? card.quantity : 0;\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE DECKS ======\n    // Criar novo deck\n    const criarDeck = async (deckData)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.create(deckData);\n                if (response.success && response.data) {\n                    setDecks((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar deck\");\n            } catch (error) {\n                console.error(\"Erro ao criar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newDeck = {\n                ...deckData,\n                id: Date.now().toString(),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    newDeck\n                ]);\n            return newDeck.id;\n        }\n    };\n    // Editar deck existente\n    const editarDeck = async (deckId, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.update(deckId, updates);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                                ...deck,\n                                ...updates\n                            } : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao editar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                        ...deck,\n                        ...updates,\n                        lastModified: new Date().toISOString()\n                    } : deck));\n        }\n    };\n    // Deletar deck\n    const deletarDeck = async (deckId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.delete(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao deletar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n        }\n    };\n    // Duplicar deck\n    const duplicarDeck = async (deckId, newName)=>{\n        const originalDeck = decks.find((deck)=>deck.id === deckId);\n        if (!originalDeck) return undefined;\n        if (session) {\n            try {\n                const newDeckData = {\n                    name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                    description: originalDeck.description,\n                    format: originalDeck.format,\n                    colors: originalDeck.colors,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.create(newDeckData);\n                if (response.success && response.data) {\n                    // Adicionar cartas ao novo deck\n                    for (const cardItem of originalDeck.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            isSideboard: cardItem.category === \"sideboard\",\n                            isCommander: cardItem.category === \"commander\",\n                            category: cardItem.category\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setDecks((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                        return updatedResponse.data.id;\n                    }\n                }\n                return undefined;\n            } catch (error) {\n                console.error(\"Erro ao duplicar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const duplicatedDeck = {\n                ...originalDeck,\n                id: Date.now().toString(),\n                name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    duplicatedDeck\n                ]);\n            return duplicatedDeck.id;\n        }\n    };\n    // Adicionar carta ao deck\n    const adicionarCartaAoDeck = async function(deckId, card) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\", quantity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.addCard(deckId, {\n                    card,\n                    quantity,\n                    isSideboard: category === \"sideboard\",\n                    isCommander: category === \"commander\",\n                    category\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta ao deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        const existingCard = deck.cards.find((c)=>c.card.id === card.id && c.category === category);\n                        if (existingCard) {\n                            return {\n                                ...deck,\n                                cards: deck.cards.map((c)=>c.card.id === card.id && c.category === category ? {\n                                        ...c,\n                                        quantity: c.quantity + quantity\n                                    } : c),\n                                lastModified: new Date().toISOString()\n                            };\n                        } else {\n                            return {\n                                ...deck,\n                                cards: [\n                                    ...deck.cards,\n                                    {\n                                        card,\n                                        quantity,\n                                        category\n                                    }\n                                ],\n                                lastModified: new Date().toISOString()\n                            };\n                        }\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Remover carta do deck\n    const removerCartaDoDeck = async function(deckId, cardId) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\";\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.removeCard(deckId, cardInDeck._id);\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta do deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.filter((c)=>!(c.card.id === cardId && c.category === category)),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Atualizar quantidade de carta no deck\n    const atualizarQuantidadeNoDeck = async function(deckId, cardId, novaQuantidade) {\n        let category = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"mainboard\";\n        if (novaQuantidade <= 0) {\n            await removerCartaDoDeck(deckId, cardId, category);\n            return;\n        }\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.updateCard(deckId, cardInDeck._id, {\n                    quantity: novaQuantidade\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar quantidade no deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.map((c)=>c.card.id === cardId && c.category === category ? {\n                                    ...c,\n                                    quantity: novaQuantidade\n                                } : c),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Obter cartas que estão sendo usadas em decks\n    const getCartasUsadasEmDecks = (cardId)=>{\n        const result = [];\n        decks.forEach((deck)=>{\n            deck.cards.forEach((deckCard)=>{\n                if (deckCard.card.id === cardId) {\n                    result.push({\n                        deck,\n                        quantity: deckCard.quantity,\n                        category: deckCard.category\n                    });\n                }\n            });\n        });\n        return result;\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE FAVORITOS ======\n    // Adicionar carta aos favoritos\n    const addFavorite = async (card)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.add(card);\n                if (response.success) {\n                    setFavorites((prev)=>[\n                            ...prev,\n                            card\n                        ]);\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>{\n                if (prev.some((c)=>c.id === card.id)) return prev;\n                return [\n                    ...prev,\n                    card\n                ];\n            });\n        }\n    };\n    // Remover carta dos favoritos\n    const removeFavorite = async (cardId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.removeCard(cardId);\n                if (response.success) {\n                    setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n        }\n    };\n    // Verificar se uma carta está nos favoritos\n    const isFavorite = (cardId)=>{\n        return favorites.some((card)=>card.id === cardId);\n    };\n    // Função para exportar coleção para CSV no formato Manabox\n    const exportCollectionToCSV = (collection)=>{\n        // Formato Manabox: Name,Set,Quantity,Foil,Condition,Language\n        const csvContent = [\n            [\n                \"Name\",\n                \"Set\",\n                \"Quantity\",\n                \"Foil\",\n                \"Condition\",\n                \"Language\"\n            ],\n            ...collection.cards.map((c)=>[\n                    c.card.name,\n                    c.card.set_code,\n                    c.quantity.toString(),\n                    c.foil ? \"Foil\" : \"Non-foil\",\n                    c.condition || \"Near Mint\",\n                    c.language || \"English\"\n                ])\n        ].map((row)=>row.join(\",\")).join(\"\\n\");\n        const blob = new Blob([\n            csvContent\n        ], {\n            type: \"text/csv\"\n        });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"\".concat(collection.name, \"_manabox.csv\");\n        a.click();\n        window.URL.revokeObjectURL(url);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: {\n            collections,\n            currentCollection,\n            setCurrentCollection: setCollections,\n            currentCollectionId,\n            setCurrentCollectionId,\n            createCollection,\n            updateCollection,\n            deleteCollection,\n            duplicateCollection,\n            adicionarCarta,\n            removerCarta,\n            getQuantidadeNaColecao,\n            decks,\n            setDecks,\n            criarDeck,\n            editarDeck,\n            deletarDeck,\n            duplicarDeck,\n            adicionarCartaAoDeck,\n            removerCartaDoDeck,\n            atualizarQuantidadeNoDeck,\n            getCartasUsadasEmDecks,\n            favorites,\n            addFavorite,\n            removeFavorite,\n            isFavorite,\n            loading,\n            exportCollectionToCSV\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Rodrigo\\\\Downloads\\\\MTG HELP\\\\contexts\\\\AppContext.tsx\",\n        lineNumber: 774,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(AppProvider, \"P5slHoOyqMDp2BOUreOP8tfxRtM=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession\n    ];\n});\n_c = AppProvider;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL0FwcENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFeUY7QUFFSjtBQUN4QztBQTBDN0MsTUFBTVMsMkJBQWFSLG9EQUFhQSxDQUF3QjtBQUVqRCxNQUFNUyxnQkFBZ0I7O0lBQzNCLE1BQU1DLFVBQVVULGlEQUFVQSxDQUFDTztJQUMzQixJQUFJLENBQUNFLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7R0FOV0Q7QUFZTixNQUFNRyxjQUEwQztRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDbEUsTUFBTSxFQUFFQyxNQUFNQyxPQUFPLEVBQUUsR0FBR1IsMkRBQVVBO0lBQ3BDLE1BQU0sQ0FBQ1MsYUFBYUMsZUFBZSxHQUFHZiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUNuRSxNQUFNLENBQUNnQixxQkFBcUJDLHVCQUF1QixHQUFHakIsK0NBQVFBLENBQWdCO0lBQzlFLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDb0IsV0FBV0MsYUFBYSxHQUFHckIsK0NBQVFBLENBQVksRUFBRTtJQUN4RCxNQUFNLENBQUNzQixTQUFTQyxXQUFXLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUV2QyxNQUFNd0Isb0JBQW9CM0Isb0RBQWEsQ0FBQztRQUN0QyxPQUFPaUIsWUFBWVksSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaO0lBQ3hDLEdBQUc7UUFBQ0Y7UUFBYUU7S0FBb0I7SUFFckMsNkRBQTZEO0lBQzdEZixnREFBU0EsQ0FBQztRQUNSLE1BQU00QixXQUFXO1lBQ2YsSUFBSWhCLFNBQVM7Z0JBQ1hVLFdBQVc7Z0JBQ1gsSUFBSTtvQkFDRixvQkFBb0I7b0JBQ3BCLE1BQU1PLHNCQUFzQixNQUFNNUIsZ0VBQWlCQSxDQUFDNkIsTUFBTTtvQkFDMUQsSUFBSUQsb0JB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QU87WUFDQUc7WUFDQUk7WUFDQVU7WUFDQUs7WUFDQU07WUFDQS9FO1lBQ0FDO1lBQ0FnRjtZQUNBSTtZQUNBRztZQUNBQztZQUNBVztZQUNBQztZQUNBRztZQUNBRTtZQUNBeEc7WUFDQTZHO1lBQ0FHO1lBQ0FDO1lBQ0EvRztZQUNBZ0g7UUFDRjtrQkFDRzNIOzs7Ozs7QUFHUCxFQUFFO0lBenVCV0Q7O1FBQ2VMLHVEQUFVQTs7O0tBRHpCSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0cy9BcHBDb250ZXh0LnRzeD8yNTBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBNVEdDYXJkLCBVc2VyQ29sbGVjdGlvbiwgQ29sbGVjdGlvbkNhcmQsIERlY2ssIERlY2tDYXJkIH0gZnJvbSAnQC90eXBlcy9tdGcnO1xuaW1wb3J0IHsgY29sbGVjdGlvblNlcnZpY2UsIGRlY2tTZXJ2aWNlLCBmYXZvcml0ZVNlcnZpY2UgfSBmcm9tICdAL3V0aWxzL2FwaVNlcnZpY2UnO1xuaW1wb3J0IHsgdXNlU2Vzc2lvbiB9IGZyb20gJ25leHQtYXV0aC9yZWFjdCc7XG5cbmludGVyZmFjZSBBcHBDb250ZXh0VHlwZSB7XG4gIGNvbGxlY3Rpb25zOiBVc2VyQ29sbGVjdGlvbltdO1xuICBjdXJyZW50Q29sbGVjdGlvbjogVXNlckNvbGxlY3Rpb24gfCB1bmRlZmluZWQ7XG4gIHNldEN1cnJlbnRDb2xsZWN0aW9uOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxVc2VyQ29sbGVjdGlvbltdPj47XG4gIGN1cnJlbnRDb2xsZWN0aW9uSWQ6IHN0cmluZyB8IG51bGw7XG4gIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQ6IChpZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgY3JlYXRlQ29sbGVjdGlvbjogKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPjtcbiAgdXBkYXRlQ29sbGVjdGlvbjogKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VXNlckNvbGxlY3Rpb24+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkZWxldGVDb2xsZWN0aW9uOiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZHVwbGljYXRlQ29sbGVjdGlvbjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGFkaWNpb25hckNhcnRhOiAoY2FyZDogTVRHQ2FyZCwgcXVhbnRpZGFkZT86IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVtb3ZlckNhcnRhOiAoY2FyZDogTVRHQ2FyZCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZ2V0UXVhbnRpZGFkZU5hQ29sZWNhbzogKGNhcmRJZDogc3RyaW5nKSA9PiBudW1iZXI7XG4gIFxuICAvLyBHZXJlbmNpYW1lbnRvIGRlIERlY2tzXG4gIGRlY2tzOiBEZWNrW107XG4gIHNldERlY2tzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxEZWNrW10+PjtcbiAgY3JpYXJEZWNrOiAoZGVjazogT21pdDxEZWNrLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAnbGFzdE1vZGlmaWVkJz4pID0+IFByb21pc2U8c3RyaW5nPjtcbiAgZWRpdGFyRGVjazogKGRlY2tJZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPERlY2s+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkZWxldGFyRGVjazogKGRlY2tJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkdXBsaWNhckRlY2s6IChkZWNrSWQ6IHN0cmluZywgbmV3TmFtZT86IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuICBhZGljaW9uYXJDYXJ0YUFvRGVjazogKGRlY2tJZDogc3RyaW5nLCBjYXJkOiBNVEdDYXJkLCBjYXRlZ29yeT86ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJywgcXVhbnRpdHk/OiBudW1iZXIpID0+IFByb21pc2U8dm9pZD47XG4gIHJlbW92ZXJDYXJ0YURvRGVjazogKGRlY2tJZDogc3RyaW5nLCBjYXJkSWQ6IHN0cmluZywgY2F0ZWdvcnk/OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicpID0+IFByb21pc2U8dm9pZD47XG4gIGF0dWFsaXphclF1YW50aWRhZGVOb0RlY2s6IChkZWNrSWQ6IHN0cmluZywgY2FyZElkOiBzdHJpbmcsIG5vdmFRdWFudGlkYWRlOiBudW1iZXIsIGNhdGVnb3J5PzogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDYXJ0YXNVc2FkYXNFbURlY2tzOiAoY2FyZElkOiBzdHJpbmcpID0+IEFycmF5PHtkZWNrOiBEZWNrLCBxdWFudGl0eTogbnVtYmVyLCBjYXRlZ29yeTogc3RyaW5nfT47XG4gIGltcG9ydGFyRGVja0RlTGlzdGE6IChkZWNrTGlzdDogc3RyaW5nLCBkZWNrRGF0YTogYW55KSA9PiBQcm9taXNlPHN0cmluZz47XG4gIFxuICAvLyBGYXZvcml0b3NcbiAgZmF2b3JpdGVzOiBNVEdDYXJkW107XG4gIGFkZEZhdm9yaXRlOiAoY2FyZDogTVRHQ2FyZCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVtb3ZlRmF2b3JpdGU6IChjYXJkSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgaXNGYXZvcml0ZTogKGNhcmRJZDogc3RyaW5nKSA9PiBib29sZWFuO1xuICBcbiAgLy8gRXN0YWRvIGRlIGNhcnJlZ2FtZW50b1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBcbiAgLy8gRXhwb3J0YcOnw6NvXG4gIGV4cG9ydENvbGxlY3Rpb25Ub0NTVjogKGNvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uKSA9PiB2b2lkO1xufVxuXG5jb25zdCBBcHBDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBcHBDb250ZXh0VHlwZSB8IG51bGw+KG51bGwpO1xuXG5leHBvcnQgY29uc3QgdXNlQXBwQ29udGV4dCA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQXBwQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXBwQ29udGV4dCBkZXZlIHNlciB1c2FkbyBkZW50cm8gZGUgdW0gQXBwUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbmludGVyZmFjZSBBcHBQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGNvbnN0IEFwcFByb3ZpZGVyOiBSZWFjdC5GQzxBcHBQcm92aWRlclByb3BzPiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgeyBkYXRhOiBzZXNzaW9uIH0gPSB1c2VTZXNzaW9uKCk7XG4gIGNvbnN0IFtjb2xsZWN0aW9ucywgc2V0Q29sbGVjdGlvbnNdID0gdXNlU3RhdGU8VXNlckNvbGxlY3Rpb25bXT4oW10pO1xuICBjb25zdCBbY3VycmVudENvbGxlY3Rpb25JZCwgc2V0Q3VycmVudENvbGxlY3Rpb25JZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2RlY2tzLCBzZXREZWNrc10gPSB1c2VTdGF0ZTxEZWNrW10+KFtdKTtcbiAgY29uc3QgW2Zhdm9yaXRlcywgc2V0RmF2b3JpdGVzXSA9IHVzZVN0YXRlPE1UR0NhcmRbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcblxuICBjb25zdCBjdXJyZW50Q29sbGVjdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBjb2xsZWN0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbGxlY3Rpb25JZCk7XG4gIH0sIFtjb2xsZWN0aW9ucywgY3VycmVudENvbGxlY3Rpb25JZF0pO1xuXG4gIC8vIENhcnJlZ2FyIGRhZG9zIGRhIEFQSSBxdWFuZG8gbyB1c3XDoXJpbyBlc3RpdmVyIGF1dGVudGljYWRvXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9hZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENhcnJlZ2FyIGNvbGXDp8O1ZXNcbiAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uc1Jlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuZ2V0QWxsKCk7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb25zUmVzcG9uc2Uuc3VjY2VzcyAmJiBjb2xsZWN0aW9uc1Jlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHNldENvbGxlY3Rpb25zKGNvbGxlY3Rpb25zUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICBpZiAoY29sbGVjdGlvbnNSZXNwb25zZS5kYXRhLmxlbmd0aCA+IDAgJiYgIWN1cnJlbnRDb2xsZWN0aW9uSWQpIHtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChjb2xsZWN0aW9uc1Jlc3BvbnNlLmRhdGFbMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhcnJlZ2FyIGRlY2tzXG4gICAgICAgICAgY29uc3QgZGVja3NSZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEFsbCgpO1xuICAgICAgICAgIGlmIChkZWNrc1Jlc3BvbnNlLnN1Y2Nlc3MgJiYgZGVja3NSZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICBzZXREZWNrcyhkZWNrc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhcnJlZ2FyIGZhdm9yaXRvc1xuICAgICAgICAgIGNvbnN0IGZhdm9yaXRlc1Jlc3BvbnNlID0gYXdhaXQgZmF2b3JpdGVTZXJ2aWNlLmdldEFsbCgpO1xuICAgICAgICAgIGlmIChmYXZvcml0ZXNSZXNwb25zZS5zdWNjZXNzICYmIGZhdm9yaXRlc1Jlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHNldEZhdm9yaXRlcyhmYXZvcml0ZXNSZXNwb25zZS5kYXRhLm1hcCgoZmF2OiBhbnkpID0+IGZhdi5jYXJkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY2FycmVnYXIgZGFkb3M6JywgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc3XDoXJpbyBuw6NvIGF1dGVudGljYWRvLCB1c2FyIGxvY2FsU3RvcmFnZSBjb21vIGZhbGxiYWNrXG4gICAgICAgIGNvbnN0IHNhdmVkQ29sbGVjdGlvbnMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXRnLWNvbGxlY3Rpb25zJyk7XG4gICAgICAgIGlmIChzYXZlZENvbGxlY3Rpb25zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZENvbGxlY3Rpb25zID0gSlNPTi5wYXJzZShzYXZlZENvbGxlY3Rpb25zKTtcbiAgICAgICAgICAgIHNldENvbGxlY3Rpb25zKHBhcnNlZENvbGxlY3Rpb25zKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRDb2xsZWN0aW9ucy5sZW5ndGggPiAwICYmICFjdXJyZW50Q29sbGVjdGlvbklkKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQocGFyc2VkQ29sbGVjdGlvbnNbMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGNvbGXDp8O1ZXMgc2FsdmFzOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3JpYXIgdW1hIGNvbGXDp8OjbyBwYWRyw6NvIHNlIG7Do28gaG91dmVyIG5lbmh1bWFcbiAgICAgICAgICBjb25zdCBkZWZhdWx0Q29sbGVjdGlvbjogVXNlckNvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICBpZDogJzEnLFxuICAgICAgICAgICAgbmFtZTogJ01pbmhhIENvbGXDp8OjbycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbGXDp8OjbyBwcmluY2lwYWwgZGUgY2FydGFzIE1hZ2ljJyxcbiAgICAgICAgICAgIGNhcmRzOiBbXSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpc1B1YmxpYzogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKFtkZWZhdWx0Q29sbGVjdGlvbl0pO1xuICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQoZGVmYXVsdENvbGxlY3Rpb24uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2F2ZWREZWNrcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdtdGctZGVja3MnKTtcbiAgICAgICAgaWYgKHNhdmVkRGVja3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGVja3MgPSBKU09OLnBhcnNlKHNhdmVkRGVja3MpO1xuICAgICAgICAgICAgc2V0RGVja3MocGFyc2VkRGVja3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGRlY2tzIHNhbHZvczonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2F2ZWRGYXZvcml0ZXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXRnLWZhdm9yaXRlcycpO1xuICAgICAgICBpZiAoc2F2ZWRGYXZvcml0ZXMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRmF2b3JpdGVzID0gSlNPTi5wYXJzZShzYXZlZEZhdm9yaXRlcyk7XG4gICAgICAgICAgICBzZXRGYXZvcml0ZXMocGFyc2VkRmF2b3JpdGVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBmYXZvcml0b3Mgc2Fsdm9zOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkRGF0YSgpO1xuICB9LCBbc2Vzc2lvbl0pO1xuXG4gIC8vIFNhbHZhciBkYWRvcyBubyBsb2NhbFN0b3JhZ2UgcXVhbmRvIG7Do28gZXN0aXZlciBhdXRlbnRpY2Fkb1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ210Zy1jb2xsZWN0aW9ucycsIEpTT04uc3RyaW5naWZ5KGNvbGxlY3Rpb25zKSk7XG4gICAgfVxuICB9LCBbY29sbGVjdGlvbnMsIHNlc3Npb25dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ210Zy1kZWNrcycsIEpTT04uc3RyaW5naWZ5KGRlY2tzKSk7XG4gICAgfVxuICB9LCBbZGVja3MsIHNlc3Npb25dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ210Zy1mYXZvcml0ZXMnLCBKU09OLnN0cmluZ2lmeShmYXZvcml0ZXMpKTtcbiAgICB9XG4gIH0sIFtmYXZvcml0ZXMsIHNlc3Npb25dKTtcblxuICAvLyBGdW7Dp8O1ZXMgZGUgZ2VyZW5jaWFtZW50byBkZSBjb2xlw6fDo29cbiAgY29uc3QgY3JlYXRlQ29sbGVjdGlvbiA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcgPSAnJyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuY3JlYXRlKHsgbmFtZSwgZGVzY3JpcHRpb24gfSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IFsuLi5wcmV2LCByZXNwb25zZS5kYXRhXSk7XG4gICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChyZXNwb25zZS5kYXRhLmlkKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm8gYW8gY3JpYXIgY29sZcOnw6NvJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNyaWFyIGNvbGXDp8OjbzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3QgbmV3Q29sbGVjdGlvbjogVXNlckNvbGxlY3Rpb24gPSB7XG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBjYXJkczogW10sXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgaXNQdWJsaWM6IGZhbHNlLFxuICAgICAgfTtcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gWy4uLnByZXYsIG5ld0NvbGxlY3Rpb25dKTtcbiAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQobmV3Q29sbGVjdGlvbi5pZCk7XG4gICAgICByZXR1cm4gbmV3Q29sbGVjdGlvbi5pZDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlQ29sbGVjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFVzZXJDb2xsZWN0aW9uPik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLnVwZGF0ZShpZCwgdXBkYXRlcyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IGMuaWQgPT09IGlkID8geyAuLi5jLCAuLi51cGRhdGVzIH0gOiBjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYXR1YWxpemFyIGNvbGXDp8OjbzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IGMuaWQgPT09IGlkID8geyAuLi5jLCAuLi51cGRhdGVzLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9IDogYykpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBkZWxldGVDb2xsZWN0aW9uID0gYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5kZWxldGUoaWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlvbnMgPSBwcmV2LmZpbHRlcihjID0+IGMuaWQgIT09IGlkKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29sbGVjdGlvbklkID09PSBpZCkge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKG5ld0NvbGxlY3Rpb25zLmxlbmd0aCA+IDAgPyBuZXdDb2xsZWN0aW9uc1swXS5pZCA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbGxlY3Rpb25zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGV4Y2x1aXIgY29sZcOnw6NvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlvbnMgPSBwcmV2LmZpbHRlcihjID0+IGMuaWQgIT09IGlkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2xsZWN0aW9uSWQgPT09IGlkKSB7XG4gICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChuZXdDb2xsZWN0aW9ucy5sZW5ndGggPiAwID8gbmV3Q29sbGVjdGlvbnNbMF0uaWQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Q29sbGVjdGlvbnM7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZHVwbGljYXRlQ29sbGVjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgY29sbGVjdGlvblRvRHVwbGljYXRlID0gY29sbGVjdGlvbnMuZmluZChjID0+IGMuaWQgPT09IGlkKTtcbiAgICBpZiAoIWNvbGxlY3Rpb25Ub0R1cGxpY2F0ZSkgcmV0dXJuO1xuXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgbmFtZTogYCR7Y29sbGVjdGlvblRvRHVwbGljYXRlLm5hbWV9IChDw7NwaWEpYCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogY29sbGVjdGlvblRvRHVwbGljYXRlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlzUHVibGljOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5jcmVhdGUobmV3Q29sbGVjdGlvbik7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAvLyBBZGljaW9uYXIgY2FydGFzIMOgIG5vdmEgY29sZcOnw6NvXG4gICAgICAgICAgZm9yIChjb25zdCBjYXJkSXRlbSBvZiBjb2xsZWN0aW9uVG9EdXBsaWNhdGUuY2FyZHMpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmFkZENhcmQocmVzcG9uc2UuZGF0YS5pZCwge1xuICAgICAgICAgICAgICBjYXJkOiBjYXJkSXRlbS5jYXJkLFxuICAgICAgICAgICAgICBxdWFudGl0eTogY2FyZEl0ZW0ucXVhbnRpdHksXG4gICAgICAgICAgICAgIGNvbmRpdGlvbjogY2FyZEl0ZW0uY29uZGl0aW9uLFxuICAgICAgICAgICAgICBmb2lsOiBjYXJkSXRlbS5mb2lsLFxuICAgICAgICAgICAgICBsYW5ndWFnZTogY2FyZEl0ZW0ubGFuZ3VhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuZ2V0QnlJZChyZXNwb25zZS5kYXRhLmlkKTtcbiAgICAgICAgICBpZiAodXBkYXRlZFJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gWy4uLnByZXYsIHVwZGF0ZWRSZXNwb25zZS5kYXRhXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGR1cGxpY2FyIGNvbGXDp8OjbzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3QgbmV3Q29sbGVjdGlvbjogVXNlckNvbGxlY3Rpb24gPSB7XG4gICAgICAgIC4uLmNvbGxlY3Rpb25Ub0R1cGxpY2F0ZSxcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZTogYCR7Y29sbGVjdGlvblRvRHVwbGljYXRlLm5hbWV9IChDw7NwaWEpYCxcbiAgICAgIH07XG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdDb2xsZWN0aW9uXSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bsOnw6NvIHBhcmEgYWRpY2lvbmFyIGNhcnRhIMOgIGNvbGXDp8Ojb1xuICBjb25zdCBhZGljaW9uYXJDYXJ0YSA9IGFzeW5jIChjYXJkOiBNVEdDYXJkLCBxdWFudGlkYWRlOiBudW1iZXIgPSAxKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKCFjdXJyZW50Q29sbGVjdGlvbklkKSByZXR1cm47XG4gICAgXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmFkZENhcmQoY3VycmVudENvbGxlY3Rpb25JZCwge1xuICAgICAgICAgIGNhcmQsXG4gICAgICAgICAgcXVhbnRpdHk6IHF1YW50aWRhZGUsXG4gICAgICAgICAgY29uZGl0aW9uOiAnTmVhciBNaW50JyxcbiAgICAgICAgICBmb2lsOiBmYWxzZSxcbiAgICAgICAgICBsYW5ndWFnZTogJ0VuZ2xpc2gnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEJ5SWQoY3VycmVudENvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IGMuaWQgPT09IGN1cnJlbnRDb2xsZWN0aW9uSWQgPyByZXNwb25zZS5kYXRhIDogYykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGFkaWNpb25hciBjYXJ0YTonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IHtcbiAgICAgICAgaWYgKGMuaWQgIT09IGN1cnJlbnRDb2xsZWN0aW9uSWQpIHJldHVybiBjO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYXJkID0gYy5jYXJkcy5maW5kKGNjID0+IGNjLmNhcmQuaWQgPT09IGNhcmQuaWQpO1xuICAgICAgICBsZXQgbmV3Q2FyZHM7XG4gICAgICAgIGlmIChleGlzdGluZ0NhcmQpIHtcbiAgICAgICAgICBuZXdDYXJkcyA9IGMuY2FyZHMubWFwKGNjID0+XG4gICAgICAgICAgICBjYy5jYXJkLmlkID09PSBjYXJkLmlkXG4gICAgICAgICAgICAgID8geyAuLi5jYywgcXVhbnRpdHk6IGNjLnF1YW50aXR5ICsgcXVhbnRpZGFkZSB9XG4gICAgICAgICAgICAgIDogY2NcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NhcmRzID0gWy4uLmMuY2FyZHMsIHtcbiAgICAgICAgICAgIGNhcmQsXG4gICAgICAgICAgICBxdWFudGl0eTogcXVhbnRpZGFkZSxcbiAgICAgICAgICAgIGNvbmRpdGlvbjogJ05lYXIgTWludCcsXG4gICAgICAgICAgICBmb2lsOiBmYWxzZVxuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmMsIGNhcmRzOiBuZXdDYXJkcywgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuw6fDo28gcGFyYSByZW1vdmVyIGNhcnRhIGRhIGNvbGXDp8Ojb1xuICBjb25zdCByZW1vdmVyQ2FydGEgPSBhc3luYyAoY2FyZDogTVRHQ2FyZCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghY3VycmVudENvbGxlY3Rpb25JZCkgcmV0dXJuO1xuICAgIFxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBFbmNvbnRyYXIgbyBJRCBkYSBjYXJ0YSBuYSBjb2xlw6fDo29cbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBjdXJyZW50Q29sbGVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjYXJkSW5Db2xsZWN0aW9uID0gY29sbGVjdGlvbi5jYXJkcy5maW5kKGNjID0+IGNjLmNhcmQuaWQgPT09IGNhcmQuaWQpO1xuICAgICAgICBpZiAoIWNhcmRJbkNvbGxlY3Rpb24pIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGlmIChjYXJkSW5Db2xsZWN0aW9uLnF1YW50aXR5ID4gMSkge1xuICAgICAgICAgIC8vIEF0dWFsaXphciBxdWFudGlkYWRlXG4gICAgICAgICAgYXdhaXQgY29sbGVjdGlvblNlcnZpY2UudXBkYXRlQ2FyZChjdXJyZW50Q29sbGVjdGlvbklkLCBjYXJkSW5Db2xsZWN0aW9uLl9pZCwge1xuICAgICAgICAgICAgcXVhbnRpdHk6IGNhcmRJbkNvbGxlY3Rpb24ucXVhbnRpdHkgLSAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlciBjYXJ0YVxuICAgICAgICAgIGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLnJlbW92ZUNhcmQoY3VycmVudENvbGxlY3Rpb25JZCwgY2FyZEluQ29sbGVjdGlvbi5faWQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuZ2V0QnlJZChjdXJyZW50Q29sbGVjdGlvbklkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbGxlY3Rpb25JZCA/IHJlc3BvbnNlLmRhdGEgOiBjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gcmVtb3ZlciBjYXJ0YTonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IHtcbiAgICAgICAgaWYgKGMuaWQgIT09IGN1cnJlbnRDb2xsZWN0aW9uSWQpIHJldHVybiBjO1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FyZCA9IGMuY2FyZHMuZmluZChjYyA9PiBjYy5jYXJkLmlkID09PSBjYXJkLmlkKTtcbiAgICAgICAgbGV0IG5ld0NhcmRzO1xuICAgICAgICBpZiAoZXhpc3RpbmdDYXJkICYmIGV4aXN0aW5nQ2FyZC5xdWFudGl0eSA+IDEpIHtcbiAgICAgICAgICBuZXdDYXJkcyA9IGMuY2FyZHMubWFwKGNjID0+XG4gICAgICAgICAgICBjYy5jYXJkLmlkID09PSBjYXJkLmlkXG4gICAgICAgICAgICAgID8geyAuLi5jYywgcXVhbnRpdHk6IGNjLnF1YW50aXR5IC0gMSB9XG4gICAgICAgICAgICAgIDogY2NcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NhcmRzID0gYy5jYXJkcy5maWx0ZXIoY2MgPT4gY2MuY2FyZC5pZCAhPT0gY2FyZC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uYywgY2FyZHM6IG5ld0NhcmRzLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9O1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW7Dp8OjbyBwYXJhIG9idGVyIHF1YW50aWRhZGUgZGUgdW1hIGNhcnRhIG5hIGNvbGXDp8Ojb1xuICBjb25zdCBnZXRRdWFudGlkYWRlTmFDb2xlY2FvID0gKGNhcmRJZDogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCBjYXJkID0gY3VycmVudENvbGxlY3Rpb24/LmNhcmRzPy5maW5kKGMgPT4gYy5jYXJkLmlkID09PSBjYXJkSWQpO1xuICAgIHJldHVybiBjYXJkID8gY2FyZC5xdWFudGl0eSA6IDA7XG4gIH07XG5cbiAgLy8gPT09PT09IEZVTsOHw5VFUyBERSBHRVJFTkNJQU1FTlRPIERFIERFQ0tTID09PT09PVxuXG4gIC8vIENyaWFyIG5vdm8gZGVja1xuICBjb25zdCBjcmlhckRlY2sgPSBhc3luYyAoZGVja0RhdGE6IE9taXQ8RGVjaywgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ2xhc3RNb2RpZmllZCc+KTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5jcmVhdGUoZGVja0RhdGEpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgc2V0RGVja3MocHJldiA9PiBbLi4ucHJldiwgcmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJybyBhbyBjcmlhciBkZWNrJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNyaWFyIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IG5ld0RlY2s6IERlY2sgPSB7XG4gICAgICAgIC4uLmRlY2tEYXRhLFxuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgc2V0RGVja3MocHJldiA9PiBbLi4ucHJldiwgbmV3RGVja10pO1xuICAgICAgcmV0dXJuIG5ld0RlY2suaWQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVkaXRhciBkZWNrIGV4aXN0ZW50ZVxuICBjb25zdCBlZGl0YXJEZWNrID0gYXN5bmMgKGRlY2tJZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPERlY2s+KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UudXBkYXRlKGRlY2tJZCwgdXBkYXRlcyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IFxuICAgICAgICAgICAgZGVjay5pZCA9PT0gZGVja0lkIFxuICAgICAgICAgICAgICA/IHsgLi4uZGVjaywgLi4udXBkYXRlcyB9XG4gICAgICAgICAgICAgIDogZGVja1xuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGVkaXRhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gXG4gICAgICAgIGRlY2suaWQgPT09IGRlY2tJZCBcbiAgICAgICAgICA/IHsgLi4uZGVjaywgLi4udXBkYXRlcywgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfVxuICAgICAgICAgIDogZGVja1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERlbGV0YXIgZGVja1xuICBjb25zdCBkZWxldGFyRGVjayA9IGFzeW5jIChkZWNrSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmRlbGV0ZShkZWNrSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5maWx0ZXIoZGVjayA9PiBkZWNrLmlkICE9PSBkZWNrSWQpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBkZWxldGFyIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5maWx0ZXIoZGVjayA9PiBkZWNrLmlkICE9PSBkZWNrSWQpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRHVwbGljYXIgZGVja1xuICBjb25zdCBkdXBsaWNhckRlY2sgPSBhc3luYyAoZGVja0lkOiBzdHJpbmcsIG5ld05hbWU/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4gPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRGVjayA9IGRlY2tzLmZpbmQoZGVjayA9PiBkZWNrLmlkID09PSBkZWNrSWQpO1xuICAgIGlmICghb3JpZ2luYWxEZWNrKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld0RlY2tEYXRhID0ge1xuICAgICAgICAgIG5hbWU6IG5ld05hbWUgfHwgYCR7b3JpZ2luYWxEZWNrLm5hbWV9IChDw7NwaWEpYCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogb3JpZ2luYWxEZWNrLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGZvcm1hdDogb3JpZ2luYWxEZWNrLmZvcm1hdCxcbiAgICAgICAgICBjb2xvcnM6IG9yaWdpbmFsRGVjay5jb2xvcnMsXG4gICAgICAgICAgaXNQdWJsaWM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmNyZWF0ZShuZXdEZWNrRGF0YSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAvLyBBZGljaW9uYXIgY2FydGFzIGFvIG5vdm8gZGVja1xuICAgICAgICAgIGZvciAoY29uc3QgY2FyZEl0ZW0gb2Ygb3JpZ2luYWxEZWNrLmNhcmRzKSB7XG4gICAgICAgICAgICBhd2FpdCBkZWNrU2VydmljZS5hZGRDYXJkKHJlc3BvbnNlLmRhdGEuaWQsIHtcbiAgICAgICAgICAgICAgY2FyZDogY2FyZEl0ZW0uY2FyZCxcbiAgICAgICAgICAgICAgcXVhbnRpdHk6IGNhcmRJdGVtLnF1YW50aXR5LFxuICAgICAgICAgICAgICBpc1NpZGVib2FyZDogY2FyZEl0ZW0uY2F0ZWdvcnkgPT09ICdzaWRlYm9hcmQnLFxuICAgICAgICAgICAgICBpc0NvbW1hbmRlcjogY2FyZEl0ZW0uY2F0ZWdvcnkgPT09ICdjb21tYW5kZXInLFxuICAgICAgICAgICAgICBjYXRlZ29yeTogY2FyZEl0ZW0uY2F0ZWdvcnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuZ2V0QnlJZChyZXNwb25zZS5kYXRhLmlkKTtcbiAgICAgICAgICBpZiAodXBkYXRlZFJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gWy4uLnByZXYsIHVwZGF0ZWRSZXNwb25zZS5kYXRhXSk7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZFJlc3BvbnNlLmRhdGEuaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGR1cGxpY2FyIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZWREZWNrOiBEZWNrID0ge1xuICAgICAgICAuLi5vcmlnaW5hbERlY2ssXG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IG5ld05hbWUgfHwgYCR7b3JpZ2luYWxEZWNrLm5hbWV9IChDw7NwaWEpYCxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIHNldERlY2tzKHByZXYgPT4gWy4uLnByZXYsIGR1cGxpY2F0ZWREZWNrXSk7XG4gICAgICByZXR1cm4gZHVwbGljYXRlZERlY2suaWQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkaWNpb25hciBjYXJ0YSBhbyBkZWNrXG4gIGNvbnN0IGFkaWNpb25hckNhcnRhQW9EZWNrID0gYXN5bmMgKFxuICAgIGRlY2tJZDogc3RyaW5nLCBcbiAgICBjYXJkOiBNVEdDYXJkLCBcbiAgICBjYXRlZ29yeTogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInID0gJ21haW5ib2FyZCcsXG4gICAgcXVhbnRpdHk6IG51bWJlciA9IDFcbiAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRlY2tTZXJ2aWNlLmFkZENhcmQoZGVja0lkLCB7XG4gICAgICAgICAgY2FyZCxcbiAgICAgICAgICBxdWFudGl0eSxcbiAgICAgICAgICBpc1NpZGVib2FyZDogY2F0ZWdvcnkgPT09ICdzaWRlYm9hcmQnLFxuICAgICAgICAgIGlzQ29tbWFuZGVyOiBjYXRlZ29yeSA9PT0gJ2NvbW1hbmRlcicsXG4gICAgICAgICAgY2F0ZWdvcnlcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuZ2V0QnlJZChkZWNrSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiBkZWNrLmlkID09PSBkZWNrSWQgPyByZXNwb25zZS5kYXRhIDogZGVjaykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGFkaWNpb25hciBjYXJ0YSBhbyBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4ge1xuICAgICAgICBpZiAoZGVjay5pZCA9PT0gZGVja0lkKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDYXJkID0gZGVjay5jYXJkcy5maW5kKGMgPT4gYy5jYXJkLmlkID09PSBjYXJkLmlkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdDYXJkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5kZWNrLFxuICAgICAgICAgICAgICBjYXJkczogZGVjay5jYXJkcy5tYXAoYyA9PiBcbiAgICAgICAgICAgICAgICBjLmNhcmQuaWQgPT09IGNhcmQuaWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgID8geyAuLi5jLCBxdWFudGl0eTogYy5xdWFudGl0eSArIHF1YW50aXR5IH1cbiAgICAgICAgICAgICAgICAgIDogY1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZGVjayxcbiAgICAgICAgICAgICAgY2FyZHM6IFsuLi5kZWNrLmNhcmRzLCB7IGNhcmQsIHF1YW50aXR5LCBjYXRlZ29yeSB9XSxcbiAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNrO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZW1vdmVyIGNhcnRhIGRvIGRlY2tcbiAgY29uc3QgcmVtb3ZlckNhcnRhRG9EZWNrID0gYXN5bmMgKFxuICAgIGRlY2tJZDogc3RyaW5nLCBcbiAgICBjYXJkSWQ6IHN0cmluZywgXG4gICAgY2F0ZWdvcnk6ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnXG4gICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBFbmNvbnRyYXIgbyBJRCBkYSBjYXJ0YSBubyBkZWNrXG4gICAgICAgIGNvbnN0IGRlY2sgPSBkZWNrcy5maW5kKGQgPT4gZC5pZCA9PT0gZGVja0lkKTtcbiAgICAgICAgaWYgKCFkZWNrKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjYXJkSW5EZWNrID0gZGVjay5jYXJkcy5maW5kKGMgPT4gYy5jYXJkLmlkID09PSBjYXJkSWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpO1xuICAgICAgICBpZiAoIWNhcmRJbkRlY2spIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGRlY2tTZXJ2aWNlLnJlbW92ZUNhcmQoZGVja0lkLCBjYXJkSW5EZWNrLl9pZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuZ2V0QnlJZChkZWNrSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiBkZWNrLmlkID09PSBkZWNrSWQgPyByZXNwb25zZS5kYXRhIDogZGVjaykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlbW92ZXIgY2FydGEgZG8gZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IHtcbiAgICAgICAgaWYgKGRlY2suaWQgPT09IGRlY2tJZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kZWNrLFxuICAgICAgICAgICAgY2FyZHM6IGRlY2suY2FyZHMuZmlsdGVyKGMgPT4gIShjLmNhcmQuaWQgPT09IGNhcmRJZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeSkpLFxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNrO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBdHVhbGl6YXIgcXVhbnRpZGFkZSBkZSBjYXJ0YSBubyBkZWNrXG4gIGNvbnN0IGF0dWFsaXphclF1YW50aWRhZGVOb0RlY2sgPSBhc3luYyAoXG4gICAgZGVja0lkOiBzdHJpbmcsIFxuICAgIGNhcmRJZDogc3RyaW5nLCBcbiAgICBub3ZhUXVhbnRpZGFkZTogbnVtYmVyLCBcbiAgICBjYXRlZ29yeTogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInID0gJ21haW5ib2FyZCdcbiAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKG5vdmFRdWFudGlkYWRlIDw9IDApIHtcbiAgICAgIGF3YWl0IHJlbW92ZXJDYXJ0YURvRGVjayhkZWNrSWQsIGNhcmRJZCwgY2F0ZWdvcnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBFbmNvbnRyYXIgbyBJRCBkYSBjYXJ0YSBubyBkZWNrXG4gICAgICAgIGNvbnN0IGRlY2sgPSBkZWNrcy5maW5kKGQgPT4gZC5pZCA9PT0gZGVja0lkKTtcbiAgICAgICAgaWYgKCFkZWNrKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjYXJkSW5EZWNrID0gZGVjay5jYXJkcy5maW5kKGMgPT4gYy5jYXJkLmlkID09PSBjYXJkSWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpO1xuICAgICAgICBpZiAoIWNhcmRJbkRlY2spIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IGRlY2tTZXJ2aWNlLnVwZGF0ZUNhcmQoZGVja0lkLCBjYXJkSW5EZWNrLl9pZCwgeyBxdWFudGl0eTogbm92YVF1YW50aWRhZGUgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHVhbGl6YXIgZXN0YWRvIGxvY2FsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuZ2V0QnlJZChkZWNrSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiBkZWNrLmlkID09PSBkZWNrSWQgPyByZXNwb25zZS5kYXRhIDogZGVjaykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGF0dWFsaXphciBxdWFudGlkYWRlIG5vIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiB7XG4gICAgICAgIGlmIChkZWNrLmlkID09PSBkZWNrSWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGVjayxcbiAgICAgICAgICAgIGNhcmRzOiBkZWNrLmNhcmRzLm1hcChjID0+IFxuICAgICAgICAgICAgICBjLmNhcmQuaWQgPT09IGNhcmRJZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeVxuICAgICAgICAgICAgICAgID8geyAuLi5jLCBxdWFudGl0eTogbm92YVF1YW50aWRhZGUgfVxuICAgICAgICAgICAgICAgIDogY1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaztcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gT2J0ZXIgY2FydGFzIHF1ZSBlc3TDo28gc2VuZG8gdXNhZGFzIGVtIGRlY2tzXG4gIGNvbnN0IGdldENhcnRhc1VzYWRhc0VtRGVja3MgPSAoY2FyZElkOiBzdHJpbmcpOiBBcnJheTx7ZGVjazogRGVjaywgcXVhbnRpdHk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZ30+ID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IEFycmF5PHtkZWNrOiBEZWNrLCBxdWFudGl0eTogbnVtYmVyLCBjYXRlZ29yeTogc3RyaW5nfT4gPSBbXTtcbiAgICBcbiAgICBkZWNrcy5mb3JFYWNoKGRlY2sgPT4ge1xuICAgICAgZGVjay5jYXJkcy5mb3JFYWNoKGRlY2tDYXJkID0+IHtcbiAgICAgICAgaWYgKGRlY2tDYXJkLmNhcmQuaWQgPT09IGNhcmRJZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGRlY2ssXG4gICAgICAgICAgICBxdWFudGl0eTogZGVja0NhcmQucXVhbnRpdHksXG4gICAgICAgICAgICBjYXRlZ29yeTogZGVja0NhcmQuY2F0ZWdvcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyA9PT09PT0gRlVOw4fDlUVTIERFIEdFUkVOQ0lBTUVOVE8gREUgRkFWT1JJVE9TID09PT09PVxuXG4gIC8vIEFkaWNpb25hciBjYXJ0YSBhb3MgZmF2b3JpdG9zXG4gIGNvbnN0IGFkZEZhdm9yaXRlID0gYXN5bmMgKGNhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmYXZvcml0ZVNlcnZpY2UuYWRkKGNhcmQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldEZhdm9yaXRlcyhwcmV2ID0+IFsuLi5wcmV2LCBjYXJkXSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYWRpY2lvbmFyIGZhdm9yaXRvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiB7XG4gICAgICAgIGlmIChwcmV2LnNvbWUoYyA9PiBjLmlkID09PSBjYXJkLmlkKSkgcmV0dXJuIHByZXY7XG4gICAgICAgIHJldHVybiBbLi4ucHJldiwgY2FyZF07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlciBjYXJ0YSBkb3MgZmF2b3JpdG9zXG4gIGNvbnN0IHJlbW92ZUZhdm9yaXRlID0gYXN5bmMgKGNhcmRJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmF2b3JpdGVTZXJ2aWNlLnJlbW92ZUNhcmQoY2FyZElkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiBwcmV2LmZpbHRlcihjYXJkID0+IGNhcmQuaWQgIT09IGNhcmRJZCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlbW92ZXIgZmF2b3JpdG86JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldEZhdm9yaXRlcyhwcmV2ID0+IHByZXYuZmlsdGVyKGNhcmQgPT4gY2FyZC5pZCAhPT0gY2FyZElkKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFZlcmlmaWNhciBzZSB1bWEgY2FydGEgZXN0w6Egbm9zIGZhdm9yaXRvc1xuICBjb25zdCBpc0Zhdm9yaXRlID0gKGNhcmRJZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIGZhdm9yaXRlcy5zb21lKGNhcmQgPT4gY2FyZC5pZCA9PT0gY2FyZElkKTtcbiAgfTtcblxuICAvLyBGdW7Dp8OjbyBwYXJhIGV4cG9ydGFyIGNvbGXDp8OjbyBwYXJhIENTViBubyBmb3JtYXRvIE1hbmFib3hcbiAgY29uc3QgZXhwb3J0Q29sbGVjdGlvblRvQ1NWID0gKGNvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uKSA9PiB7XG4gICAgLy8gRm9ybWF0byBNYW5hYm94OiBOYW1lLFNldCxRdWFudGl0eSxGb2lsLENvbmRpdGlvbixMYW5ndWFnZVxuICAgIGNvbnN0IGNzdkNvbnRlbnQgPSBbXG4gICAgICBbJ05hbWUnLCAnU2V0JywgJ1F1YW50aXR5JywgJ0ZvaWwnLCAnQ29uZGl0aW9uJywgJ0xhbmd1YWdlJ10sXG4gICAgICAuLi5jb2xsZWN0aW9uLmNhcmRzLm1hcChjID0+IFtcbiAgICAgICAgYy5jYXJkLm5hbWUsXG4gICAgICAgIGMuY2FyZC5zZXRfY29kZSxcbiAgICAgICAgYy5xdWFudGl0eS50b1N0cmluZygpLFxuICAgICAgICBjLmZvaWwgPyAnRm9pbCcgOiAnTm9uLWZvaWwnLFxuICAgICAgICBjLmNvbmRpdGlvbiB8fCAnTmVhciBNaW50JyxcbiAgICAgICAgYy5sYW5ndWFnZSB8fCAnRW5nbGlzaCdcbiAgICAgIF0pXG4gICAgXS5tYXAocm93ID0+IHJvdy5qb2luKCcsJykpLmpvaW4oJ1xcbicpO1xuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjc3ZDb250ZW50XSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgIGNvbnN0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5ocmVmID0gdXJsO1xuICAgIGEuZG93bmxvYWQgPSBgJHtjb2xsZWN0aW9uLm5hbWV9X21hbmFib3guY3N2YDtcbiAgICBhLmNsaWNrKCk7XG4gICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxBcHBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBjb2xsZWN0aW9ucyxcbiAgICAgIGN1cnJlbnRDb2xsZWN0aW9uLFxuICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb246IHNldENvbGxlY3Rpb25zLFxuICAgICAgY3VycmVudENvbGxlY3Rpb25JZCxcbiAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQsXG4gICAgICBjcmVhdGVDb2xsZWN0aW9uLFxuICAgICAgdXBkYXRlQ29sbGVjdGlvbixcbiAgICAgIGRlbGV0ZUNvbGxlY3Rpb24sXG4gICAgICBkdXBsaWNhdGVDb2xsZWN0aW9uLFxuICAgICAgYWRpY2lvbmFyQ2FydGEsXG4gICAgICByZW1vdmVyQ2FydGEsXG4gICAgICBnZXRRdWFudGlkYWRlTmFDb2xlY2FvLFxuICAgICAgZGVja3MsXG4gICAgICBzZXREZWNrcyxcbiAgICAgIGNyaWFyRGVjayxcbiAgICAgIGVkaXRhckRlY2ssXG4gICAgICBkZWxldGFyRGVjayxcbiAgICAgIGR1cGxpY2FyRGVjayxcbiAgICAgIGFkaWNpb25hckNhcnRhQW9EZWNrLFxuICAgICAgcmVtb3ZlckNhcnRhRG9EZWNrLFxuICAgICAgYXR1YWxpemFyUXVhbnRpZGFkZU5vRGVjayxcbiAgICAgIGdldENhcnRhc1VzYWRhc0VtRGVja3MsXG4gICAgICBmYXZvcml0ZXMsXG4gICAgICBhZGRGYXZvcml0ZSxcbiAgICAgIHJlbW92ZUZhdm9yaXRlLFxuICAgICAgaXNGYXZvcml0ZSxcbiAgICAgIGxvYWRpbmcsXG4gICAgICBleHBvcnRDb2xsZWN0aW9uVG9DU1ZcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0FwcENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59OyJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjb2xsZWN0aW9uU2VydmljZSIsImRlY2tTZXJ2aWNlIiwiZmF2b3JpdGVTZXJ2aWNlIiwidXNlU2Vzc2lvbiIsIkFwcENvbnRleHQiLCJ1c2VBcHBDb250ZXh0IiwiY29udGV4dCIsIkVycm9yIiwiQXBwUHJvdmlkZXIiLCJjaGlsZHJlbiIsImRhdGEiLCJzZXNzaW9uIiwiY29sbGVjdGlvbnMiLCJzZXRDb2xsZWN0aW9ucyIsImN1cnJlbnRDb2xsZWN0aW9uSWQiLCJzZXRDdXJyZW50Q29sbGVjdGlvbklkIiwiZGVja3MiLCJzZXREZWNrcyIsImZhdm9yaXRlcyIsInNldEZhdm9yaXRlcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY3VycmVudENvbGxlY3Rpb24iLCJ1c2VNZW1vIiwiZmluZCIsImMiLCJpZCIsImxvYWREYXRhIiwiY29sbGVjdGlvbnNSZXNwb25zZSIsImdldEFsbCIsInN1Y2Nlc3MiLCJsZW5ndGgiLCJkZWNrc1Jlc3BvbnNlIiwiZmF2b3JpdGVzUmVzcG9uc2UiLCJtYXAiLCJmYXYiLCJjYXJkIiwiZXJyb3IiLCJjb25zb2xlIiwic2F2ZWRDb2xsZWN0aW9ucyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWRDb2xsZWN0aW9ucyIsIkpTT04iLCJwYXJzZSIsImRlZmF1bHRDb2xsZWN0aW9uIiwibmFtZSIsImRlc2NyaXB0aW9uIiwiY2FyZHMiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJpc1B1YmxpYyIsInNhdmVkRGVja3MiLCJwYXJzZWREZWNrcyIsInNhdmVkRmF2b3JpdGVzIiwicGFyc2VkRmF2b3JpdGVzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImNyZWF0ZUNvbGxlY3Rpb24iLCJyZXNwb25zZSIsImNyZWF0ZSIsInByZXYiLCJuZXdDb2xsZWN0aW9uIiwibm93IiwidG9TdHJpbmciLCJ1cGRhdGVDb2xsZWN0aW9uIiwidXBkYXRlcyIsInVwZGF0ZSIsImRlbGV0ZUNvbGxlY3Rpb24iLCJkZWxldGUiLCJuZXdDb2xsZWN0aW9ucyIsImZpbHRlciIsImR1cGxpY2F0ZUNvbGxlY3Rpb24iLCJjb2xsZWN0aW9uVG9EdXBsaWNhdGUiLCJjYXJkSXRlbSIsImFkZENhcmQiLCJxdWFudGl0eSIsImNvbmRpdGlvbiIsImZvaWwiLCJsYW5ndWFnZSIsInVwZGF0ZWRSZXNwb25zZSIsImdldEJ5SWQiLCJhZGljaW9uYXJDYXJ0YSIsInF1YW50aWRhZGUiLCJleGlzdGluZ0NhcmQiLCJjYyIsIm5ld0NhcmRzIiwicmVtb3ZlckNhcnRhIiwiY29sbGVjdGlvbiIsImNhcmRJbkNvbGxlY3Rpb24iLCJ1cGRhdGVDYXJkIiwiX2lkIiwicmVtb3ZlQ2FyZCIsImdldFF1YW50aWRhZGVOYUNvbGVjYW8iLCJjYXJkSWQiLCJjcmlhckRlY2siLCJkZWNrRGF0YSIsIm5ld0RlY2siLCJsYXN0TW9kaWZpZWQiLCJlZGl0YXJEZWNrIiwiZGVja0lkIiwiZGVjayIsImRlbGV0YXJEZWNrIiwiZHVwbGljYXJEZWNrIiwibmV3TmFtZSIsIm9yaWdpbmFsRGVjayIsInVuZGVmaW5lZCIsIm5ld0RlY2tEYXRhIiwiZm9ybWF0IiwiY29sb3JzIiwiaXNTaWRlYm9hcmQiLCJjYXRlZ29yeSIsImlzQ29tbWFuZGVyIiwiZHVwbGljYXRlZERlY2siLCJhZGljaW9uYXJDYXJ0YUFvRGVjayIsInJlbW92ZXJDYXJ0YURvRGVjayIsImQiLCJjYXJkSW5EZWNrIiwiYXR1YWxpemFyUXVhbnRpZGFkZU5vRGVjayIsIm5vdmFRdWFudGlkYWRlIiwiZ2V0Q2FydGFzVXNhZGFzRW1EZWNrcyIsInJlc3VsdCIsImZvckVhY2giLCJkZWNrQ2FyZCIsInB1c2giLCJhZGRGYXZvcml0ZSIsImFkZCIsInNvbWUiLCJyZW1vdmVGYXZvcml0ZSIsImlzRmF2b3JpdGUiLCJleHBvcnRDb2xsZWN0aW9uVG9DU1YiLCJjc3ZDb250ZW50Iiwic2V0X2NvZGUiLCJyb3ciLCJqb2luIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwid2luZG93IiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImNsaWNrIiwicmV2b2tlT2JqZWN0VVJMIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInNldEN1cnJlbnRDb2xsZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/AppContext.tsx\n"));

/***/ })

});