"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"1d8f0973a430\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzZmZjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxZDhmMDk3M2E0MzBcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./contexts/AppContext.tsx":
/*!*********************************!*\
  !*** ./contexts/AppContext.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: function() { return /* binding */ AppProvider; },\n/* harmony export */   useAppContext: function() { return /* binding */ useAppContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_apiService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/apiService */ \"(app-pages-browser)/./utils/apiService.ts\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ useAppContext,AppProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useAppContext = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (!context) {\n        throw new Error(\"useAppContext deve ser usado dentro de um AppProvider\");\n    }\n    return context;\n};\n_s(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst AppProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession)();\n    const [collections, setCollections] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCollectionId, setCurrentCollectionId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [decks, setDecks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [favorites, setFavorites] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const currentCollection = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(()=>{\n        return collections.find((c)=>c.id === currentCollectionId);\n    }, [\n        collections,\n        currentCollectionId\n    ]);\n    // Carregar dados da API quando o usuário estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (session) {\n                setLoading(true);\n                try {\n                    // Carregar coleções\n                    const collectionsResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getAll();\n                    if (collectionsResponse.success && collectionsResponse.data) {\n                        setCollections(collectionsResponse.data);\n                        if (collectionsResponse.data.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(collectionsResponse.data[0].id);\n                        }\n                    }\n                    // Carregar decks\n                    const decksResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getAll();\n                    if (decksResponse.success && decksResponse.data) {\n                        setDecks(decksResponse.data);\n                    }\n                    // Carregar favoritos\n                    const favoritesResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.getAll();\n                    if (favoritesResponse.success && favoritesResponse.data) {\n                        setFavorites(favoritesResponse.data.map((fav)=>fav.card));\n                    }\n                } catch (error) {\n                    console.error(\"Erro ao carregar dados:\", error);\n                } finally{\n                    setLoading(false);\n                }\n            } else {\n                // Usuário não autenticado, usar localStorage como fallback\n                const savedCollections = localStorage.getItem(\"mtg-collections\");\n                if (savedCollections) {\n                    try {\n                        const parsedCollections = JSON.parse(savedCollections);\n                        setCollections(parsedCollections);\n                        if (parsedCollections.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(parsedCollections[0].id);\n                        }\n                    } catch (error) {\n                        console.error(\"Erro ao carregar cole\\xe7\\xf5es salvas:\", error);\n                    }\n                } else {\n                    // Criar uma coleção padrão se não houver nenhuma\n                    const defaultCollection = {\n                        id: \"1\",\n                        name: \"Minha Cole\\xe7\\xe3o\",\n                        description: \"Cole\\xe7\\xe3o principal de cartas Magic\",\n                        cards: [],\n                        createdAt: new Date().toISOString(),\n                        updatedAt: new Date().toISOString(),\n                        isPublic: false\n                    };\n                    setCollections([\n                        defaultCollection\n                    ]);\n                    setCurrentCollectionId(defaultCollection.id);\n                }\n                const savedDecks = localStorage.getItem(\"mtg-decks\");\n                if (savedDecks) {\n                    try {\n                        const parsedDecks = JSON.parse(savedDecks);\n                        setDecks(parsedDecks);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar decks salvos:\", error);\n                    }\n                }\n                const savedFavorites = localStorage.getItem(\"mtg-favorites\");\n                if (savedFavorites) {\n                    try {\n                        const parsedFavorites = JSON.parse(savedFavorites);\n                        setFavorites(parsedFavorites);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar favoritos salvos:\", error);\n                    }\n                }\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        session\n    ]);\n    // Salvar dados no localStorage quando não estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-collections\", JSON.stringify(collections));\n        }\n    }, [\n        collections,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-decks\", JSON.stringify(decks));\n        }\n    }, [\n        decks,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            localStorage.setItem(\"mtg-favorites\", JSON.stringify(favorites));\n        }\n    }, [\n        favorites,\n        session\n    ]);\n    // Funções de gerenciamento de coleção\n    const createCollection = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.create({\n                    name,\n                    description\n                });\n                if (response.success && response.data) {\n                    setCollections((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    setCurrentCollectionId(response.data.id);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar cole\\xe7\\xe3o\");\n            } catch (error) {\n                console.error(\"Erro ao criar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                id: Date.now().toString(),\n                name,\n                description,\n                cards: [],\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n                isPublic: false\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n            setCurrentCollectionId(newCollection.id);\n            return newCollection.id;\n        }\n    };\n    const updateCollection = async (id, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.update(id, updates);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                                ...c,\n                                ...updates\n                            } : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                        ...c,\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    } : c));\n        }\n    };\n    const deleteCollection = async (id)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.delete(id);\n                if (response.success) {\n                    setCollections((prev)=>{\n                        const newCollections = prev.filter((c)=>c.id !== id);\n                        if (currentCollectionId === id) {\n                            setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                        }\n                        return newCollections;\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erro ao excluir cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>{\n                const newCollections = prev.filter((c)=>c.id !== id);\n                if (currentCollectionId === id) {\n                    setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                }\n                return newCollections;\n            });\n        }\n    };\n    const duplicateCollection = async (id)=>{\n        const collectionToDuplicate = collections.find((c)=>c.id === id);\n        if (!collectionToDuplicate) return;\n        if (session) {\n            try {\n                const newCollection = {\n                    name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\"),\n                    description: collectionToDuplicate.description,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.create(newCollection);\n                if (response.success && response.data) {\n                    // Adicionar cartas à nova coleção\n                    for (const cardItem of collectionToDuplicate.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            condition: cardItem.condition,\n                            foil: cardItem.foil,\n                            language: cardItem.language\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setCollections((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Erro ao duplicar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                ...collectionToDuplicate,\n                id: Date.now().toString(),\n                name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\")\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n        }\n    };\n    // Função para adicionar carta à coleção\n    const adicionarCarta = async function(card) {\n        let quantidade = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.addCard(currentCollectionId, {\n                    card,\n                    quantity: quantidade,\n                    condition: \"Near Mint\",\n                    foil: false,\n                    language: \"English\"\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity + quantidade\n                            } : cc);\n                    } else {\n                        newCards = [\n                            ...c.cards,\n                            {\n                                card,\n                                quantity: quantidade,\n                                condition: \"Near Mint\",\n                                foil: false\n                            }\n                        ];\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para remover carta da coleção\n    const removerCarta = async (card)=>{\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                // Encontrar o ID da carta na coleção\n                const collection = collections.find((c)=>c.id === currentCollectionId);\n                if (!collection) return;\n                const cardInCollection = collection.cards.find((cc)=>cc.card.id === card.id);\n                if (!cardInCollection) return;\n                if (cardInCollection.quantity > 1) {\n                    // Atualizar quantidade\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.updateCard(currentCollectionId, cardInCollection._id, {\n                        quantity: cardInCollection.quantity - 1\n                    });\n                } else {\n                    // Remover carta\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.removeCard(currentCollectionId, cardInCollection._id);\n                }\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard && existingCard.quantity > 1) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity - 1\n                            } : cc);\n                    } else {\n                        newCards = c.cards.filter((cc)=>cc.card.id !== card.id);\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para obter quantidade de uma carta na coleção\n    const getQuantidadeNaColecao = (cardId)=>{\n        var _currentCollection_cards;\n        const card = currentCollection === null || currentCollection === void 0 ? void 0 : (_currentCollection_cards = currentCollection.cards) === null || _currentCollection_cards === void 0 ? void 0 : _currentCollection_cards.find((c)=>c.card.id === cardId);\n        return card ? card.quantity : 0;\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE DECKS ======\n    // Criar novo deck\n    const criarDeck = async (deckData)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.create(deckData);\n                if (response.success && response.data) {\n                    setDecks((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar deck\");\n            } catch (error) {\n                console.error(\"Erro ao criar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newDeck = {\n                ...deckData,\n                id: Date.now().toString(),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    newDeck\n                ]);\n            return newDeck.id;\n        }\n    };\n    // Editar deck existente\n    const editarDeck = async (deckId, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.update(deckId, updates);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                                ...deck,\n                                ...updates\n                            } : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao editar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                        ...deck,\n                        ...updates,\n                        lastModified: new Date().toISOString()\n                    } : deck));\n        }\n    };\n    // Deletar deck\n    const deletarDeck = async (deckId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.delete(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao deletar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n        }\n    };\n    // Duplicar deck\n    const duplicarDeck = async (deckId, newName)=>{\n        const originalDeck = decks.find((deck)=>deck.id === deckId);\n        if (!originalDeck) return undefined;\n        if (session) {\n            try {\n                const newDeckData = {\n                    name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                    description: originalDeck.description,\n                    format: originalDeck.format,\n                    colors: originalDeck.colors,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.create(newDeckData);\n                if (response.success && response.data) {\n                    // Adicionar cartas ao novo deck\n                    for (const cardItem of originalDeck.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            isSideboard: cardItem.category === \"sideboard\",\n                            isCommander: cardItem.category === \"commander\",\n                            category: cardItem.category\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setDecks((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                        return updatedResponse.data.id;\n                    }\n                }\n                return undefined;\n            } catch (error) {\n                console.error(\"Erro ao duplicar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const duplicatedDeck = {\n                ...originalDeck,\n                id: Date.now().toString(),\n                name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    duplicatedDeck\n                ]);\n            return duplicatedDeck.id;\n        }\n    };\n    // Adicionar carta ao deck\n    const adicionarCartaAoDeck = async function(deckId, card) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\", quantity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.addCard(deckId, {\n                    card,\n                    quantity,\n                    isSideboard: category === \"sideboard\",\n                    isCommander: category === \"commander\",\n                    category\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta ao deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        const existingCard = deck.cards.find((c)=>c.card.id === card.id && c.category === category);\n                        if (existingCard) {\n                            return {\n                                ...deck,\n                                cards: deck.cards.map((c)=>c.card.id === card.id && c.category === category ? {\n                                        ...c,\n                                        quantity: c.quantity + quantity\n                                    } : c),\n                                lastModified: new Date().toISOString()\n                            };\n                        } else {\n                            return {\n                                ...deck,\n                                cards: [\n                                    ...deck.cards,\n                                    {\n                                        card,\n                                        quantity,\n                                        category\n                                    }\n                                ],\n                                lastModified: new Date().toISOString()\n                            };\n                        }\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Remover carta do deck\n    const removerCartaDoDeck = async function(deckId, cardId) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\";\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.removeCard(deckId, cardInDeck._id);\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta do deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.filter((c)=>!(c.card.id === cardId && c.category === category)),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Atualizar quantidade de carta no deck\n    const atualizarQuantidadeNoDeck = async function(deckId, cardId, novaQuantidade) {\n        let category = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"mainboard\";\n        if (novaQuantidade <= 0) {\n            await removerCartaDoDeck(deckId, cardId, category);\n            return;\n        }\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.updateCard(deckId, cardInDeck._id, {\n                    quantity: novaQuantidade\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar quantidade no deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.map((c)=>c.card.id === cardId && c.category === category ? {\n                                    ...c,\n                                    quantity: novaQuantidade\n                                } : c),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Obter cartas que estão sendo usadas em decks\n    const getCartasUsadasEmDecks = (cardId)=>{\n        const result = [];\n        decks.forEach((deck)=>{\n            deck.cards.forEach((deckCard)=>{\n                if (deckCard.card.id === cardId) {\n                    result.push({\n                        deck,\n                        quantity: deckCard.quantity,\n                        category: deckCard.category\n                    });\n                }\n            });\n        });\n        return result;\n    };\n    // Função para importar deck a partir de uma lista de texto\n    const importarDeckDeLista = async (deckList, deckData)=>{\n        try {\n            // Criar o deck vazio primeiro\n            const deckId = await criarDeck({\n                name: deckData.name,\n                format: deckData.format,\n                description: deckData.description || \"\",\n                colors: deckData.colors || [],\n                cards: [],\n                isPublic: deckData.isPublic || false,\n                tags: deckData.tags || []\n            });\n            // Processar a lista de cartas\n            const lines = deckList.split(\"\\n\").filter((line)=>line.trim());\n            let currentSection = \"mainboard\";\n            const cardPromises = [];\n            for (const line of lines){\n                const trimmedLine = line.trim().toLowerCase();\n                // Verificar se é uma linha de seção\n                if (trimmedLine.includes(\"sideboard\")) {\n                    currentSection = \"sideboard\";\n                    continue;\n                }\n                if (trimmedLine.includes(\"commander\")) {\n                    currentSection = \"commander\";\n                    continue;\n                }\n                // Verificar se é uma linha de carta\n                const match = line.match(/^(\\d+)x?\\s+(.+)$/);\n                if (match) {\n                    const quantity = parseInt(match[1]);\n                    const cardName = match[2].trim();\n                    // Buscar a carta na API do Scryfall\n                    cardPromises.push((async ()=>{\n                        try {\n                            const response = await fetch(\"https://api.scryfall.com/cards/named?fuzzy=\".concat(encodeURIComponent(cardName)));\n                            if (response.ok) {\n                                const cardData = await response.json();\n                                // Adicionar a carta ao deck\n                                await adicionarCartaAoDeck(deckId, cardData, currentSection, quantity);\n                                return {\n                                    success: true,\n                                    card: cardName\n                                };\n                            } else {\n                                console.error(\"Carta n\\xe3o encontrada: \".concat(cardName));\n                                return {\n                                    success: false,\n                                    card: cardName\n                                };\n                            }\n                        } catch (error) {\n                            console.error(\"Erro ao buscar carta \".concat(cardName, \":\"), error);\n                            return {\n                                success: false,\n                                card: cardName\n                            };\n                        }\n                    })());\n                }\n            }\n            // Aguardar todas as cartas serem processadas\n            const results = await Promise.allSettled(cardPromises);\n            const failedCards = results.filter((result)=>result.status === \"fulfilled\" && !result.value.success).map((result)=>result.status === \"fulfilled\" ? result.value.card : \"Unknown\");\n            if (failedCards.length > 0) {\n                console.warn(\"Algumas cartas n\\xe3o foram encontradas: \".concat(failedCards.join(\", \")));\n            }\n            return deckId;\n        } catch (error) {\n            console.error(\"Erro ao importar deck:\", error);\n            throw new Error(\"Falha ao importar deck. Verifique o formato da lista.\");\n        }\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE FAVORITOS ======\n    // Adicionar carta aos favoritos\n    const addFavorite = async (card)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.add(card);\n                if (response.success) {\n                    setFavorites((prev)=>[\n                            ...prev,\n                            card\n                        ]);\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>{\n                if (prev.some((c)=>c.id === card.id)) return prev;\n                return [\n                    ...prev,\n                    card\n                ];\n            });\n        }\n    };\n    // Remover carta dos favoritos\n    const removeFavorite = async (cardId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_2__.favoriteService.removeCard(cardId);\n                if (response.success) {\n                    setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n        }\n    };\n    // Verificar se uma carta está nos favoritos\n    const isFavorite = (cardId)=>{\n        return favorites.some((card)=>card.id === cardId);\n    };\n    // Função para exportar coleção para CSV no formato Manabox\n    const exportCollectionToCSV = (collection)=>{\n        // Formato Manabox: Name,Set,Quantity,Foil,Condition,Language\n        const csvContent = [\n            [\n                \"Name\",\n                \"Set\",\n                \"Quantity\",\n                \"Foil\",\n                \"Condition\",\n                \"Language\"\n            ],\n            ...collection.cards.map((c)=>[\n                    c.card.name,\n                    c.card.set_code,\n                    c.quantity.toString(),\n                    c.foil ? \"Foil\" : \"Non-foil\",\n                    c.condition || \"Near Mint\",\n                    c.language || \"English\"\n                ])\n        ].map((row)=>row.join(\",\")).join(\"\\n\");\n        const blob = new Blob([\n            csvContent\n        ], {\n            type: \"text/csv\"\n        });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"\".concat(collection.name, \"_manabox.csv\");\n        a.click();\n        window.URL.revokeObjectURL(url);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: {\n            collections,\n            currentCollection,\n            setCurrentCollection: setCollections,\n            currentCollectionId,\n            setCurrentCollectionId,\n            createCollection,\n            updateCollection,\n            deleteCollection,\n            duplicateCollection,\n            adicionarCarta,\n            removerCarta,\n            getQuantidadeNaColecao,\n            decks,\n            setDecks,\n            criarDeck,\n            editarDeck,\n            deletarDeck,\n            duplicarDeck,\n            adicionarCartaAoDeck,\n            removerCartaDoDeck,\n            atualizarQuantidadeNoDeck,\n            getCartasUsadasEmDecks,\n            importarDeckDeLista,\n            favorites,\n            addFavorite,\n            removeFavorite,\n            isFavorite,\n            loading,\n            exportCollectionToCSV\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Rodrigo\\\\Downloads\\\\MTG HELP\\\\contexts\\\\AppContext.tsx\",\n        lineNumber: 852,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(AppProvider, \"P5slHoOyqMDp2BOUreOP8tfxRtM=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession\n    ];\n});\n_c = AppProvider;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL0FwcENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFeUY7QUFFSjtBQUN4QztBQTBDN0MsTUFBTVMsMkJBQWFSLG9EQUFhQSxDQUF3QjtBQUVqRCxNQUFNUyxnQkFBZ0I7O0lBQzNCLE1BQU1DLFVBQVVULGlEQUFVQSxDQUFDTztJQUMzQixJQUFJLENBQUNFLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNULEVBQUU7R0FOV0Q7QUFZTixNQUFNRyxjQUEwQztRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDbEUsTUFBTSxFQUFFQyxNQUFNQyxPQUFPLEVBQUUsR0FBR1IsMkRBQVVBO0lBQ3BDLE1BQU0sQ0FBQ1MsYUFBYUMsZUFBZSxHQUFHZiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUNuRSxNQUFNLENBQUNnQixxQkFBcUJDLHVCQUF1QixHQUFHakIsK0NBQVFBLENBQWdCO0lBQzlFLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDb0IsV0FBV0MsYUFBYSxHQUFHckIsK0NBQVFBLENBQVksRUFBRTtJQUN4RCxNQUFNLENBQUNzQixTQUFTQyxXQUFXLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUV2QyxNQUFNd0Isb0JBQW9CM0Isb0RBQWEsQ0FBQztRQUN0QyxPQUFPaUIsWUFBWVksSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaO0lBQ3hDLEdBQUc7UUFBQ0Y7UUFBYUU7S0FBb0I7SUFFckMsNkRBQTZEO0lBQzdEZixnREFBU0EsQ0FBQztRQUNSLE1BQU00QixXQUFXO1lBQ2YsSUFBSWhCLFNBQVM7Z0JBQ1hVLFdBQVc7Z0JBQ1gsSUFBSTtvQkFDRixvQkFBb0I7b0JBQ3BCLE1BQU1PLHNCQUFzQixNQUFNNUIsZ0VBQWlCQSxDQUFDNkIsTUFBTTtvQkFDMUQsSUFBSUQsb0JBQW9CRSxPQUFPLElBQUlGLG9CQUFvQmxCLElBQUksRUFBRTt3QkFDM0RHLGVBQWVlLG9CQUFvQmxCLElBQUk7d0JBQ3ZDLElBQUlrQixvQkFBb0JsQixJQUFJLENBQUNxQixNQUFNLEdBQUcsS0FBSyxDQUFDakIscUJBQXFCOzRCQUMvREMsdUJBQXVCYSxvQkFBb0JsQixJQUFJLENBQUMsRUFBRSxDQUFDZ0IsRUFBRTt3QkFDdkQ7b0JBQ0Y7b0JBRUEsaUJBQWlCO29CQUNqQixNQUFNTSxnQkFBZ0IsTUFBTS9CLDBEQUFXQSxDQUFDNEIsTUFBTTtvQkFDOUMsSUFBSUcsY0FBY0YsT0FBTyxJQUFJRSxjQUFjdEIsSUFBSSxFQUFFO3dCQUMvQ08sU0FBU2UsY0FBY3RCLElBQUk7b0JBQzdCO29CQUVBLHFCQUFxQjtvQkFDckIsTUFBTXVCLG9CQUFvQixNQUFNL0IsOERBQWVBLENBQUMyQixNQUFNO29CQUN0RCxJQUFJSSxrQkFBa0JILE9BQU8sSUFBSUcsa0JBQWtCdkIsSUFBSSxFQUFFO3dCQUN2RFMsYUFBYWMsa0JBQWtCdkIsSUFBSSxDQUFDd0IsR0FBRyxDQUFDLENBQUNDLE1BQWFBLElBQUlDLElBQUk7b0JBQ2hFO2dCQUNGLEVBQUUsT0FBT0MsT0FBTztvQkFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7Z0JBQzNDLFNBQVU7b0JBQ1JoQixXQUFXO2dCQUNiO1lBQ0YsT0FBTztnQkFDTCwyREFBMkQ7Z0JBQzNELE1BQU1rQixtQkFBbUJDLGFBQWFDLE9BQU8sQ0FBQztnQkFDOUMsSUFBSUYsa0JBQWtCO29CQUNwQixJQUFJO3dCQUNGLE1BQU1HLG9CQUFvQkMsS0FBS0MsS0FBSyxDQUFDTDt3QkFDckMxQixlQUFlNkI7d0JBQ2YsSUFBSUEsa0JBQWtCWCxNQUFNLEdBQUcsS0FBSyxDQUFDakIscUJBQXFCOzRCQUN4REMsdUJBQXVCMkIsaUJBQWlCLENBQUMsRUFBRSxDQUFDaEIsRUFBRTt3QkFDaEQ7b0JBQ0YsRUFBRSxPQUFPVyxPQUFPO3dCQUNkQyxRQUFRRCxLQUFLLENBQUMsMkNBQXFDQTtvQkFDckQ7Z0JBQ0YsT0FBTztvQkFDTCxpREFBaUQ7b0JBQ2pELE1BQU1RLG9CQUFvQzt3QkFDeENuQixJQUFJO3dCQUNKb0IsTUFBTTt3QkFDTkMsYUFBYTt3QkFDYkMsT0FBTyxFQUFFO3dCQUNUQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7d0JBQ2pDQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7d0JBQ2pDRSxVQUFVO29CQUNaO29CQUNBeEMsZUFBZTt3QkFBQ2dDO3FCQUFrQjtvQkFDbEM5Qix1QkFBdUI4QixrQkFBa0JuQixFQUFFO2dCQUM3QztnQkFFQSxNQUFNNEIsYUFBYWQsYUFBYUMsT0FBTyxDQUFDO2dCQUN4QyxJQUFJYSxZQUFZO29CQUNkLElBQUk7d0JBQ0YsTUFBTUMsY0FBY1osS0FBS0MsS0FBSyxDQUFDVTt3QkFDL0JyQyxTQUFTc0M7b0JBQ1gsRUFBRSxPQUFPbEIsT0FBTzt3QkFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7b0JBQ2xEO2dCQUNGO2dCQUVBLE1BQU1tQixpQkFBaUJoQixhQUFhQyxPQUFPLENBQUM7Z0JBQzVDLElBQUllLGdCQUFnQjtvQkFDbEIsSUFBSTt3QkFDRixNQUFNQyxrQkFBa0JkLEtBQUtDLEtBQUssQ0FBQ1k7d0JBQ25DckMsYUFBYXNDO29CQUNmLEVBQUUsT0FBT3BCLE9BQU87d0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxzQ0FBc0NBO29CQUN0RDtnQkFDRjtnQkFFQWhCLFdBQVc7WUFDYjtRQUNGO1FBRUFNO0lBQ0YsR0FBRztRQUFDaEI7S0FBUTtJQUVaLDhEQUE4RDtJQUM5RFosZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNZLFNBQVM7WUFDWjZCLGFBQWFrQixPQUFPLENBQUMsbUJBQW1CZixLQUFLZ0IsU0FBUyxDQUFDL0M7UUFDekQ7SUFDRixHQUFHO1FBQUNBO1FBQWFEO0tBQVE7SUFFekJaLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDWSxTQUFTO1lBQ1o2QixhQUFha0IsT0FBTyxDQUFDLGFBQWFmLEtBQUtnQixTQUFTLENBQUMzQztRQUNuRDtJQUNGLEdBQUc7UUFBQ0E7UUFBT0w7S0FBUTtJQUVuQlosZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNZLFNBQVM7WUFDWjZCLGFBQWFrQixPQUFPLENBQUMsaUJBQWlCZixLQUFLZ0IsU0FBUyxDQUFDekM7UUFDdkQ7SUFDRixHQUFHO1FBQUNBO1FBQVdQO0tBQVE7SUFFdkIsc0NBQXNDO0lBQ3RDLE1BQU1pRCxtQkFBbUIsZUFBT2Q7WUFBY0MsK0VBQXNCO1FBQ2xFLElBQUlwQyxTQUFTO1lBQ1gsSUFBSTtnQkFDRixNQUFNa0QsV0FBVyxNQUFNN0QsZ0VBQWlCQSxDQUFDOEQsTUFBTSxDQUFDO29CQUFFaEI7b0JBQU1DO2dCQUFZO2dCQUNwRSxJQUFJYyxTQUFTL0IsT0FBTyxJQUFJK0IsU0FBU25ELElBQUksRUFBRTtvQkFDckNHLGVBQWVrRCxDQUFBQSxPQUFROytCQUFJQTs0QkFBTUYsU0FBU25ELElBQUk7eUJBQUM7b0JBQy9DSyx1QkFBdUI4QyxTQUFTbkQsSUFBSSxDQUFDZ0IsRUFBRTtvQkFDdkMsT0FBT21DLFNBQVNuRCxJQUFJLENBQUNnQixFQUFFO2dCQUN6QjtnQkFDQSxNQUFNLElBQUluQixNQUFNO1lBQ2xCLEVBQUUsT0FBTzhCLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxnQ0FBMEJBO2dCQUN4QyxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLDZCQUE2QjtZQUM3QixNQUFNMkIsZ0JBQWdDO2dCQUNwQ3RDLElBQUl3QixLQUFLZSxHQUFHLEdBQUdDLFFBQVE7Z0JBQ3ZCcEI7Z0JBQ0FDO2dCQUNBQyxPQUFPLEVBQUU7Z0JBQ1RDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztnQkFDakNDLFdBQVcsSUFBSUYsT0FBT0MsV0FBVztnQkFDakNFLFVBQVU7WUFDWjtZQUNBeEMsZUFBZWtELENBQUFBLE9BQVE7dUJBQUlBO29CQUFNQztpQkFBYztZQUMvQ2pELHVCQUF1QmlELGNBQWN0QyxFQUFFO1lBQ3ZDLE9BQU9zQyxjQUFjdEMsRUFBRTtRQUN6QjtJQUNGO0lBRUEsTUFBTXlDLG1CQUFtQixPQUFPekMsSUFBWTBDO1FBQzFDLElBQUl6RCxTQUFTO1lBQ1gsSUFBSTtnQkFDRixNQUFNa0QsV0FBVyxNQUFNN0QsZ0VBQWlCQSxDQUFDcUUsTUFBTSxDQUFDM0MsSUFBSTBDO2dCQUNwRCxJQUFJUCxTQUFTL0IsT0FBTyxFQUFFO29CQUNwQmpCLGVBQWVrRCxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDVCxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtBLEtBQUs7Z0NBQUUsR0FBR0QsQ0FBQztnQ0FBRSxHQUFHMkMsT0FBTzs0QkFBQyxJQUFJM0M7Z0JBQzVFO1lBQ0YsRUFBRSxPQUFPWSxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQThCQTtnQkFDNUMsTUFBTUE7WUFDUjtRQUNGLE9BQU87WUFDTCw2QkFBNkI7WUFDN0J4QixlQUFla0QsQ0FBQUEsT0FBUUEsS0FBSzdCLEdBQUcsQ0FBQ1QsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLQSxLQUFLO3dCQUFFLEdBQUdELENBQUM7d0JBQUUsR0FBRzJDLE9BQU87d0JBQUVoQixXQUFXLElBQUlGLE9BQU9DLFdBQVc7b0JBQUcsSUFBSTFCO1FBQ2pIO0lBQ0Y7SUFFQSxNQUFNNkMsbUJBQW1CLE9BQU81QztRQUM5QixJQUFJZixTQUFTO1lBQ1gsSUFBSTtnQkFDRixNQUFNa0QsV0FBVyxNQUFNN0QsZ0VBQWlCQSxDQUFDdUUsTUFBTSxDQUFDN0M7Z0JBQ2hELElBQUltQyxTQUFTL0IsT0FBTyxFQUFFO29CQUNwQmpCLGVBQWVrRCxDQUFBQTt3QkFDYixNQUFNUyxpQkFBaUJULEtBQUtVLE1BQU0sQ0FBQ2hELENBQUFBLElBQUtBLEVBQUVDLEVBQUUsS0FBS0E7d0JBQ2pELElBQUlaLHdCQUF3QlksSUFBSTs0QkFDOUJYLHVCQUF1QnlELGVBQWV6QyxNQUFNLEdBQUcsSUFBSXlDLGNBQWMsQ0FBQyxFQUFFLENBQUM5QyxFQUFFLEdBQUc7d0JBQzVFO3dCQUNBLE9BQU84QztvQkFDVDtnQkFDRjtZQUNGLEVBQUUsT0FBT25DLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxrQ0FBNEJBO2dCQUMxQyxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLDZCQUE2QjtZQUM3QnhCLGVBQWVrRCxDQUFBQTtnQkFDYixNQUFNUyxpQkFBaUJULEtBQUtVLE1BQU0sQ0FBQ2hELENBQUFBLElBQUtBLEVBQUVDLEVBQUUsS0FBS0E7Z0JBQ2pELElBQUlaLHdCQUF3QlksSUFBSTtvQkFDOUJYLHVCQUF1QnlELGVBQWV6QyxNQUFNLEdBQUcsSUFBSXlDLGNBQWMsQ0FBQyxFQUFFLENBQUM5QyxFQUFFLEdBQUc7Z0JBQzVFO2dCQUNBLE9BQU84QztZQUNUO1FBQ0Y7SUFDRjtJQUVBLE1BQU1FLHNCQUFzQixPQUFPaEQ7UUFDakMsTUFBTWlELHdCQUF3Qi9ELFlBQVlZLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLQTtRQUM3RCxJQUFJLENBQUNpRCx1QkFBdUI7UUFFNUIsSUFBSWhFLFNBQVM7WUFDWCxJQUFJO2dCQUNGLE1BQU1xRCxnQkFBZ0I7b0JBQ3BCbEIsTUFBTSxHQUE4QixPQUEzQjZCLHNCQUFzQjdCLElBQUksRUFBQztvQkFDcENDLGFBQWE0QixzQkFBc0I1QixXQUFXO29CQUM5Q00sVUFBVTtnQkFDWjtnQkFFQSxNQUFNUSxXQUFXLE1BQU03RCxnRUFBaUJBLENBQUM4RCxNQUFNLENBQUNFO2dCQUNoRCxJQUFJSCxTQUFTL0IsT0FBTyxJQUFJK0IsU0FBU25ELElBQUksRUFBRTtvQkFDckMsa0NBQWtDO29CQUNsQyxLQUFLLE1BQU1rRSxZQUFZRCxzQkFBc0IzQixLQUFLLENBQUU7d0JBQ2xELE1BQU1oRCxnRUFBaUJBLENBQUM2RSxPQUFPLENBQUNoQixTQUFTbkQsSUFBSSxDQUFDZ0IsRUFBRSxFQUFFOzRCQUNoRFUsTUFBTXdDLFNBQVN4QyxJQUFJOzRCQUNuQjBDLFVBQVVGLFNBQVNFLFFBQVE7NEJBQzNCQyxXQUFXSCxTQUFTRyxTQUFTOzRCQUM3QkMsTUFBTUosU0FBU0ksSUFBSTs0QkFDbkJDLFVBQVVMLFNBQVNLLFFBQVE7d0JBQzdCO29CQUNGO29CQUVBLHlCQUF5QjtvQkFDekIsTUFBTUMsa0JBQWtCLE1BQU1sRixnRUFBaUJBLENBQUNtRixPQUFPLENBQUN0QixTQUFTbkQsSUFBSSxDQUFDZ0IsRUFBRTtvQkFDeEUsSUFBSXdELGdCQUFnQnBELE9BQU8sRUFBRTt3QkFDM0JqQixlQUFla0QsQ0FBQUEsT0FBUTttQ0FBSUE7Z0NBQU1tQixnQkFBZ0J4RSxJQUFJOzZCQUFDO29CQUN4RDtnQkFDRjtZQUNGLEVBQUUsT0FBTzJCLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxtQ0FBNkJBO2dCQUMzQyxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLDZCQUE2QjtZQUM3QixNQUFNMkIsZ0JBQWdDO2dCQUNwQyxHQUFHVyxxQkFBcUI7Z0JBQ3hCakQsSUFBSXdCLEtBQUtlLEdBQUcsR0FBR0MsUUFBUTtnQkFDdkJwQixNQUFNLEdBQThCLE9BQTNCNkIsc0JBQXNCN0IsSUFBSSxFQUFDO1lBQ3RDO1lBQ0FqQyxlQUFla0QsQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU1DO2lCQUFjO1FBQ2pEO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsTUFBTW9CLGlCQUFpQixlQUFPaEQ7WUFBZWlELDhFQUFxQjtRQUNoRSxJQUFJLENBQUN2RSxxQkFBcUI7UUFFMUIsSUFBSUgsU0FBUztZQUNYLElBQUk7Z0JBQ0YsTUFBTVgsZ0VBQWlCQSxDQUFDNkUsT0FBTyxDQUFDL0QscUJBQXFCO29CQUNuRHNCO29CQUNBMEMsVUFBVU87b0JBQ1ZOLFdBQVc7b0JBQ1hDLE1BQU07b0JBQ05DLFVBQVU7Z0JBQ1o7Z0JBRUEseUJBQXlCO2dCQUN6QixNQUFNcEIsV0FBVyxNQUFNN0QsZ0VBQWlCQSxDQUFDbUYsT0FBTyxDQUFDckU7Z0JBQ2pELElBQUkrQyxTQUFTL0IsT0FBTyxFQUFFO29CQUNwQmpCLGVBQWVrRCxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDVCxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaLHNCQUFzQitDLFNBQVNuRCxJQUFJLEdBQUdlO2dCQUN0RjtZQUNGLEVBQUUsT0FBT1ksT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7Z0JBQzFDLE1BQU1BO1lBQ1I7UUFDRixPQUFPO1lBQ0wsNkJBQTZCO1lBQzdCeEIsZUFBZWtELENBQUFBLE9BQVFBLEtBQUs3QixHQUFHLENBQUNULENBQUFBO29CQUM5QixJQUFJQSxFQUFFQyxFQUFFLEtBQUtaLHFCQUFxQixPQUFPVztvQkFFekMsTUFBTTZELGVBQWU3RCxFQUFFdUIsS0FBSyxDQUFDeEIsSUFBSSxDQUFDK0QsQ0FBQUEsS0FBTUEsR0FBR25ELElBQUksQ0FBQ1YsRUFBRSxLQUFLVSxLQUFLVixFQUFFO29CQUM5RCxJQUFJOEQ7b0JBQ0osSUFBSUYsY0FBYzt3QkFDaEJFLFdBQVcvRCxFQUFFdUIsS0FBSyxDQUFDZCxHQUFHLENBQUNxRCxDQUFBQSxLQUNyQkEsR0FBR25ELElBQUksQ0FBQ1YsRUFBRSxLQUFLVSxLQUFLVixFQUFFLEdBQ2xCO2dDQUFFLEdBQUc2RCxFQUFFO2dDQUFFVCxVQUFVUyxHQUFHVCxRQUFRLEdBQUdPOzRCQUFXLElBQzVDRTtvQkFFUixPQUFPO3dCQUNMQyxXQUFXOytCQUFJL0QsRUFBRXVCLEtBQUs7NEJBQUU7Z0NBQ3RCWjtnQ0FDQTBDLFVBQVVPO2dDQUNWTixXQUFXO2dDQUNYQyxNQUFNOzRCQUNSO3lCQUFFO29CQUNKO29CQUNBLE9BQU87d0JBQUUsR0FBR3ZELENBQUM7d0JBQUV1QixPQUFPd0M7d0JBQVVwQyxXQUFXLElBQUlGLE9BQU9DLFdBQVc7b0JBQUc7Z0JBQ3RFO1FBQ0Y7SUFDRjtJQUVBLHVDQUF1QztJQUN2QyxNQUFNc0MsZUFBZSxPQUFPckQ7UUFDMUIsSUFBSSxDQUFDdEIscUJBQXFCO1FBRTFCLElBQUlILFNBQVM7WUFDWCxJQUFJO2dCQUNGLHFDQUFxQztnQkFDckMsTUFBTStFLGFBQWE5RSxZQUFZWSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEVBQUUsS0FBS1o7Z0JBQ2xELElBQUksQ0FBQzRFLFlBQVk7Z0JBRWpCLE1BQU1DLG1CQUFtQkQsV0FBVzFDLEtBQUssQ0FBQ3hCLElBQUksQ0FBQytELENBQUFBLEtBQU1BLEdBQUduRCxJQUFJLENBQUNWLEVBQUUsS0FBS1UsS0FBS1YsRUFBRTtnQkFDM0UsSUFBSSxDQUFDaUUsa0JBQWtCO2dCQUV2QixJQUFJQSxpQkFBaUJiLFFBQVEsR0FBRyxHQUFHO29CQUNqQyx1QkFBdUI7b0JBQ3ZCLE1BQU05RSxnRUFBaUJBLENBQUM0RixVQUFVLENBQUM5RSxxQkFBcUI2RSxpQkFBaUJFLEdBQUcsRUFBRTt3QkFDNUVmLFVBQVVhLGlCQUFpQmIsUUFBUSxHQUFHO29CQUN4QztnQkFDRixPQUFPO29CQUNMLGdCQUFnQjtvQkFDaEIsTUFBTTlFLGdFQUFpQkEsQ0FBQzhGLFVBQVUsQ0FBQ2hGLHFCQUFxQjZFLGlCQUFpQkUsR0FBRztnQkFDOUU7Z0JBRUEseUJBQXlCO2dCQUN6QixNQUFNaEMsV0FBVyxNQUFNN0QsZ0VBQWlCQSxDQUFDbUYsT0FBTyxDQUFDckU7Z0JBQ2pELElBQUkrQyxTQUFTL0IsT0FBTyxFQUFFO29CQUNwQmpCLGVBQWVrRCxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDVCxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaLHNCQUFzQitDLFNBQVNuRCxJQUFJLEdBQUdlO2dCQUN0RjtZQUNGLEVBQUUsT0FBT1ksT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7Z0JBQ3hDLE1BQU1BO1lBQ1I7UUFDRixPQUFPO1lBQ0wsNkJBQTZCO1lBQzdCeEIsZUFBZWtELENBQUFBLE9BQVFBLEtBQUs3QixHQUFHLENBQUNULENBQUFBO29CQUM5QixJQUFJQSxFQUFFQyxFQUFFLEtBQUtaLHFCQUFxQixPQUFPVztvQkFFekMsTUFBTTZELGVBQWU3RCxFQUFFdUIsS0FBSyxDQUFDeEIsSUFBSSxDQUFDK0QsQ0FBQUEsS0FBTUEsR0FBR25ELElBQUksQ0FBQ1YsRUFBRSxLQUFLVSxLQUFLVixFQUFFO29CQUM5RCxJQUFJOEQ7b0JBQ0osSUFBSUYsZ0JBQWdCQSxhQUFhUixRQUFRLEdBQUcsR0FBRzt3QkFDN0NVLFdBQVcvRCxFQUFFdUIsS0FBSyxDQUFDZCxHQUFHLENBQUNxRCxDQUFBQSxLQUNyQkEsR0FBR25ELElBQUksQ0FBQ1YsRUFBRSxLQUFLVSxLQUFLVixFQUFFLEdBQ2xCO2dDQUFFLEdBQUc2RCxFQUFFO2dDQUFFVCxVQUFVUyxHQUFHVCxRQUFRLEdBQUc7NEJBQUUsSUFDbkNTO29CQUVSLE9BQU87d0JBQ0xDLFdBQVcvRCxFQUFFdUIsS0FBSyxDQUFDeUIsTUFBTSxDQUFDYyxDQUFBQSxLQUFNQSxHQUFHbkQsSUFBSSxDQUFDVixFQUFFLEtBQUtVLEtBQUtWLEVBQUU7b0JBQ3hEO29CQUNBLE9BQU87d0JBQUUsR0FBR0QsQ0FBQzt3QkFBRXVCLE9BQU93Qzt3QkFBVXBDLFdBQVcsSUFBSUYsT0FBT0MsV0FBVztvQkFBRztnQkFDdEU7UUFDRjtJQUNGO0lBRUEsdURBQXVEO0lBQ3ZELE1BQU00Qyx5QkFBeUIsQ0FBQ0M7WUFDakIxRTtRQUFiLE1BQU1jLE9BQU9kLDhCQUFBQSx5Q0FBQUEsMkJBQUFBLGtCQUFtQjBCLEtBQUssY0FBeEIxQiwrQ0FBQUEseUJBQTBCRSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVXLElBQUksQ0FBQ1YsRUFBRSxLQUFLc0U7UUFDL0QsT0FBTzVELE9BQU9BLEtBQUswQyxRQUFRLEdBQUc7SUFDaEM7SUFFQSxrREFBa0Q7SUFFbEQsa0JBQWtCO0lBQ2xCLE1BQU1tQixZQUFZLE9BQU9DO1FBQ3ZCLElBQUl2RixTQUFTO1lBQ1gsSUFBSTtnQkFDRixNQUFNa0QsV0FBVyxNQUFNNUQsMERBQVdBLENBQUM2RCxNQUFNLENBQUNvQztnQkFDMUMsSUFBSXJDLFNBQVMvQixPQUFPLElBQUkrQixTQUFTbkQsSUFBSSxFQUFFO29CQUNyQ08sU0FBUzhDLENBQUFBLE9BQVE7K0JBQUlBOzRCQUFNRixTQUFTbkQsSUFBSTt5QkFBQztvQkFDekMsT0FBT21ELFNBQVNuRCxJQUFJLENBQUNnQixFQUFFO2dCQUN6QjtnQkFDQSxNQUFNLElBQUluQixNQUFNO1lBQ2xCLEVBQUUsT0FBTzhCLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyx1QkFBdUJBO2dCQUNyQyxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLDZCQUE2QjtZQUM3QixNQUFNOEQsVUFBZ0I7Z0JBQ3BCLEdBQUdELFFBQVE7Z0JBQ1h4RSxJQUFJd0IsS0FBS2UsR0FBRyxHQUFHQyxRQUFRO2dCQUN2QmpCLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztnQkFDakNpRCxjQUFjLElBQUlsRCxPQUFPQyxXQUFXO1lBQ3RDO1lBQ0FsQyxTQUFTOEMsQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU1vQztpQkFBUTtZQUNuQyxPQUFPQSxRQUFRekUsRUFBRTtRQUNuQjtJQUNGO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU0yRSxhQUFhLE9BQU9DLFFBQWdCbEM7UUFDeEMsSUFBSXpELFNBQVM7WUFDWCxJQUFJO2dCQUNGLE1BQU1rRCxXQUFXLE1BQU01RCwwREFBV0EsQ0FBQ29FLE1BQU0sQ0FBQ2lDLFFBQVFsQztnQkFDbEQsSUFBSVAsU0FBUy9CLE9BQU8sRUFBRTtvQkFDcEJiLFNBQVM4QyxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDcUUsQ0FBQUEsT0FDeEJBLEtBQUs3RSxFQUFFLEtBQUs0RSxTQUNSO2dDQUFFLEdBQUdDLElBQUk7Z0NBQUUsR0FBR25DLE9BQU87NEJBQUMsSUFDdEJtQztnQkFFUjtZQUNGLEVBQUUsT0FBT2xFLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyx3QkFBd0JBO2dCQUN0QyxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLDZCQUE2QjtZQUM3QnBCLFNBQVM4QyxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDcUUsQ0FBQUEsT0FDeEJBLEtBQUs3RSxFQUFFLEtBQUs0RSxTQUNSO3dCQUFFLEdBQUdDLElBQUk7d0JBQUUsR0FBR25DLE9BQU87d0JBQUVnQyxjQUFjLElBQUlsRCxPQUFPQyxXQUFXO29CQUFHLElBQzlEb0Q7UUFFUjtJQUNGO0lBRUEsZUFBZTtJQUNmLE1BQU1DLGNBQWMsT0FBT0Y7UUFDekIsSUFBSTNGLFNBQVM7WUFDWCxJQUFJO2dCQUNGLE1BQU1rRCxXQUFXLE1BQU01RCwwREFBV0EsQ0FBQ3NFLE1BQU0sQ0FBQytCO2dCQUMxQyxJQUFJekMsU0FBUy9CLE9BQU8sRUFBRTtvQkFDcEJiLFNBQVM4QyxDQUFBQSxPQUFRQSxLQUFLVSxNQUFNLENBQUM4QixDQUFBQSxPQUFRQSxLQUFLN0UsRUFBRSxLQUFLNEU7Z0JBQ25EO1lBQ0YsRUFBRSxPQUFPakUsT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7Z0JBQ3ZDLE1BQU1BO1lBQ1I7UUFDRixPQUFPO1lBQ0wsNkJBQTZCO1lBQzdCcEIsU0FBUzhDLENBQUFBLE9BQVFBLEtBQUtVLE1BQU0sQ0FBQzhCLENBQUFBLE9BQVFBLEtBQUs3RSxFQUFFLEtBQUs0RTtRQUNuRDtJQUNGO0lBRUEsZ0JBQWdCO0lBQ2hCLE1BQU1HLGVBQWUsT0FBT0gsUUFBZ0JJO1FBQzFDLE1BQU1DLGVBQWUzRixNQUFNUSxJQUFJLENBQUMrRSxDQUFBQSxPQUFRQSxLQUFLN0UsRUFBRSxLQUFLNEU7UUFDcEQsSUFBSSxDQUFDSyxjQUFjLE9BQU9DO1FBRTFCLElBQUlqRyxTQUFTO1lBQ1gsSUFBSTtnQkFDRixNQUFNa0csY0FBYztvQkFDbEIvRCxNQUFNNEQsV0FBVyxHQUFxQixPQUFsQkMsYUFBYTdELElBQUksRUFBQztvQkFDdENDLGFBQWE0RCxhQUFhNUQsV0FBVztvQkFDckMrRCxRQUFRSCxhQUFhRyxNQUFNO29CQUMzQkMsUUFBUUosYUFBYUksTUFBTTtvQkFDM0IxRCxVQUFVO2dCQUNaO2dCQUVBLE1BQU1RLFdBQVcsTUFBTTVELDBEQUFXQSxDQUFDNkQsTUFBTSxDQUFDK0M7Z0JBQzFDLElBQUloRCxTQUFTL0IsT0FBTyxJQUFJK0IsU0FBU25ELElBQUksRUFBRTtvQkFDckMsZ0NBQWdDO29CQUNoQyxLQUFLLE1BQU1rRSxZQUFZK0IsYUFBYTNELEtBQUssQ0FBRTt3QkFDekMsTUFBTS9DLDBEQUFXQSxDQUFDNEUsT0FBTyxDQUFDaEIsU0FBU25ELElBQUksQ0FBQ2dCLEVBQUUsRUFBRTs0QkFDMUNVLE1BQU13QyxTQUFTeEMsSUFBSTs0QkFDbkIwQyxVQUFVRixTQUFTRSxRQUFROzRCQUMzQmtDLGFBQWFwQyxTQUFTcUMsUUFBUSxLQUFLOzRCQUNuQ0MsYUFBYXRDLFNBQVNxQyxRQUFRLEtBQUs7NEJBQ25DQSxVQUFVckMsU0FBU3FDLFFBQVE7d0JBQzdCO29CQUNGO29CQUVBLHlCQUF5QjtvQkFDekIsTUFBTS9CLGtCQUFrQixNQUFNakYsMERBQVdBLENBQUNrRixPQUFPLENBQUN0QixTQUFTbkQsSUFBSSxDQUFDZ0IsRUFBRTtvQkFDbEUsSUFBSXdELGdCQUFnQnBELE9BQU8sRUFBRTt3QkFDM0JiLFNBQVM4QyxDQUFBQSxPQUFRO21DQUFJQTtnQ0FBTW1CLGdCQUFnQnhFLElBQUk7NkJBQUM7d0JBQ2hELE9BQU93RSxnQkFBZ0J4RSxJQUFJLENBQUNnQixFQUFFO29CQUNoQztnQkFDRjtnQkFDQSxPQUFPa0Y7WUFDVCxFQUFFLE9BQU92RSxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsMEJBQTBCQTtnQkFDeEMsTUFBTUE7WUFDUjtRQUNGLE9BQU87WUFDTCw2QkFBNkI7WUFDN0IsTUFBTThFLGlCQUF1QjtnQkFDM0IsR0FBR1IsWUFBWTtnQkFDZmpGLElBQUl3QixLQUFLZSxHQUFHLEdBQUdDLFFBQVE7Z0JBQ3ZCcEIsTUFBTTRELFdBQVcsR0FBcUIsT0FBbEJDLGFBQWE3RCxJQUFJLEVBQUM7Z0JBQ3RDRyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7Z0JBQ2pDaUQsY0FBYyxJQUFJbEQsT0FBT0MsV0FBVztZQUN0QztZQUNBbEMsU0FBUzhDLENBQUFBLE9BQVE7dUJBQUlBO29CQUFNb0Q7aUJBQWU7WUFDMUMsT0FBT0EsZUFBZXpGLEVBQUU7UUFDMUI7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNMEYsdUJBQXVCLGVBQzNCZCxRQUNBbEU7WUFDQTZFLDRFQUFvRCxhQUNwRG5DLDRFQUFtQjtRQUVuQixJQUFJbkUsU0FBUztZQUNYLElBQUk7Z0JBQ0YsTUFBTVYsMERBQVdBLENBQUM0RSxPQUFPLENBQUN5QixRQUFRO29CQUNoQ2xFO29CQUNBMEM7b0JBQ0FrQyxhQUFhQyxhQUFhO29CQUMxQkMsYUFBYUQsYUFBYTtvQkFDMUJBO2dCQUNGO2dCQUVBLHlCQUF5QjtnQkFDekIsTUFBTXBELFdBQVcsTUFBTTVELDBEQUFXQSxDQUFDa0YsT0FBTyxDQUFDbUI7Z0JBQzNDLElBQUl6QyxTQUFTL0IsT0FBTyxFQUFFO29CQUNwQmIsU0FBUzhDLENBQUFBLE9BQVFBLEtBQUs3QixHQUFHLENBQUNxRSxDQUFBQSxPQUFRQSxLQUFLN0UsRUFBRSxLQUFLNEUsU0FBU3pDLFNBQVNuRCxJQUFJLEdBQUc2RjtnQkFDekU7WUFDRixFQUFFLE9BQU9sRSxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQW9DQTtnQkFDbEQsTUFBTUE7WUFDUjtRQUNGLE9BQU87WUFDTCw2QkFBNkI7WUFDN0JwQixTQUFTOEMsQ0FBQUEsT0FBUUEsS0FBSzdCLEdBQUcsQ0FBQ3FFLENBQUFBO29CQUN4QixJQUFJQSxLQUFLN0UsRUFBRSxLQUFLNEUsUUFBUTt3QkFDdEIsTUFBTWhCLGVBQWVpQixLQUFLdkQsS0FBSyxDQUFDeEIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFVyxJQUFJLENBQUNWLEVBQUUsS0FBS1UsS0FBS1YsRUFBRSxJQUFJRCxFQUFFd0YsUUFBUSxLQUFLQTt3QkFDbEYsSUFBSTNCLGNBQWM7NEJBQ2hCLE9BQU87Z0NBQ0wsR0FBR2lCLElBQUk7Z0NBQ1B2RCxPQUFPdUQsS0FBS3ZELEtBQUssQ0FBQ2QsR0FBRyxDQUFDVCxDQUFBQSxJQUNwQkEsRUFBRVcsSUFBSSxDQUFDVixFQUFFLEtBQUtVLEtBQUtWLEVBQUUsSUFBSUQsRUFBRXdGLFFBQVEsS0FBS0EsV0FDcEM7d0NBQUUsR0FBR3hGLENBQUM7d0NBQUVxRCxVQUFVckQsRUFBRXFELFFBQVEsR0FBR0E7b0NBQVMsSUFDeENyRDtnQ0FFTjJFLGNBQWMsSUFBSWxELE9BQU9DLFdBQVc7NEJBQ3RDO3dCQUNGLE9BQU87NEJBQ0wsT0FBTztnQ0FDTCxHQUFHb0QsSUFBSTtnQ0FDUHZELE9BQU87dUNBQUl1RCxLQUFLdkQsS0FBSztvQ0FBRTt3Q0FBRVo7d0NBQU0wQzt3Q0FBVW1DO29DQUFTO2lDQUFFO2dDQUNwRGIsY0FBYyxJQUFJbEQsT0FBT0MsV0FBVzs0QkFDdEM7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBT29EO2dCQUNUO1FBQ0Y7SUFDRjtJQUVBLHdCQUF3QjtJQUN4QixNQUFNYyxxQkFBcUIsZUFDekJmLFFBQ0FOO1lBQ0FpQiw0RUFBb0Q7UUFFcEQsSUFBSXRHLFNBQVM7WUFDWCxJQUFJO2dCQUNGLGtDQUFrQztnQkFDbEMsTUFBTTRGLE9BQU92RixNQUFNUSxJQUFJLENBQUM4RixDQUFBQSxJQUFLQSxFQUFFNUYsRUFBRSxLQUFLNEU7Z0JBQ3RDLElBQUksQ0FBQ0MsTUFBTTtnQkFFWCxNQUFNZ0IsYUFBYWhCLEtBQUt2RCxLQUFLLENBQUN4QixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVXLElBQUksQ0FBQ1YsRUFBRSxLQUFLc0UsVUFBVXZFLEVBQUV3RixRQUFRLEtBQUtBO2dCQUMvRSxJQUFJLENBQUNNLFlBQVk7Z0JBRWpCLE1BQU10SCwwREFBV0EsQ0FBQzZGLFVBQVUsQ0FBQ1EsUUFBUWlCLFdBQVcxQixHQUFHO2dCQUVuRCx5QkFBeUI7Z0JBQ3pCLE1BQU1oQyxXQUFXLE1BQU01RCwwREFBV0EsQ0FBQ2tGLE9BQU8sQ0FBQ21CO2dCQUMzQyxJQUFJekMsU0FBUy9CLE9BQU8sRUFBRTtvQkFDcEJiLFNBQVM4QyxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDcUUsQ0FBQUEsT0FBUUEsS0FBSzdFLEVBQUUsS0FBSzRFLFNBQVN6QyxTQUFTbkQsSUFBSSxHQUFHNkY7Z0JBQ3pFO1lBQ0YsRUFBRSxPQUFPbEUsT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7Z0JBQ2hELE1BQU1BO1lBQ1I7UUFDRixPQUFPO1lBQ0wsNkJBQTZCO1lBQzdCcEIsU0FBUzhDLENBQUFBLE9BQVFBLEtBQUs3QixHQUFHLENBQUNxRSxDQUFBQTtvQkFDeEIsSUFBSUEsS0FBSzdFLEVBQUUsS0FBSzRFLFFBQVE7d0JBQ3RCLE9BQU87NEJBQ0wsR0FBR0MsSUFBSTs0QkFDUHZELE9BQU91RCxLQUFLdkQsS0FBSyxDQUFDeUIsTUFBTSxDQUFDaEQsQ0FBQUEsSUFBSyxDQUFFQSxDQUFBQSxFQUFFVyxJQUFJLENBQUNWLEVBQUUsS0FBS3NFLFVBQVV2RSxFQUFFd0YsUUFBUSxLQUFLQSxRQUFPOzRCQUM5RWIsY0FBYyxJQUFJbEQsT0FBT0MsV0FBVzt3QkFDdEM7b0JBQ0Y7b0JBQ0EsT0FBT29EO2dCQUNUO1FBQ0Y7SUFDRjtJQUVBLHdDQUF3QztJQUN4QyxNQUFNaUIsNEJBQTRCLGVBQ2hDbEIsUUFDQU4sUUFDQXlCO1lBQ0FSLDRFQUFvRDtRQUVwRCxJQUFJUSxrQkFBa0IsR0FBRztZQUN2QixNQUFNSixtQkFBbUJmLFFBQVFOLFFBQVFpQjtZQUN6QztRQUNGO1FBRUEsSUFBSXRHLFNBQVM7WUFDWCxJQUFJO2dCQUNGLGtDQUFrQztnQkFDbEMsTUFBTTRGLE9BQU92RixNQUFNUSxJQUFJLENBQUM4RixDQUFBQSxJQUFLQSxFQUFFNUYsRUFBRSxLQUFLNEU7Z0JBQ3RDLElBQUksQ0FBQ0MsTUFBTTtnQkFFWCxNQUFNZ0IsYUFBYWhCLEtBQUt2RCxLQUFLLENBQUN4QixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVXLElBQUksQ0FBQ1YsRUFBRSxLQUFLc0UsVUFBVXZFLEVBQUV3RixRQUFRLEtBQUtBO2dCQUMvRSxJQUFJLENBQUNNLFlBQVk7Z0JBRWpCLE1BQU10SCwwREFBV0EsQ0FBQzJGLFVBQVUsQ0FBQ1UsUUFBUWlCLFdBQVcxQixHQUFHLEVBQUU7b0JBQUVmLFVBQVUyQztnQkFBZTtnQkFFaEYseUJBQXlCO2dCQUN6QixNQUFNNUQsV0FBVyxNQUFNNUQsMERBQVdBLENBQUNrRixPQUFPLENBQUNtQjtnQkFDM0MsSUFBSXpDLFNBQVMvQixPQUFPLEVBQUU7b0JBQ3BCYixTQUFTOEMsQ0FBQUEsT0FBUUEsS0FBSzdCLEdBQUcsQ0FBQ3FFLENBQUFBLE9BQVFBLEtBQUs3RSxFQUFFLEtBQUs0RSxTQUFTekMsU0FBU25ELElBQUksR0FBRzZGO2dCQUN6RTtZQUNGLEVBQUUsT0FBT2xFLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyx5Q0FBeUNBO2dCQUN2RCxNQUFNQTtZQUNSO1FBQ0YsT0FBTztZQUNMLDZCQUE2QjtZQUM3QnBCLFNBQVM4QyxDQUFBQSxPQUFRQSxLQUFLN0IsR0FBRyxDQUFDcUUsQ0FBQUE7b0JBQ3hCLElBQUlBLEtBQUs3RSxFQUFFLEtBQUs0RSxRQUFRO3dCQUN0QixPQUFPOzRCQUNMLEdBQUdDLElBQUk7NEJBQ1B2RCxPQUFPdUQsS0FBS3ZELEtBQUssQ0FBQ2QsR0FBRyxDQUFDVCxDQUFBQSxJQUNwQkEsRUFBRVcsSUFBSSxDQUFDVixFQUFFLEtBQUtzRSxVQUFVdkUsRUFBRXdGLFFBQVEsS0FBS0EsV0FDbkM7b0NBQUUsR0FBR3hGLENBQUM7b0NBQUVxRCxVQUFVMkM7Z0NBQWUsSUFDakNoRzs0QkFFTjJFLGNBQWMsSUFBSWxELE9BQU9DLFdBQVc7d0JBQ3RDO29CQUNGO29CQUNBLE9BQU9vRDtnQkFDVDtRQUNGO0lBQ0Y7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTW1CLHlCQUF5QixDQUFDMUI7UUFDOUIsTUFBTTJCLFNBQWtFLEVBQUU7UUFFMUUzRyxNQUFNNEcsT0FBTyxDQUFDckIsQ0FBQUE7WUFDWkEsS0FBS3ZELEtBQUssQ0FBQzRFLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2pCLElBQUlBLFNBQVN6RixJQUFJLENBQUNWLEVBQUUsS0FBS3NFLFFBQVE7b0JBQy9CMkIsT0FBT0csSUFBSSxDQUFDO3dCQUNWdkI7d0JBQ0F6QixVQUFVK0MsU0FBUy9DLFFBQVE7d0JBQzNCbUMsVUFBVVksU0FBU1osUUFBUTtvQkFDN0I7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT1U7SUFDVDtJQUVBLDJEQUEyRDtJQUMzRCxNQUFNSSxzQkFBc0IsT0FBT0MsVUFBa0I5QjtRQUNuRCxJQUFJO1lBQ0YsOEJBQThCO1lBQzlCLE1BQU1JLFNBQVMsTUFBTUwsVUFBVTtnQkFDN0JuRCxNQUFNb0QsU0FBU3BELElBQUk7Z0JBQ25CZ0UsUUFBUVosU0FBU1ksTUFBTTtnQkFDdkIvRCxhQUFhbUQsU0FBU25ELFdBQVcsSUFBSTtnQkFDckNnRSxRQUFRYixTQUFTYSxNQUFNLElBQUksRUFBRTtnQkFDN0IvRCxPQUFPLEVBQUU7Z0JBQ1RLLFVBQVU2QyxTQUFTN0MsUUFBUSxJQUFJO2dCQUMvQjRFLE1BQU0vQixTQUFTK0IsSUFBSSxJQUFJLEVBQUU7WUFDM0I7WUFFQSw4QkFBOEI7WUFDOUIsTUFBTUMsUUFBUUYsU0FBU0csS0FBSyxDQUFDLE1BQU0xRCxNQUFNLENBQUMyRCxDQUFBQSxPQUFRQSxLQUFLQyxJQUFJO1lBQzNELElBQUlDLGlCQUEwRDtZQUM5RCxNQUFNQyxlQUFlLEVBQUU7WUFFdkIsS0FBSyxNQUFNSCxRQUFRRixNQUFPO2dCQUN4QixNQUFNTSxjQUFjSixLQUFLQyxJQUFJLEdBQUdJLFdBQVc7Z0JBRTNDLG9DQUFvQztnQkFDcEMsSUFBSUQsWUFBWUUsUUFBUSxDQUFDLGNBQWM7b0JBQ3JDSixpQkFBaUI7b0JBQ2pCO2dCQUNGO2dCQUNBLElBQUlFLFlBQVlFLFFBQVEsQ0FBQyxjQUFjO29CQUNyQ0osaUJBQWlCO29CQUNqQjtnQkFDRjtnQkFFQSxvQ0FBb0M7Z0JBQ3BDLE1BQU1LLFFBQVFQLEtBQUtPLEtBQUssQ0FBQztnQkFDekIsSUFBSUEsT0FBTztvQkFDVCxNQUFNN0QsV0FBVzhELFNBQVNELEtBQUssQ0FBQyxFQUFFO29CQUNsQyxNQUFNRSxXQUFXRixLQUFLLENBQUMsRUFBRSxDQUFDTixJQUFJO29CQUU5QixvQ0FBb0M7b0JBQ3BDRSxhQUFhVCxJQUFJLENBQ2YsQ0FBQzt3QkFDQyxJQUFJOzRCQUNGLE1BQU1qRSxXQUFXLE1BQU1pRixNQUFNLDhDQUEyRSxPQUE3QkMsbUJBQW1CRjs0QkFDOUYsSUFBSWhGLFNBQVNtRixFQUFFLEVBQUU7Z0NBQ2YsTUFBTUMsV0FBVyxNQUFNcEYsU0FBU3FGLElBQUk7Z0NBQ3BDLDRCQUE0QjtnQ0FDNUIsTUFBTTlCLHFCQUFxQmQsUUFBUTJDLFVBQVVYLGdCQUFnQnhEO2dDQUM3RCxPQUFPO29DQUFFaEQsU0FBUztvQ0FBTU0sTUFBTXlHO2dDQUFTOzRCQUN6QyxPQUFPO2dDQUNMdkcsUUFBUUQsS0FBSyxDQUFDLDRCQUFrQyxPQUFUd0c7Z0NBQ3ZDLE9BQU87b0NBQUUvRyxTQUFTO29DQUFPTSxNQUFNeUc7Z0NBQVM7NEJBQzFDO3dCQUNGLEVBQUUsT0FBT3hHLE9BQU87NEJBQ2RDLFFBQVFELEtBQUssQ0FBQyx3QkFBaUMsT0FBVHdHLFVBQVMsTUFBSXhHOzRCQUNuRCxPQUFPO2dDQUFFUCxTQUFTO2dDQUFPTSxNQUFNeUc7NEJBQVM7d0JBQzFDO29CQUNGO2dCQUVKO1lBQ0Y7WUFFQSw2Q0FBNkM7WUFDN0MsTUFBTU0sVUFBVSxNQUFNQyxRQUFRQyxVQUFVLENBQUNkO1lBQ3pDLE1BQU1lLGNBQWNILFFBQ2pCMUUsTUFBTSxDQUFDa0QsQ0FBQUEsU0FBVUEsT0FBTzRCLE1BQU0sS0FBSyxlQUFlLENBQUMsT0FBUUMsS0FBSyxDQUFTMUgsT0FBTyxFQUNoRkksR0FBRyxDQUFDeUYsQ0FBQUEsU0FBV0EsT0FBTzRCLE1BQU0sS0FBSyxjQUFjLE9BQVFDLEtBQUssQ0FBU3BILElBQUksR0FBRztZQUUvRSxJQUFJa0gsWUFBWXZILE1BQU0sR0FBRyxHQUFHO2dCQUMxQk8sUUFBUW1ILElBQUksQ0FBQyw0Q0FBZ0UsT0FBdkJILFlBQVlJLElBQUksQ0FBQztZQUN6RTtZQUVBLE9BQU9wRDtRQUNULEVBQUUsT0FBT2pFLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDBCQUEwQkE7WUFDeEMsTUFBTSxJQUFJOUIsTUFBTTtRQUNsQjtJQUNGO0lBRUEsc0RBQXNEO0lBRXRELGdDQUFnQztJQUNoQyxNQUFNb0osY0FBYyxPQUFPdkg7UUFDekIsSUFBSXpCLFNBQVM7WUFDWCxJQUFJO2dCQUNGLE1BQU1rRCxXQUFXLE1BQU0zRCw4REFBZUEsQ0FBQzBKLEdBQUcsQ0FBQ3hIO2dCQUMzQyxJQUFJeUIsU0FBUy9CLE9BQU8sRUFBRTtvQkFDcEJYLGFBQWE0QyxDQUFBQSxPQUFROytCQUFJQTs0QkFBTTNCO3lCQUFLO2dCQUN0QztZQUNGLEVBQUUsT0FBT0MsT0FBTztnQkFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7Z0JBQzdDLE1BQU1BO1lBQ1I7UUFDRixPQUFPO1lBQ0wsNkJBQTZCO1lBQzdCbEIsYUFBYTRDLENBQUFBO2dCQUNYLElBQUlBLEtBQUs4RixJQUFJLENBQUNwSSxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtVLEtBQUtWLEVBQUUsR0FBRyxPQUFPcUM7Z0JBQzdDLE9BQU87dUJBQUlBO29CQUFNM0I7aUJBQUs7WUFDeEI7UUFDRjtJQUNGO0lBRUEsOEJBQThCO0lBQzlCLE1BQU0wSCxpQkFBaUIsT0FBTzlEO1FBQzVCLElBQUlyRixTQUFTO1lBQ1gsSUFBSTtnQkFDRixNQUFNa0QsV0FBVyxNQUFNM0QsOERBQWVBLENBQUM0RixVQUFVLENBQUNFO2dCQUNsRCxJQUFJbkMsU0FBUy9CLE9BQU8sRUFBRTtvQkFDcEJYLGFBQWE0QyxDQUFBQSxPQUFRQSxLQUFLVSxNQUFNLENBQUNyQyxDQUFBQSxPQUFRQSxLQUFLVixFQUFFLEtBQUtzRTtnQkFDdkQ7WUFDRixFQUFFLE9BQU8zRCxPQUFPO2dCQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtnQkFDM0MsTUFBTUE7WUFDUjtRQUNGLE9BQU87WUFDTCw2QkFBNkI7WUFDN0JsQixhQUFhNEMsQ0FBQUEsT0FBUUEsS0FBS1UsTUFBTSxDQUFDckMsQ0FBQUEsT0FBUUEsS0FBS1YsRUFBRSxLQUFLc0U7UUFDdkQ7SUFDRjtJQUVBLDRDQUE0QztJQUM1QyxNQUFNK0QsYUFBYSxDQUFDL0Q7UUFDbEIsT0FBTzlFLFVBQVUySSxJQUFJLENBQUN6SCxDQUFBQSxPQUFRQSxLQUFLVixFQUFFLEtBQUtzRTtJQUM1QztJQUVBLDJEQUEyRDtJQUMzRCxNQUFNZ0Usd0JBQXdCLENBQUN0RTtRQUM3Qiw2REFBNkQ7UUFDN0QsTUFBTXVFLGFBQWE7WUFDakI7Z0JBQUM7Z0JBQVE7Z0JBQU87Z0JBQVk7Z0JBQVE7Z0JBQWE7YUFBVztlQUN6RHZFLFdBQVcxQyxLQUFLLENBQUNkLEdBQUcsQ0FBQ1QsQ0FBQUEsSUFBSztvQkFDM0JBLEVBQUVXLElBQUksQ0FBQ1UsSUFBSTtvQkFDWHJCLEVBQUVXLElBQUksQ0FBQzhILFFBQVE7b0JBQ2Z6SSxFQUFFcUQsUUFBUSxDQUFDWixRQUFRO29CQUNuQnpDLEVBQUV1RCxJQUFJLEdBQUcsU0FBUztvQkFDbEJ2RCxFQUFFc0QsU0FBUyxJQUFJO29CQUNmdEQsRUFBRXdELFFBQVEsSUFBSTtpQkFDZjtTQUNGLENBQUMvQyxHQUFHLENBQUNpSSxDQUFBQSxNQUFPQSxJQUFJVCxJQUFJLENBQUMsTUFBTUEsSUFBSSxDQUFDO1FBRWpDLE1BQU1VLE9BQU8sSUFBSUMsS0FBSztZQUFDSjtTQUFXLEVBQUU7WUFBRUssTUFBTTtRQUFXO1FBQ3ZELE1BQU1DLE1BQU1DLE9BQU9DLEdBQUcsQ0FBQ0MsZUFBZSxDQUFDTjtRQUN2QyxNQUFNTyxJQUFJQyxTQUFTQyxhQUFhLENBQUM7UUFDakNGLEVBQUVHLElBQUksR0FBR1A7UUFDVEksRUFBRUksUUFBUSxHQUFHLEdBQW1CLE9BQWhCckYsV0FBVzVDLElBQUksRUFBQztRQUNoQzZILEVBQUVLLEtBQUs7UUFDUFIsT0FBT0MsR0FBRyxDQUFDUSxlQUFlLENBQUNWO0lBQzdCO0lBRUEscUJBQ0UsOERBQUNuSyxXQUFXOEssUUFBUTtRQUFDMUIsT0FBTztZQUMxQjVJO1lBQ0FVO1lBQ0E2SixzQkFBc0J0SztZQUN0QkM7WUFDQUM7WUFDQTZDO1lBQ0FPO1lBQ0FHO1lBQ0FJO1lBQ0FVO1lBQ0FLO1lBQ0FNO1lBQ0EvRTtZQUNBQztZQUNBZ0Y7WUFDQUk7WUFDQUc7WUFDQUM7WUFDQVc7WUFDQUM7WUFDQUc7WUFDQUU7WUFDQUs7WUFDQTdHO1lBQ0F5STtZQUNBRztZQUNBQztZQUNBM0k7WUFDQTRJO1FBQ0Y7a0JBQ0d2Sjs7Ozs7O0FBR1AsRUFBRTtJQXh6QldEOztRQUNlTCx1REFBVUE7OztLQUR6QksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvQXBwQ29udGV4dC50c3g/MjUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgTVRHQ2FyZCwgVXNlckNvbGxlY3Rpb24sIENvbGxlY3Rpb25DYXJkLCBEZWNrLCBEZWNrQ2FyZCB9IGZyb20gJ0AvdHlwZXMvbXRnJztcbmltcG9ydCB7IGNvbGxlY3Rpb25TZXJ2aWNlLCBkZWNrU2VydmljZSwgZmF2b3JpdGVTZXJ2aWNlIH0gZnJvbSAnQC91dGlscy9hcGlTZXJ2aWNlJztcbmltcG9ydCB7IHVzZVNlc3Npb24gfSBmcm9tICduZXh0LWF1dGgvcmVhY3QnO1xuXG5pbnRlcmZhY2UgQXBwQ29udGV4dFR5cGUge1xuICBjb2xsZWN0aW9uczogVXNlckNvbGxlY3Rpb25bXTtcbiAgY3VycmVudENvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uIHwgdW5kZWZpbmVkO1xuICBzZXRDdXJyZW50Q29sbGVjdGlvbjogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248VXNlckNvbGxlY3Rpb25bXT4+O1xuICBjdXJyZW50Q29sbGVjdGlvbklkOiBzdHJpbmcgfCBudWxsO1xuICBzZXRDdXJyZW50Q29sbGVjdGlvbklkOiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIGNyZWF0ZUNvbGxlY3Rpb246IChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIHVwZGF0ZUNvbGxlY3Rpb246IChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFVzZXJDb2xsZWN0aW9uPikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGVsZXRlQ29sbGVjdGlvbjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGR1cGxpY2F0ZUNvbGxlY3Rpb246IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhZGljaW9uYXJDYXJ0YTogKGNhcmQ6IE1UR0NhcmQsIHF1YW50aWRhZGU/OiBudW1iZXIpID0+IFByb21pc2U8dm9pZD47XG4gIHJlbW92ZXJDYXJ0YTogKGNhcmQ6IE1UR0NhcmQpID0+IFByb21pc2U8dm9pZD47XG4gIGdldFF1YW50aWRhZGVOYUNvbGVjYW86IChjYXJkSWQ6IHN0cmluZykgPT4gbnVtYmVyO1xuICBcbiAgLy8gR2VyZW5jaWFtZW50byBkZSBEZWNrc1xuICBkZWNrczogRGVja1tdO1xuICBzZXREZWNrczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248RGVja1tdPj47XG4gIGNyaWFyRGVjazogKGRlY2s6IE9taXQ8RGVjaywgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ2xhc3RNb2RpZmllZCc+KSA9PiBQcm9taXNlPHN0cmluZz47XG4gIGVkaXRhckRlY2s6IChkZWNrSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxEZWNrPikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGVsZXRhckRlY2s6IChkZWNrSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZHVwbGljYXJEZWNrOiAoZGVja0lkOiBzdHJpbmcsIG5ld05hbWU/OiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPjtcbiAgYWRpY2lvbmFyQ2FydGFBb0RlY2s6IChkZWNrSWQ6IHN0cmluZywgY2FyZDogTVRHQ2FyZCwgY2F0ZWdvcnk/OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicsIHF1YW50aXR5PzogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZW1vdmVyQ2FydGFEb0RlY2s6IChkZWNrSWQ6IHN0cmluZywgY2FyZElkOiBzdHJpbmcsIGNhdGVnb3J5PzogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhdHVhbGl6YXJRdWFudGlkYWRlTm9EZWNrOiAoZGVja0lkOiBzdHJpbmcsIGNhcmRJZDogc3RyaW5nLCBub3ZhUXVhbnRpZGFkZTogbnVtYmVyLCBjYXRlZ29yeT86ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZ2V0Q2FydGFzVXNhZGFzRW1EZWNrczogKGNhcmRJZDogc3RyaW5nKSA9PiBBcnJheTx7ZGVjazogRGVjaywgcXVhbnRpdHk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZ30+O1xuICBpbXBvcnRhckRlY2tEZUxpc3RhOiAoZGVja0xpc3Q6IHN0cmluZywgZGVja0RhdGE6IGFueSkgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICBcbiAgLy8gRmF2b3JpdG9zXG4gIGZhdm9yaXRlczogTVRHQ2FyZFtdO1xuICBhZGRGYXZvcml0ZTogKGNhcmQ6IE1UR0NhcmQpID0+IFByb21pc2U8dm9pZD47XG4gIHJlbW92ZUZhdm9yaXRlOiAoY2FyZElkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGlzRmF2b3JpdGU6IChjYXJkSWQ6IHN0cmluZykgPT4gYm9vbGVhbjtcbiAgXG4gIC8vIEVzdGFkbyBkZSBjYXJyZWdhbWVudG9cbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgXG4gIC8vIEV4cG9ydGHDp8Ojb1xuICBleHBvcnRDb2xsZWN0aW9uVG9DU1Y6IChjb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbikgPT4gdm9pZDtcbn1cblxuY29uc3QgQXBwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXBwQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuZXhwb3J0IGNvbnN0IHVzZUFwcENvbnRleHQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUFwcENvbnRleHQgZGV2ZSBzZXIgdXNhZG8gZGVudHJvIGRlIHVtIEFwcFByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5pbnRlcmZhY2UgQXBwUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBjb25zdCBBcHBQcm92aWRlcjogUmVhY3QuRkM8QXBwUHJvdmlkZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xuICBjb25zdCBbY29sbGVjdGlvbnMsIHNldENvbGxlY3Rpb25zXSA9IHVzZVN0YXRlPFVzZXJDb2xsZWN0aW9uW10+KFtdKTtcbiAgY29uc3QgW2N1cnJlbnRDb2xsZWN0aW9uSWQsIHNldEN1cnJlbnRDb2xsZWN0aW9uSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtkZWNrcywgc2V0RGVja3NdID0gdXNlU3RhdGU8RGVja1tdPihbXSk7XG4gIGNvbnN0IFtmYXZvcml0ZXMsIHNldEZhdm9yaXRlc10gPSB1c2VTdGF0ZTxNVEdDYXJkW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgY29uc3QgY3VycmVudENvbGxlY3Rpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY29sbGVjdGlvbnMuZmluZChjID0+IGMuaWQgPT09IGN1cnJlbnRDb2xsZWN0aW9uSWQpO1xuICB9LCBbY29sbGVjdGlvbnMsIGN1cnJlbnRDb2xsZWN0aW9uSWRdKTtcblxuICAvLyBDYXJyZWdhciBkYWRvcyBkYSBBUEkgcXVhbmRvIG8gdXN1w6FyaW8gZXN0aXZlciBhdXRlbnRpY2Fkb1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDYXJyZWdhciBjb2xlw6fDtWVzXG4gICAgICAgICAgY29uc3QgY29sbGVjdGlvbnNSZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEFsbCgpO1xuICAgICAgICAgIGlmIChjb2xsZWN0aW9uc1Jlc3BvbnNlLnN1Y2Nlc3MgJiYgY29sbGVjdGlvbnNSZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhjb2xsZWN0aW9uc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25zUmVzcG9uc2UuZGF0YS5sZW5ndGggPiAwICYmICFjdXJyZW50Q29sbGVjdGlvbklkKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQoY29sbGVjdGlvbnNSZXNwb25zZS5kYXRhWzBdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYXJyZWdhciBkZWNrc1xuICAgICAgICAgIGNvbnN0IGRlY2tzUmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5nZXRBbGwoKTtcbiAgICAgICAgICBpZiAoZGVja3NSZXNwb25zZS5zdWNjZXNzICYmIGRlY2tzUmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgc2V0RGVja3MoZGVja3NSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYXJyZWdhciBmYXZvcml0b3NcbiAgICAgICAgICBjb25zdCBmYXZvcml0ZXNSZXNwb25zZSA9IGF3YWl0IGZhdm9yaXRlU2VydmljZS5nZXRBbGwoKTtcbiAgICAgICAgICBpZiAoZmF2b3JpdGVzUmVzcG9uc2Uuc3VjY2VzcyAmJiBmYXZvcml0ZXNSZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICBzZXRGYXZvcml0ZXMoZmF2b3JpdGVzUmVzcG9uc2UuZGF0YS5tYXAoKGZhdjogYW55KSA9PiBmYXYuY2FyZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGRhZG9zOicsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXN1w6FyaW8gbsOjbyBhdXRlbnRpY2FkbywgdXNhciBsb2NhbFN0b3JhZ2UgY29tbyBmYWxsYmFja1xuICAgICAgICBjb25zdCBzYXZlZENvbGxlY3Rpb25zID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ210Zy1jb2xsZWN0aW9ucycpO1xuICAgICAgICBpZiAoc2F2ZWRDb2xsZWN0aW9ucykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRDb2xsZWN0aW9ucyA9IEpTT04ucGFyc2Uoc2F2ZWRDb2xsZWN0aW9ucyk7XG4gICAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwYXJzZWRDb2xsZWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAocGFyc2VkQ29sbGVjdGlvbnMubGVuZ3RoID4gMCAmJiAhY3VycmVudENvbGxlY3Rpb25JZCkge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKHBhcnNlZENvbGxlY3Rpb25zWzBdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBjb2xlw6fDtWVzIHNhbHZhczonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENyaWFyIHVtYSBjb2xlw6fDo28gcGFkcsOjbyBzZSBuw6NvIGhvdXZlciBuZW5odW1hXG4gICAgICAgICAgY29uc3QgZGVmYXVsdENvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uID0ge1xuICAgICAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgICAgIG5hbWU6ICdNaW5oYSBDb2xlw6fDo28nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdDb2xlw6fDo28gcHJpbmNpcGFsIGRlIGNhcnRhcyBNYWdpYycsXG4gICAgICAgICAgICBjYXJkczogW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaXNQdWJsaWM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhbZGVmYXVsdENvbGxlY3Rpb25dKTtcbiAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKGRlZmF1bHRDb2xsZWN0aW9uLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNhdmVkRGVja3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXRnLWRlY2tzJyk7XG4gICAgICAgIGlmIChzYXZlZERlY2tzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERlY2tzID0gSlNPTi5wYXJzZShzYXZlZERlY2tzKTtcbiAgICAgICAgICAgIHNldERlY2tzKHBhcnNlZERlY2tzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBkZWNrcyBzYWx2b3M6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNhdmVkRmF2b3JpdGVzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ210Zy1mYXZvcml0ZXMnKTtcbiAgICAgICAgaWYgKHNhdmVkRmF2b3JpdGVzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEZhdm9yaXRlcyA9IEpTT04ucGFyc2Uoc2F2ZWRGYXZvcml0ZXMpO1xuICAgICAgICAgICAgc2V0RmF2b3JpdGVzKHBhcnNlZEZhdm9yaXRlcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY2FycmVnYXIgZmF2b3JpdG9zIHNhbHZvczonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZERhdGEoKTtcbiAgfSwgW3Nlc3Npb25dKTtcblxuICAvLyBTYWx2YXIgZGFkb3Mgbm8gbG9jYWxTdG9yYWdlIHF1YW5kbyBuw6NvIGVzdGl2ZXIgYXV0ZW50aWNhZG9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdtdGctY29sbGVjdGlvbnMnLCBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9ucykpO1xuICAgIH1cbiAgfSwgW2NvbGxlY3Rpb25zLCBzZXNzaW9uXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdtdGctZGVja3MnLCBKU09OLnN0cmluZ2lmeShkZWNrcykpO1xuICAgIH1cbiAgfSwgW2RlY2tzLCBzZXNzaW9uXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdtdGctZmF2b3JpdGVzJywgSlNPTi5zdHJpbmdpZnkoZmF2b3JpdGVzKSk7XG4gICAgfVxuICB9LCBbZmF2b3JpdGVzLCBzZXNzaW9uXSk7XG5cbiAgLy8gRnVuw6fDtWVzIGRlIGdlcmVuY2lhbWVudG8gZGUgY29sZcOnw6NvXG4gIGNvbnN0IGNyZWF0ZUNvbGxlY3Rpb24gPSBhc3luYyAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nID0gJycpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmNyZWF0ZSh7IG5hbWUsIGRlc2NyaXB0aW9uIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBbLi4ucHJldiwgcmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQocmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvIGFvIGNyaWFyIGNvbGXDp8OjbycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjcmlhciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uID0ge1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgY2FyZHM6IFtdLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGlzUHVibGljOiBmYWxzZSxcbiAgICAgIH07XG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdDb2xsZWN0aW9uXSk7XG4gICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKG5ld0NvbGxlY3Rpb24uaWQpO1xuICAgICAgcmV0dXJuIG5ld0NvbGxlY3Rpb24uaWQ7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZUNvbGxlY3Rpb24gPSBhc3luYyAoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxVc2VyQ29sbGVjdGlvbj4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS51cGRhdGUoaWQsIHVwZGF0ZXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBpZCA/IHsgLi4uYywgLi4udXBkYXRlcyB9IDogYykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGF0dWFsaXphciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBpZCA/IHsgLi4uYywgLi4udXBkYXRlcywgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSA6IGMpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZGVsZXRlQ29sbGVjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuZGVsZXRlKGlkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb25zID0gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBpZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbGxlY3Rpb25JZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChuZXdDb2xsZWN0aW9ucy5sZW5ndGggPiAwID8gbmV3Q29sbGVjdGlvbnNbMF0uaWQgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdDb2xsZWN0aW9ucztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBleGNsdWlyIGNvbGXDp8OjbzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb25zID0gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBpZCk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sbGVjdGlvbklkID09PSBpZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQobmV3Q29sbGVjdGlvbnMubGVuZ3RoID4gMCA/IG5ld0NvbGxlY3Rpb25zWzBdLmlkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0NvbGxlY3Rpb25zO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGR1cGxpY2F0ZUNvbGxlY3Rpb24gPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25Ub0R1cGxpY2F0ZSA9IGNvbGxlY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgaWYgKCFjb2xsZWN0aW9uVG9EdXBsaWNhdGUpIHJldHVybjtcblxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aW9uID0ge1xuICAgICAgICAgIG5hbWU6IGAke2NvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGNvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBpc1B1YmxpYzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuY3JlYXRlKG5ld0NvbGxlY3Rpb24pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgLy8gQWRpY2lvbmFyIGNhcnRhcyDDoCBub3ZhIGNvbGXDp8Ojb1xuICAgICAgICAgIGZvciAoY29uc3QgY2FyZEl0ZW0gb2YgY29sbGVjdGlvblRvRHVwbGljYXRlLmNhcmRzKSB7XG4gICAgICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5hZGRDYXJkKHJlc3BvbnNlLmRhdGEuaWQsIHtcbiAgICAgICAgICAgICAgY2FyZDogY2FyZEl0ZW0uY2FyZCxcbiAgICAgICAgICAgICAgcXVhbnRpdHk6IGNhcmRJdGVtLnF1YW50aXR5LFxuICAgICAgICAgICAgICBjb25kaXRpb246IGNhcmRJdGVtLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgZm9pbDogY2FyZEl0ZW0uZm9pbCxcbiAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGNhcmRJdGVtLmxhbmd1YWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEJ5SWQocmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRSZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IFsuLi5wcmV2LCB1cGRhdGVkUmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBkdXBsaWNhciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uID0ge1xuICAgICAgICAuLi5jb2xsZWN0aW9uVG9EdXBsaWNhdGUsXG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IGAke2NvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICB9O1xuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBbLi4ucHJldiwgbmV3Q29sbGVjdGlvbl0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW7Dp8OjbyBwYXJhIGFkaWNpb25hciBjYXJ0YSDDoCBjb2xlw6fDo29cbiAgY29uc3QgYWRpY2lvbmFyQ2FydGEgPSBhc3luYyAoY2FyZDogTVRHQ2FyZCwgcXVhbnRpZGFkZTogbnVtYmVyID0gMSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghY3VycmVudENvbGxlY3Rpb25JZCkgcmV0dXJuO1xuICAgIFxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5hZGRDYXJkKGN1cnJlbnRDb2xsZWN0aW9uSWQsIHtcbiAgICAgICAgICBjYXJkLFxuICAgICAgICAgIHF1YW50aXR5OiBxdWFudGlkYWRlLFxuICAgICAgICAgIGNvbmRpdGlvbjogJ05lYXIgTWludCcsXG4gICAgICAgICAgZm9pbDogZmFsc2UsXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdFbmdsaXNoJ1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5nZXRCeUlkKGN1cnJlbnRDb2xsZWN0aW9uSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBjdXJyZW50Q29sbGVjdGlvbklkID8gcmVzcG9uc2UuZGF0YSA6IGMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgY2FydGE6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiB7XG4gICAgICAgIGlmIChjLmlkICE9PSBjdXJyZW50Q29sbGVjdGlvbklkKSByZXR1cm4gYztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FyZCA9IGMuY2FyZHMuZmluZChjYyA9PiBjYy5jYXJkLmlkID09PSBjYXJkLmlkKTtcbiAgICAgICAgbGV0IG5ld0NhcmRzO1xuICAgICAgICBpZiAoZXhpc3RpbmdDYXJkKSB7XG4gICAgICAgICAgbmV3Q2FyZHMgPSBjLmNhcmRzLm1hcChjYyA9PlxuICAgICAgICAgICAgY2MuY2FyZC5pZCA9PT0gY2FyZC5pZFxuICAgICAgICAgICAgICA/IHsgLi4uY2MsIHF1YW50aXR5OiBjYy5xdWFudGl0eSArIHF1YW50aWRhZGUgfVxuICAgICAgICAgICAgICA6IGNjXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDYXJkcyA9IFsuLi5jLmNhcmRzLCB7XG4gICAgICAgICAgICBjYXJkLFxuICAgICAgICAgICAgcXVhbnRpdHk6IHF1YW50aWRhZGUsXG4gICAgICAgICAgICBjb25kaXRpb246ICdOZWFyIE1pbnQnLFxuICAgICAgICAgICAgZm9pbDogZmFsc2VcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5jLCBjYXJkczogbmV3Q2FyZHMsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH07XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bsOnw6NvIHBhcmEgcmVtb3ZlciBjYXJ0YSBkYSBjb2xlw6fDo29cbiAgY29uc3QgcmVtb3ZlckNhcnRhID0gYXN5bmMgKGNhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWN1cnJlbnRDb2xsZWN0aW9uSWQpIHJldHVybjtcbiAgICBcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5jb250cmFyIG8gSUQgZGEgY2FydGEgbmEgY29sZcOnw6NvXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FyZEluQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uY2FyZHMuZmluZChjYyA9PiBjYy5jYXJkLmlkID09PSBjYXJkLmlkKTtcbiAgICAgICAgaWYgKCFjYXJkSW5Db2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FyZEluQ29sbGVjdGlvbi5xdWFudGl0eSA+IDEpIHtcbiAgICAgICAgICAvLyBBdHVhbGl6YXIgcXVhbnRpZGFkZVxuICAgICAgICAgIGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLnVwZGF0ZUNhcmQoY3VycmVudENvbGxlY3Rpb25JZCwgY2FyZEluQ29sbGVjdGlvbi5faWQsIHtcbiAgICAgICAgICAgIHF1YW50aXR5OiBjYXJkSW5Db2xsZWN0aW9uLnF1YW50aXR5IC0gMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZXIgY2FydGFcbiAgICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5yZW1vdmVDYXJkKGN1cnJlbnRDb2xsZWN0aW9uSWQsIGNhcmRJbkNvbGxlY3Rpb24uX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEJ5SWQoY3VycmVudENvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IGMuaWQgPT09IGN1cnJlbnRDb2xsZWN0aW9uSWQgPyByZXNwb25zZS5kYXRhIDogYykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlbW92ZXIgY2FydGE6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiB7XG4gICAgICAgIGlmIChjLmlkICE9PSBjdXJyZW50Q29sbGVjdGlvbklkKSByZXR1cm4gYztcblxuICAgICAgICBjb25zdCBleGlzdGluZ0NhcmQgPSBjLmNhcmRzLmZpbmQoY2MgPT4gY2MuY2FyZC5pZCA9PT0gY2FyZC5pZCk7XG4gICAgICAgIGxldCBuZXdDYXJkcztcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FyZCAmJiBleGlzdGluZ0NhcmQucXVhbnRpdHkgPiAxKSB7XG4gICAgICAgICAgbmV3Q2FyZHMgPSBjLmNhcmRzLm1hcChjYyA9PlxuICAgICAgICAgICAgY2MuY2FyZC5pZCA9PT0gY2FyZC5pZFxuICAgICAgICAgICAgICA/IHsgLi4uY2MsIHF1YW50aXR5OiBjYy5xdWFudGl0eSAtIDEgfVxuICAgICAgICAgICAgICA6IGNjXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDYXJkcyA9IGMuY2FyZHMuZmlsdGVyKGNjID0+IGNjLmNhcmQuaWQgIT09IGNhcmQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmMsIGNhcmRzOiBuZXdDYXJkcywgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuw6fDo28gcGFyYSBvYnRlciBxdWFudGlkYWRlIGRlIHVtYSBjYXJ0YSBuYSBjb2xlw6fDo29cbiAgY29uc3QgZ2V0UXVhbnRpZGFkZU5hQ29sZWNhbyA9IChjYXJkSWQ6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgY29uc3QgY2FyZCA9IGN1cnJlbnRDb2xsZWN0aW9uPy5jYXJkcz8uZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZElkKTtcbiAgICByZXR1cm4gY2FyZCA/IGNhcmQucXVhbnRpdHkgOiAwO1xuICB9O1xuXG4gIC8vID09PT09PSBGVU7Dh8OVRVMgREUgR0VSRU5DSUFNRU5UTyBERSBERUNLUyA9PT09PT1cblxuICAvLyBDcmlhciBub3ZvIGRlY2tcbiAgY29uc3QgY3JpYXJEZWNrID0gYXN5bmMgKGRlY2tEYXRhOiBPbWl0PERlY2ssICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdsYXN0TW9kaWZpZWQnPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuY3JlYXRlKGRlY2tEYXRhKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gWy4uLnByZXYsIHJlc3BvbnNlLmRhdGFdKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm8gYW8gY3JpYXIgZGVjaycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjcmlhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBuZXdEZWNrOiBEZWNrID0ge1xuICAgICAgICAuLi5kZWNrRGF0YSxcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIHNldERlY2tzKHByZXYgPT4gWy4uLnByZXYsIG5ld0RlY2tdKTtcbiAgICAgIHJldHVybiBuZXdEZWNrLmlkO1xuICAgIH1cbiAgfTtcblxuICAvLyBFZGl0YXIgZGVjayBleGlzdGVudGVcbiAgY29uc3QgZWRpdGFyRGVjayA9IGFzeW5jIChkZWNrSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxEZWNrPik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLnVwZGF0ZShkZWNrSWQsIHVwZGF0ZXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiBcbiAgICAgICAgICAgIGRlY2suaWQgPT09IGRlY2tJZCBcbiAgICAgICAgICAgICAgPyB7IC4uLmRlY2ssIC4uLnVwZGF0ZXMgfVxuICAgICAgICAgICAgICA6IGRlY2tcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBlZGl0YXIgZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IFxuICAgICAgICBkZWNrLmlkID09PSBkZWNrSWQgXG4gICAgICAgICAgPyB7IC4uLmRlY2ssIC4uLnVwZGF0ZXMsIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cbiAgICAgICAgICA6IGRlY2tcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWxldGFyIGRlY2tcbiAgY29uc3QgZGVsZXRhckRlY2sgPSBhc3luYyAoZGVja0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5kZWxldGUoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKGRlY2sgPT4gZGVjay5pZCAhPT0gZGVja0lkKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZGVsZXRhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKGRlY2sgPT4gZGVjay5pZCAhPT0gZGVja0lkKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIER1cGxpY2FyIGRlY2tcbiAgY29uc3QgZHVwbGljYXJEZWNrID0gYXN5bmMgKGRlY2tJZDogc3RyaW5nLCBuZXdOYW1lPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbERlY2sgPSBkZWNrcy5maW5kKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkKTtcbiAgICBpZiAoIW9yaWdpbmFsRGVjaykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdEZWNrRGF0YSA9IHtcbiAgICAgICAgICBuYW1lOiBuZXdOYW1lIHx8IGAke29yaWdpbmFsRGVjay5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICAgICAgZGVzY3JpcHRpb246IG9yaWdpbmFsRGVjay5kZXNjcmlwdGlvbixcbiAgICAgICAgICBmb3JtYXQ6IG9yaWdpbmFsRGVjay5mb3JtYXQsXG4gICAgICAgICAgY29sb3JzOiBvcmlnaW5hbERlY2suY29sb3JzLFxuICAgICAgICAgIGlzUHVibGljOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5jcmVhdGUobmV3RGVja0RhdGEpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgLy8gQWRpY2lvbmFyIGNhcnRhcyBhbyBub3ZvIGRlY2tcbiAgICAgICAgICBmb3IgKGNvbnN0IGNhcmRJdGVtIG9mIG9yaWdpbmFsRGVjay5jYXJkcykge1xuICAgICAgICAgICAgYXdhaXQgZGVja1NlcnZpY2UuYWRkQ2FyZChyZXNwb25zZS5kYXRhLmlkLCB7XG4gICAgICAgICAgICAgIGNhcmQ6IGNhcmRJdGVtLmNhcmQsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiBjYXJkSXRlbS5xdWFudGl0eSxcbiAgICAgICAgICAgICAgaXNTaWRlYm9hcmQ6IGNhcmRJdGVtLmNhdGVnb3J5ID09PSAnc2lkZWJvYXJkJyxcbiAgICAgICAgICAgICAgaXNDb21tYW5kZXI6IGNhcmRJdGVtLmNhdGVnb3J5ID09PSAnY29tbWFuZGVyJyxcbiAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhcmRJdGVtLmNhdGVnb3J5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQocmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRSZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IFsuLi5wcmV2LCB1cGRhdGVkUmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRSZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBkdXBsaWNhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBkdXBsaWNhdGVkRGVjazogRGVjayA9IHtcbiAgICAgICAgLi4ub3JpZ2luYWxEZWNrLFxuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBuYW1lOiBuZXdOYW1lIHx8IGAke29yaWdpbmFsRGVjay5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBzZXREZWNrcyhwcmV2ID0+IFsuLi5wcmV2LCBkdXBsaWNhdGVkRGVja10pO1xuICAgICAgcmV0dXJuIGR1cGxpY2F0ZWREZWNrLmlkO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGljaW9uYXIgY2FydGEgYW8gZGVja1xuICBjb25zdCBhZGljaW9uYXJDYXJ0YUFvRGVjayA9IGFzeW5jIChcbiAgICBkZWNrSWQ6IHN0cmluZywgXG4gICAgY2FyZDogTVRHQ2FyZCwgXG4gICAgY2F0ZWdvcnk6ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnLFxuICAgIHF1YW50aXR5OiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBkZWNrU2VydmljZS5hZGRDYXJkKGRlY2tJZCwge1xuICAgICAgICAgIGNhcmQsXG4gICAgICAgICAgcXVhbnRpdHksXG4gICAgICAgICAgaXNTaWRlYm9hcmQ6IGNhdGVnb3J5ID09PSAnc2lkZWJvYXJkJyxcbiAgICAgICAgICBpc0NvbW1hbmRlcjogY2F0ZWdvcnkgPT09ICdjb21tYW5kZXInLFxuICAgICAgICAgIGNhdGVnb3J5XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkID8gcmVzcG9uc2UuZGF0YSA6IGRlY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgY2FydGEgYW8gZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IHtcbiAgICAgICAgaWYgKGRlY2suaWQgPT09IGRlY2tJZCkge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FyZCA9IGRlY2suY2FyZHMuZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZC5pZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nQ2FyZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZGVjayxcbiAgICAgICAgICAgICAgY2FyZHM6IGRlY2suY2FyZHMubWFwKGMgPT4gXG4gICAgICAgICAgICAgICAgYy5jYXJkLmlkID09PSBjYXJkLmlkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICA/IHsgLi4uYywgcXVhbnRpdHk6IGMucXVhbnRpdHkgKyBxdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgICA6IGNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmRlY2ssXG4gICAgICAgICAgICAgIGNhcmRzOiBbLi4uZGVjay5jYXJkcywgeyBjYXJkLCBxdWFudGl0eSwgY2F0ZWdvcnkgfV0sXG4gICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaztcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlciBjYXJ0YSBkbyBkZWNrXG4gIGNvbnN0IHJlbW92ZXJDYXJ0YURvRGVjayA9IGFzeW5jIChcbiAgICBkZWNrSWQ6IHN0cmluZywgXG4gICAgY2FyZElkOiBzdHJpbmcsIFxuICAgIGNhdGVnb3J5OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicgPSAnbWFpbmJvYXJkJ1xuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5jb250cmFyIG8gSUQgZGEgY2FydGEgbm8gZGVja1xuICAgICAgICBjb25zdCBkZWNrID0gZGVja3MuZmluZChkID0+IGQuaWQgPT09IGRlY2tJZCk7XG4gICAgICAgIGlmICghZGVjaykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FyZEluRGVjayA9IGRlY2suY2FyZHMuZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZElkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KTtcbiAgICAgICAgaWYgKCFjYXJkSW5EZWNrKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBkZWNrU2VydmljZS5yZW1vdmVDYXJkKGRlY2tJZCwgY2FyZEluRGVjay5faWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkID8gcmVzcG9uc2UuZGF0YSA6IGRlY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyByZW1vdmVyIGNhcnRhIGRvIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiB7XG4gICAgICAgIGlmIChkZWNrLmlkID09PSBkZWNrSWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGVjayxcbiAgICAgICAgICAgIGNhcmRzOiBkZWNrLmNhcmRzLmZpbHRlcihjID0+ICEoYy5jYXJkLmlkID09PSBjYXJkSWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpKSxcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaztcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQXR1YWxpemFyIHF1YW50aWRhZGUgZGUgY2FydGEgbm8gZGVja1xuICBjb25zdCBhdHVhbGl6YXJRdWFudGlkYWRlTm9EZWNrID0gYXN5bmMgKFxuICAgIGRlY2tJZDogc3RyaW5nLCBcbiAgICBjYXJkSWQ6IHN0cmluZywgXG4gICAgbm92YVF1YW50aWRhZGU6IG51bWJlciwgXG4gICAgY2F0ZWdvcnk6ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnXG4gICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChub3ZhUXVhbnRpZGFkZSA8PSAwKSB7XG4gICAgICBhd2FpdCByZW1vdmVyQ2FydGFEb0RlY2soZGVja0lkLCBjYXJkSWQsIGNhdGVnb3J5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5jb250cmFyIG8gSUQgZGEgY2FydGEgbm8gZGVja1xuICAgICAgICBjb25zdCBkZWNrID0gZGVja3MuZmluZChkID0+IGQuaWQgPT09IGRlY2tJZCk7XG4gICAgICAgIGlmICghZGVjaykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FyZEluRGVjayA9IGRlY2suY2FyZHMuZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZElkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KTtcbiAgICAgICAgaWYgKCFjYXJkSW5EZWNrKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBkZWNrU2VydmljZS51cGRhdGVDYXJkKGRlY2tJZCwgY2FyZEluRGVjay5faWQsIHsgcXVhbnRpdHk6IG5vdmFRdWFudGlkYWRlIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkID8gcmVzcG9uc2UuZGF0YSA6IGRlY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhdHVhbGl6YXIgcXVhbnRpZGFkZSBubyBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4ge1xuICAgICAgICBpZiAoZGVjay5pZCA9PT0gZGVja0lkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRlY2ssXG4gICAgICAgICAgICBjYXJkczogZGVjay5jYXJkcy5tYXAoYyA9PiBcbiAgICAgICAgICAgICAgYy5jYXJkLmlkID09PSBjYXJkSWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICA/IHsgLi4uYywgcXVhbnRpdHk6IG5vdmFRdWFudGlkYWRlIH1cbiAgICAgICAgICAgICAgICA6IGNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY2s7XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE9idGVyIGNhcnRhcyBxdWUgZXN0w6NvIHNlbmRvIHVzYWRhcyBlbSBkZWNrc1xuICBjb25zdCBnZXRDYXJ0YXNVc2FkYXNFbURlY2tzID0gKGNhcmRJZDogc3RyaW5nKTogQXJyYXk8e2RlY2s6IERlY2ssIHF1YW50aXR5OiBudW1iZXIsIGNhdGVnb3J5OiBzdHJpbmd9PiA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBBcnJheTx7ZGVjazogRGVjaywgcXVhbnRpdHk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZ30+ID0gW107XG4gICAgXG4gICAgZGVja3MuZm9yRWFjaChkZWNrID0+IHtcbiAgICAgIGRlY2suY2FyZHMuZm9yRWFjaChkZWNrQ2FyZCA9PiB7XG4gICAgICAgIGlmIChkZWNrQ2FyZC5jYXJkLmlkID09PSBjYXJkSWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBkZWNrLFxuICAgICAgICAgICAgcXVhbnRpdHk6IGRlY2tDYXJkLnF1YW50aXR5LFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGRlY2tDYXJkLmNhdGVnb3J5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIFxuICAvLyBGdW7Dp8OjbyBwYXJhIGltcG9ydGFyIGRlY2sgYSBwYXJ0aXIgZGUgdW1hIGxpc3RhIGRlIHRleHRvXG4gIGNvbnN0IGltcG9ydGFyRGVja0RlTGlzdGEgPSBhc3luYyAoZGVja0xpc3Q6IHN0cmluZywgZGVja0RhdGE6IGFueSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyaWFyIG8gZGVjayB2YXppbyBwcmltZWlyb1xuICAgICAgY29uc3QgZGVja0lkID0gYXdhaXQgY3JpYXJEZWNrKHtcbiAgICAgICAgbmFtZTogZGVja0RhdGEubmFtZSxcbiAgICAgICAgZm9ybWF0OiBkZWNrRGF0YS5mb3JtYXQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZWNrRGF0YS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgY29sb3JzOiBkZWNrRGF0YS5jb2xvcnMgfHwgW10sXG4gICAgICAgIGNhcmRzOiBbXSxcbiAgICAgICAgaXNQdWJsaWM6IGRlY2tEYXRhLmlzUHVibGljIHx8IGZhbHNlLFxuICAgICAgICB0YWdzOiBkZWNrRGF0YS50YWdzIHx8IFtdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2Vzc2FyIGEgbGlzdGEgZGUgY2FydGFzXG4gICAgICBjb25zdCBsaW5lcyA9IGRlY2tMaXN0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgICBsZXQgY3VycmVudFNlY3Rpb246ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnO1xuICAgICAgY29uc3QgY2FyZFByb21pc2VzID0gW107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZmljYXIgc2Ugw6kgdW1hIGxpbmhhIGRlIHNlw6fDo29cbiAgICAgICAgaWYgKHRyaW1tZWRMaW5lLmluY2x1ZGVzKCdzaWRlYm9hcmQnKSkge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gJ3NpZGVib2FyZCc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1tZWRMaW5lLmluY2x1ZGVzKCdjb21tYW5kZXInKSkge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gJ2NvbW1hbmRlcic7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmaWNhciBzZSDDqSB1bWEgbGluaGEgZGUgY2FydGFcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eKFxcZCspeD9cXHMrKC4rKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgcXVhbnRpdHkgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgY29uc3QgY2FyZE5hbWUgPSBtYXRjaFsyXS50cmltKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQnVzY2FyIGEgY2FydGEgbmEgQVBJIGRvIFNjcnlmYWxsXG4gICAgICAgICAgY2FyZFByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLnNjcnlmYWxsLmNvbS9jYXJkcy9uYW1lZD9mdXp6eT0ke2VuY29kZVVSSUNvbXBvbmVudChjYXJkTmFtZSl9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXJkRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgIC8vIEFkaWNpb25hciBhIGNhcnRhIGFvIGRlY2tcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGFkaWNpb25hckNhcnRhQW9EZWNrKGRlY2tJZCwgY2FyZERhdGEsIGN1cnJlbnRTZWN0aW9uLCBxdWFudGl0eSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBjYXJkOiBjYXJkTmFtZSB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDYXJ0YSBuw6NvIGVuY29udHJhZGE6ICR7Y2FyZE5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgY2FyZDogY2FyZE5hbWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJybyBhbyBidXNjYXIgY2FydGEgJHtjYXJkTmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBjYXJkOiBjYXJkTmFtZSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZ3VhcmRhciB0b2RhcyBhcyBjYXJ0YXMgc2VyZW0gcHJvY2Vzc2FkYXNcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoY2FyZFByb21pc2VzKTtcbiAgICAgIGNvbnN0IGZhaWxlZENhcmRzID0gcmVzdWx0c1xuICAgICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyAmJiAhKHJlc3VsdC52YWx1ZSBhcyBhbnkpLnN1Y2Nlc3MpXG4gICAgICAgIC5tYXAocmVzdWx0ID0+IChyZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJyA/IChyZXN1bHQudmFsdWUgYXMgYW55KS5jYXJkIDogJ1Vua25vd24nKSk7XG4gICAgICBcbiAgICAgIGlmIChmYWlsZWRDYXJkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQWxndW1hcyBjYXJ0YXMgbsOjbyBmb3JhbSBlbmNvbnRyYWRhczogJHtmYWlsZWRDYXJkcy5qb2luKCcsICcpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZGVja0lkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGltcG9ydGFyIGRlY2s6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWxoYSBhbyBpbXBvcnRhciBkZWNrLiBWZXJpZmlxdWUgbyBmb3JtYXRvIGRhIGxpc3RhLicpO1xuICAgIH1cbiAgfTtcblxuICAvLyA9PT09PT0gRlVOw4fDlUVTIERFIEdFUkVOQ0lBTUVOVE8gREUgRkFWT1JJVE9TID09PT09PVxuXG4gIC8vIEFkaWNpb25hciBjYXJ0YSBhb3MgZmF2b3JpdG9zXG4gIGNvbnN0IGFkZEZhdm9yaXRlID0gYXN5bmMgKGNhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmYXZvcml0ZVNlcnZpY2UuYWRkKGNhcmQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldEZhdm9yaXRlcyhwcmV2ID0+IFsuLi5wcmV2LCBjYXJkXSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gYWRpY2lvbmFyIGZhdm9yaXRvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiB7XG4gICAgICAgIGlmIChwcmV2LnNvbWUoYyA9PiBjLmlkID09PSBjYXJkLmlkKSkgcmV0dXJuIHByZXY7XG4gICAgICAgIHJldHVybiBbLi4ucHJldiwgY2FyZF07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlciBjYXJ0YSBkb3MgZmF2b3JpdG9zXG4gIGNvbnN0IHJlbW92ZUZhdm9yaXRlID0gYXN5bmMgKGNhcmRJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmF2b3JpdGVTZXJ2aWNlLnJlbW92ZUNhcmQoY2FyZElkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiBwcmV2LmZpbHRlcihjYXJkID0+IGNhcmQuaWQgIT09IGNhcmRJZCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlbW92ZXIgZmF2b3JpdG86JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldEZhdm9yaXRlcyhwcmV2ID0+IHByZXYuZmlsdGVyKGNhcmQgPT4gY2FyZC5pZCAhPT0gY2FyZElkKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFZlcmlmaWNhciBzZSB1bWEgY2FydGEgZXN0w6Egbm9zIGZhdm9yaXRvc1xuICBjb25zdCBpc0Zhdm9yaXRlID0gKGNhcmRJZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIGZhdm9yaXRlcy5zb21lKGNhcmQgPT4gY2FyZC5pZCA9PT0gY2FyZElkKTtcbiAgfTtcblxuICAvLyBGdW7Dp8OjbyBwYXJhIGV4cG9ydGFyIGNvbGXDp8OjbyBwYXJhIENTViBubyBmb3JtYXRvIE1hbmFib3hcbiAgY29uc3QgZXhwb3J0Q29sbGVjdGlvblRvQ1NWID0gKGNvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uKSA9PiB7XG4gICAgLy8gRm9ybWF0byBNYW5hYm94OiBOYW1lLFNldCxRdWFudGl0eSxGb2lsLENvbmRpdGlvbixMYW5ndWFnZVxuICAgIGNvbnN0IGNzdkNvbnRlbnQgPSBbXG4gICAgICBbJ05hbWUnLCAnU2V0JywgJ1F1YW50aXR5JywgJ0ZvaWwnLCAnQ29uZGl0aW9uJywgJ0xhbmd1YWdlJ10sXG4gICAgICAuLi5jb2xsZWN0aW9uLmNhcmRzLm1hcChjID0+IFtcbiAgICAgICAgYy5jYXJkLm5hbWUsXG4gICAgICAgIGMuY2FyZC5zZXRfY29kZSxcbiAgICAgICAgYy5xdWFudGl0eS50b1N0cmluZygpLFxuICAgICAgICBjLmZvaWwgPyAnRm9pbCcgOiAnTm9uLWZvaWwnLFxuICAgICAgICBjLmNvbmRpdGlvbiB8fCAnTmVhciBNaW50JyxcbiAgICAgICAgYy5sYW5ndWFnZSB8fCAnRW5nbGlzaCdcbiAgICAgIF0pXG4gICAgXS5tYXAocm93ID0+IHJvdy5qb2luKCcsJykpLmpvaW4oJ1xcbicpO1xuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjc3ZDb250ZW50XSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgIGNvbnN0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5ocmVmID0gdXJsO1xuICAgIGEuZG93bmxvYWQgPSBgJHtjb2xsZWN0aW9uLm5hbWV9X21hbmFib3guY3N2YDtcbiAgICBhLmNsaWNrKCk7XG4gICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxBcHBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBjb2xsZWN0aW9ucyxcbiAgICAgIGN1cnJlbnRDb2xsZWN0aW9uLFxuICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb246IHNldENvbGxlY3Rpb25zLFxuICAgICAgY3VycmVudENvbGxlY3Rpb25JZCxcbiAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQsXG4gICAgICBjcmVhdGVDb2xsZWN0aW9uLFxuICAgICAgdXBkYXRlQ29sbGVjdGlvbixcbiAgICAgIGRlbGV0ZUNvbGxlY3Rpb24sXG4gICAgICBkdXBsaWNhdGVDb2xsZWN0aW9uLFxuICAgICAgYWRpY2lvbmFyQ2FydGEsXG4gICAgICByZW1vdmVyQ2FydGEsXG4gICAgICBnZXRRdWFudGlkYWRlTmFDb2xlY2FvLFxuICAgICAgZGVja3MsXG4gICAgICBzZXREZWNrcyxcbiAgICAgIGNyaWFyRGVjayxcbiAgICAgIGVkaXRhckRlY2ssXG4gICAgICBkZWxldGFyRGVjayxcbiAgICAgIGR1cGxpY2FyRGVjayxcbiAgICAgIGFkaWNpb25hckNhcnRhQW9EZWNrLFxuICAgICAgcmVtb3ZlckNhcnRhRG9EZWNrLFxuICAgICAgYXR1YWxpemFyUXVhbnRpZGFkZU5vRGVjayxcbiAgICAgIGdldENhcnRhc1VzYWRhc0VtRGVja3MsXG4gICAgICBpbXBvcnRhckRlY2tEZUxpc3RhLFxuICAgICAgZmF2b3JpdGVzLFxuICAgICAgYWRkRmF2b3JpdGUsXG4gICAgICByZW1vdmVGYXZvcml0ZSxcbiAgICAgIGlzRmF2b3JpdGUsXG4gICAgICBsb2FkaW5nLFxuICAgICAgZXhwb3J0Q29sbGVjdGlvblRvQ1NWXG4gICAgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BcHBDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTsiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY29sbGVjdGlvblNlcnZpY2UiLCJkZWNrU2VydmljZSIsImZhdm9yaXRlU2VydmljZSIsInVzZVNlc3Npb24iLCJBcHBDb250ZXh0IiwidXNlQXBwQ29udGV4dCIsImNvbnRleHQiLCJFcnJvciIsIkFwcFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJkYXRhIiwic2Vzc2lvbiIsImNvbGxlY3Rpb25zIiwic2V0Q29sbGVjdGlvbnMiLCJjdXJyZW50Q29sbGVjdGlvbklkIiwic2V0Q3VycmVudENvbGxlY3Rpb25JZCIsImRlY2tzIiwic2V0RGVja3MiLCJmYXZvcml0ZXMiLCJzZXRGYXZvcml0ZXMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImN1cnJlbnRDb2xsZWN0aW9uIiwidXNlTWVtbyIsImZpbmQiLCJjIiwiaWQiLCJsb2FkRGF0YSIsImNvbGxlY3Rpb25zUmVzcG9uc2UiLCJnZXRBbGwiLCJzdWNjZXNzIiwibGVuZ3RoIiwiZGVja3NSZXNwb25zZSIsImZhdm9yaXRlc1Jlc3BvbnNlIiwibWFwIiwiZmF2IiwiY2FyZCIsImVycm9yIiwiY29uc29sZSIsInNhdmVkQ29sbGVjdGlvbnMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkQ29sbGVjdGlvbnMiLCJKU09OIiwicGFyc2UiLCJkZWZhdWx0Q29sbGVjdGlvbiIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImNhcmRzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwiaXNQdWJsaWMiLCJzYXZlZERlY2tzIiwicGFyc2VkRGVja3MiLCJzYXZlZEZhdm9yaXRlcyIsInBhcnNlZEZhdm9yaXRlcyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjcmVhdGVDb2xsZWN0aW9uIiwicmVzcG9uc2UiLCJjcmVhdGUiLCJwcmV2IiwibmV3Q29sbGVjdGlvbiIsIm5vdyIsInRvU3RyaW5nIiwidXBkYXRlQ29sbGVjdGlvbiIsInVwZGF0ZXMiLCJ1cGRhdGUiLCJkZWxldGVDb2xsZWN0aW9uIiwiZGVsZXRlIiwibmV3Q29sbGVjdGlvbnMiLCJmaWx0ZXIiLCJkdXBsaWNhdGVDb2xsZWN0aW9uIiwiY29sbGVjdGlvblRvRHVwbGljYXRlIiwiY2FyZEl0ZW0iLCJhZGRDYXJkIiwicXVhbnRpdHkiLCJjb25kaXRpb24iLCJmb2lsIiwibGFuZ3VhZ2UiLCJ1cGRhdGVkUmVzcG9uc2UiLCJnZXRCeUlkIiwiYWRpY2lvbmFyQ2FydGEiLCJxdWFudGlkYWRlIiwiZXhpc3RpbmdDYXJkIiwiY2MiLCJuZXdDYXJkcyIsInJlbW92ZXJDYXJ0YSIsImNvbGxlY3Rpb24iLCJjYXJkSW5Db2xsZWN0aW9uIiwidXBkYXRlQ2FyZCIsIl9pZCIsInJlbW92ZUNhcmQiLCJnZXRRdWFudGlkYWRlTmFDb2xlY2FvIiwiY2FyZElkIiwiY3JpYXJEZWNrIiwiZGVja0RhdGEiLCJuZXdEZWNrIiwibGFzdE1vZGlmaWVkIiwiZWRpdGFyRGVjayIsImRlY2tJZCIsImRlY2siLCJkZWxldGFyRGVjayIsImR1cGxpY2FyRGVjayIsIm5ld05hbWUiLCJvcmlnaW5hbERlY2siLCJ1bmRlZmluZWQiLCJuZXdEZWNrRGF0YSIsImZvcm1hdCIsImNvbG9ycyIsImlzU2lkZWJvYXJkIiwiY2F0ZWdvcnkiLCJpc0NvbW1hbmRlciIsImR1cGxpY2F0ZWREZWNrIiwiYWRpY2lvbmFyQ2FydGFBb0RlY2siLCJyZW1vdmVyQ2FydGFEb0RlY2siLCJkIiwiY2FyZEluRGVjayIsImF0dWFsaXphclF1YW50aWRhZGVOb0RlY2siLCJub3ZhUXVhbnRpZGFkZSIsImdldENhcnRhc1VzYWRhc0VtRGVja3MiLCJyZXN1bHQiLCJmb3JFYWNoIiwiZGVja0NhcmQiLCJwdXNoIiwiaW1wb3J0YXJEZWNrRGVMaXN0YSIsImRlY2tMaXN0IiwidGFncyIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwidHJpbSIsImN1cnJlbnRTZWN0aW9uIiwiY2FyZFByb21pc2VzIiwidHJpbW1lZExpbmUiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwibWF0Y2giLCJwYXJzZUludCIsImNhcmROYW1lIiwiZmV0Y2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJvayIsImNhcmREYXRhIiwianNvbiIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsImZhaWxlZENhcmRzIiwic3RhdHVzIiwidmFsdWUiLCJ3YXJuIiwiam9pbiIsImFkZEZhdm9yaXRlIiwiYWRkIiwic29tZSIsInJlbW92ZUZhdm9yaXRlIiwiaXNGYXZvcml0ZSIsImV4cG9ydENvbGxlY3Rpb25Ub0NTViIsImNzdkNvbnRlbnQiLCJzZXRfY29kZSIsInJvdyIsImJsb2IiLCJCbG9iIiwidHlwZSIsInVybCIsIndpbmRvdyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJjbGljayIsInJldm9rZU9iamVjdFVSTCIsIlByb3ZpZGVyIiwic2V0Q3VycmVudENvbGxlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/AppContext.tsx\n"));

/***/ })

});