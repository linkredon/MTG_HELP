"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./contexts/AppContext.tsx":
/*!*********************************!*\
  !*** ./contexts/AppContext.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: function() { return /* binding */ AppProvider; },\n/* harmony export */   useAppContext: function() { return /* binding */ useAppContext; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_storageUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/storageUtils */ \"(app-pages-browser)/./utils/storageUtils.ts\");\n/* harmony import */ var _utils_apiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/apiService */ \"(app-pages-browser)/./utils/apiService.ts\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ useAppContext,AppProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useAppContext = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (!context) {\n        throw new Error(\"useAppContext deve ser usado dentro de um AppProvider\");\n    }\n    return context;\n};\n_s(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst AppProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_4__.useSession)();\n    const [collections, setCollections] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCollectionId, setCurrentCollectionId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [decks, setDecks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [favorites, setFavorites] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const currentCollection = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(()=>{\n        return collections.find((c)=>c.id === currentCollectionId);\n    }, [\n        collections,\n        currentCollectionId\n    ]);\n    // Carregar dados da API quando o usuário estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (session) {\n                setLoading(true);\n                try {\n                    // Carregar coleções\n                    const collectionsResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.getAll();\n                    if (collectionsResponse.success && collectionsResponse.data) {\n                        setCollections(collectionsResponse.data);\n                        if (collectionsResponse.data.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(collectionsResponse.data[0].id);\n                        }\n                    }\n                    // Carregar decks\n                    const decksResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.getAll();\n                    if (decksResponse.success && decksResponse.data) {\n                        setDecks(decksResponse.data);\n                    }\n                    // Carregar favoritos\n                    const favoritesResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.favoriteService.getAll();\n                    if (favoritesResponse.success && favoritesResponse.data) {\n                        setFavorites(favoritesResponse.data.map((fav)=>fav.card));\n                    }\n                } catch (error) {\n                    console.error(\"Erro ao carregar dados:\", error);\n                } finally{\n                    setLoading(false);\n                }\n            } else {\n                // Usuário não autenticado, usar localStorage como fallback\n                const savedCollections = localStorage.getItem(\"mtg-collections\");\n                if (savedCollections) {\n                    try {\n                        const parsedCollections = JSON.parse(savedCollections);\n                        setCollections(parsedCollections);\n                        if (parsedCollections.length > 0 && !currentCollectionId) {\n                            setCurrentCollectionId(parsedCollections[0].id);\n                        }\n                    } catch (error) {\n                        console.error(\"Erro ao carregar cole\\xe7\\xf5es salvas:\", error);\n                    }\n                } else {\n                    // Criar uma coleção padrão se não houver nenhuma\n                    const defaultCollection = {\n                        id: \"1\",\n                        name: \"Minha Cole\\xe7\\xe3o\",\n                        description: \"Cole\\xe7\\xe3o principal de cartas Magic\",\n                        cards: [],\n                        createdAt: new Date().toISOString(),\n                        updatedAt: new Date().toISOString(),\n                        isPublic: false\n                    };\n                    setCollections([\n                        defaultCollection\n                    ]);\n                    setCurrentCollectionId(defaultCollection.id);\n                }\n                const savedDecks = localStorage.getItem(\"mtg-decks\");\n                if (savedDecks) {\n                    try {\n                        const parsedDecks = JSON.parse(savedDecks);\n                        setDecks(parsedDecks);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar decks salvos:\", error);\n                    }\n                }\n                const savedFavorites = localStorage.getItem(\"mtg-favorites\");\n                if (savedFavorites) {\n                    try {\n                        const parsedFavorites = JSON.parse(savedFavorites);\n                        setFavorites(parsedFavorites);\n                    } catch (error) {\n                        console.error(\"Erro ao carregar favoritos salvos:\", error);\n                    }\n                }\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        session\n    ]);\n    // Salvar dados no localStorage quando não estiver autenticado\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            (0,_utils_storageUtils__WEBPACK_IMPORTED_MODULE_2__.safeLocalStorageSave)(\"mtg-collections\", collections);\n        }\n    }, [\n        collections,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            (0,_utils_storageUtils__WEBPACK_IMPORTED_MODULE_2__.safeLocalStorageSave)(\"mtg-decks\", decks);\n        }\n    }, [\n        decks,\n        session\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!session) {\n            (0,_utils_storageUtils__WEBPACK_IMPORTED_MODULE_2__.safeLocalStorageSave)(\"mtg-favorites\", favorites);\n        }\n    }, [\n        favorites,\n        session\n    ]);\n    // Funções de gerenciamento de coleção\n    const createCollection = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.create({\n                    name,\n                    description\n                });\n                if (response.success && response.data) {\n                    setCollections((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    setCurrentCollectionId(response.data.id);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar cole\\xe7\\xe3o\");\n            } catch (error) {\n                console.error(\"Erro ao criar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                id: Date.now().toString(),\n                name,\n                description,\n                cards: [],\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n                isPublic: false\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n            setCurrentCollectionId(newCollection.id);\n            return newCollection.id;\n        }\n    };\n    const updateCollection = async (id, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.update(id, updates);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                                ...c,\n                                ...updates\n                            } : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>c.id === id ? {\n                        ...c,\n                        ...updates,\n                        updatedAt: new Date().toISOString()\n                    } : c));\n        }\n    };\n    const deleteCollection = async (id)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.delete(id);\n                if (response.success) {\n                    setCollections((prev)=>{\n                        const newCollections = prev.filter((c)=>c.id !== id);\n                        if (currentCollectionId === id) {\n                            setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                        }\n                        return newCollections;\n                    });\n                }\n            } catch (error) {\n                console.error(\"Erro ao excluir cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>{\n                const newCollections = prev.filter((c)=>c.id !== id);\n                if (currentCollectionId === id) {\n                    setCurrentCollectionId(newCollections.length > 0 ? newCollections[0].id : null);\n                }\n                return newCollections;\n            });\n        }\n    };\n    const duplicateCollection = async (id)=>{\n        const collectionToDuplicate = collections.find((c)=>c.id === id);\n        if (!collectionToDuplicate) return;\n        if (session) {\n            try {\n                const newCollection = {\n                    name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\"),\n                    description: collectionToDuplicate.description,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.create(newCollection);\n                if (response.success && response.data) {\n                    // Adicionar cartas à nova coleção\n                    for (const cardItem of collectionToDuplicate.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            condition: cardItem.condition,\n                            foil: cardItem.foil,\n                            language: cardItem.language\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setCollections((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Erro ao duplicar cole\\xe7\\xe3o:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newCollection = {\n                ...collectionToDuplicate,\n                id: Date.now().toString(),\n                name: \"\".concat(collectionToDuplicate.name, \" (C\\xf3pia)\")\n            };\n            setCollections((prev)=>[\n                    ...prev,\n                    newCollection\n                ]);\n        }\n    };\n    // Função para adicionar carta à coleção\n    const adicionarCarta = async function(card) {\n        let quantidade = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.addCard(currentCollectionId, {\n                    card,\n                    quantity: quantidade,\n                    condition: \"Near Mint\",\n                    foil: false,\n                    language: \"English\"\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity + quantidade\n                            } : cc);\n                    } else {\n                        newCards = [\n                            ...c.cards,\n                            {\n                                card,\n                                quantity: quantidade,\n                                condition: \"Near Mint\",\n                                foil: false\n                            }\n                        ];\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para remover carta da coleção\n    const removerCarta = async (card)=>{\n        if (!currentCollectionId) return;\n        if (session) {\n            try {\n                // Encontrar o ID da carta na coleção\n                const collection = collections.find((c)=>c.id === currentCollectionId);\n                if (!collection) return;\n                const cardInCollection = collection.cards.find((cc)=>cc.card.id === card.id);\n                if (!cardInCollection) return;\n                if (cardInCollection.quantity > 1) {\n                    // Atualizar quantidade\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.updateCard(currentCollectionId, cardInCollection._id, {\n                        quantity: cardInCollection.quantity - 1\n                    });\n                } else {\n                    // Remover carta\n                    await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.removeCard(currentCollectionId, cardInCollection._id);\n                }\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.collectionService.getById(currentCollectionId);\n                if (response.success) {\n                    setCollections((prev)=>prev.map((c)=>c.id === currentCollectionId ? response.data : c));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setCollections((prev)=>prev.map((c)=>{\n                    if (c.id !== currentCollectionId) return c;\n                    const existingCard = c.cards.find((cc)=>cc.card.id === card.id);\n                    let newCards;\n                    if (existingCard && existingCard.quantity > 1) {\n                        newCards = c.cards.map((cc)=>cc.card.id === card.id ? {\n                                ...cc,\n                                quantity: cc.quantity - 1\n                            } : cc);\n                    } else {\n                        newCards = c.cards.filter((cc)=>cc.card.id !== card.id);\n                    }\n                    return {\n                        ...c,\n                        cards: newCards,\n                        updatedAt: new Date().toISOString()\n                    };\n                }));\n        }\n    };\n    // Função para obter quantidade de uma carta na coleção\n    const getQuantidadeNaColecao = (cardId)=>{\n        var _currentCollection_cards;\n        const card = currentCollection === null || currentCollection === void 0 ? void 0 : (_currentCollection_cards = currentCollection.cards) === null || _currentCollection_cards === void 0 ? void 0 : _currentCollection_cards.find((c)=>c.card.id === cardId);\n        return card ? card.quantity : 0;\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE DECKS ======\n    // Criar novo deck\n    const criarDeck = async (deckData)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.create(deckData);\n                if (response.success && response.data) {\n                    setDecks((prev)=>[\n                            ...prev,\n                            response.data\n                        ]);\n                    return response.data.id;\n                }\n                throw new Error(\"Erro ao criar deck\");\n            } catch (error) {\n                console.error(\"Erro ao criar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const newDeck = {\n                ...deckData,\n                id: Date.now().toString(),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    newDeck\n                ]);\n            return newDeck.id;\n        }\n    };\n    // Editar deck existente\n    const editarDeck = async (deckId, updates)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.update(deckId, updates);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                                ...deck,\n                                ...updates\n                            } : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao editar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? {\n                        ...deck,\n                        ...updates,\n                        lastModified: new Date().toISOString()\n                    } : deck));\n        }\n    };\n    // Deletar deck\n    const deletarDeck = async (deckId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.delete(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao deletar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.filter((deck)=>deck.id !== deckId));\n        }\n    };\n    // Duplicar deck\n    const duplicarDeck = async (deckId, newName)=>{\n        const originalDeck = decks.find((deck)=>deck.id === deckId);\n        if (!originalDeck) return undefined;\n        if (session) {\n            try {\n                const newDeckData = {\n                    name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                    description: originalDeck.description,\n                    format: originalDeck.format,\n                    colors: originalDeck.colors,\n                    isPublic: false\n                };\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.create(newDeckData);\n                if (response.success && response.data) {\n                    // Adicionar cartas ao novo deck\n                    for (const cardItem of originalDeck.cards){\n                        await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.addCard(response.data.id, {\n                            card: cardItem.card,\n                            quantity: cardItem.quantity,\n                            isSideboard: cardItem.category === \"sideboard\",\n                            isCommander: cardItem.category === \"commander\",\n                            category: cardItem.category\n                        });\n                    }\n                    // Atualizar estado local\n                    const updatedResponse = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.getById(response.data.id);\n                    if (updatedResponse.success) {\n                        setDecks((prev)=>[\n                                ...prev,\n                                updatedResponse.data\n                            ]);\n                        return updatedResponse.data.id;\n                    }\n                }\n                return undefined;\n            } catch (error) {\n                console.error(\"Erro ao duplicar deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            const duplicatedDeck = {\n                ...originalDeck,\n                id: Date.now().toString(),\n                name: newName || \"\".concat(originalDeck.name, \" (C\\xf3pia)\"),\n                createdAt: new Date().toISOString(),\n                lastModified: new Date().toISOString()\n            };\n            setDecks((prev)=>[\n                    ...prev,\n                    duplicatedDeck\n                ]);\n            return duplicatedDeck.id;\n        }\n    };\n    // Adicionar carta ao deck\n    const adicionarCartaAoDeck = async function(deckId, card) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\", quantity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        if (session) {\n            try {\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.addCard(deckId, {\n                    card,\n                    quantity,\n                    isSideboard: category === \"sideboard\",\n                    isCommander: category === \"commander\",\n                    category\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar carta ao deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        const existingCard = deck.cards.find((c)=>c.card.id === card.id && c.category === category);\n                        if (existingCard) {\n                            return {\n                                ...deck,\n                                cards: deck.cards.map((c)=>c.card.id === card.id && c.category === category ? {\n                                        ...c,\n                                        quantity: c.quantity + quantity\n                                    } : c),\n                                lastModified: new Date().toISOString()\n                            };\n                        } else {\n                            return {\n                                ...deck,\n                                cards: [\n                                    ...deck.cards,\n                                    {\n                                        card,\n                                        quantity,\n                                        category\n                                    }\n                                ],\n                                lastModified: new Date().toISOString()\n                            };\n                        }\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Remover carta do deck\n    const removerCartaDoDeck = async function(deckId, cardId) {\n        let category = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"mainboard\";\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.removeCard(deckId, cardInDeck._id);\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover carta do deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.filter((c)=>!(c.card.id === cardId && c.category === category)),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Atualizar quantidade de carta no deck\n    const atualizarQuantidadeNoDeck = async function(deckId, cardId, novaQuantidade) {\n        let category = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"mainboard\";\n        if (novaQuantidade <= 0) {\n            await removerCartaDoDeck(deckId, cardId, category);\n            return;\n        }\n        if (session) {\n            try {\n                // Encontrar o ID da carta no deck\n                const deck = decks.find((d)=>d.id === deckId);\n                if (!deck) return;\n                const cardInDeck = deck.cards.find((c)=>c.card.id === cardId && c.category === category);\n                if (!cardInDeck) return;\n                await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.updateCard(deckId, cardInDeck._id, {\n                    quantity: novaQuantidade\n                });\n                // Atualizar estado local\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.deckService.getById(deckId);\n                if (response.success) {\n                    setDecks((prev)=>prev.map((deck)=>deck.id === deckId ? response.data : deck));\n                }\n            } catch (error) {\n                console.error(\"Erro ao atualizar quantidade no deck:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setDecks((prev)=>prev.map((deck)=>{\n                    if (deck.id === deckId) {\n                        return {\n                            ...deck,\n                            cards: deck.cards.map((c)=>c.card.id === cardId && c.category === category ? {\n                                    ...c,\n                                    quantity: novaQuantidade\n                                } : c),\n                            lastModified: new Date().toISOString()\n                        };\n                    }\n                    return deck;\n                }));\n        }\n    };\n    // Obter cartas que estão sendo usadas em decks\n    const getCartasUsadasEmDecks = (cardId)=>{\n        const result = [];\n        decks.forEach((deck)=>{\n            deck.cards.forEach((deckCard)=>{\n                if (deckCard.card.id === cardId) {\n                    result.push({\n                        deck,\n                        quantity: deckCard.quantity,\n                        category: deckCard.category\n                    });\n                }\n            });\n        });\n        return result;\n    };\n    // Função para importar deck a partir de uma lista de texto\n    const importarDeckDeLista = async (deckList, deckData)=>{\n        try {\n            // Criar o deck vazio primeiro\n            const deckId = await criarDeck({\n                name: deckData.name,\n                format: deckData.format,\n                description: deckData.description || \"\",\n                colors: deckData.colors || [],\n                cards: [],\n                isPublic: deckData.isPublic || false,\n                tags: deckData.tags || []\n            });\n            // Processar a lista de cartas\n            const lines = deckList.split(\"\\n\").filter((line)=>line.trim());\n            let currentSection = \"mainboard\";\n            const cardPromises = [];\n            for (const line of lines){\n                const trimmedLine = line.trim().toLowerCase();\n                // Verificar se é uma linha de seção\n                if (trimmedLine.includes(\"sideboard\")) {\n                    currentSection = \"sideboard\";\n                    continue;\n                }\n                if (trimmedLine.includes(\"commander\")) {\n                    currentSection = \"commander\";\n                    continue;\n                }\n                if (trimmedLine.includes(\"mainboard\") || trimmedLine.includes(\"main deck\")) {\n                    currentSection = \"mainboard\";\n                    continue;\n                }\n                // Verificar se é uma linha de carta\n                const match = line.match(/^(\\d+)x?\\s+(.+)$/);\n                if (match) {\n                    const quantity = parseInt(match[1]);\n                    const cardName = match[2].trim();\n                    // Buscar a carta na API do Scryfall\n                    cardPromises.push((async ()=>{\n                        try {\n                            const response = await fetch(\"https://api.scryfall.com/cards/named?fuzzy=\".concat(encodeURIComponent(cardName)));\n                            if (response.ok) {\n                                const cardData = await response.json();\n                                // Adicionar a carta ao deck\n                                await adicionarCartaAoDeck(deckId, cardData, currentSection, quantity);\n                                return {\n                                    success: true,\n                                    card: cardName\n                                };\n                            } else {\n                                console.error(\"Carta n\\xe3o encontrada: \".concat(cardName));\n                                return {\n                                    success: false,\n                                    card: cardName\n                                };\n                            }\n                        } catch (error) {\n                            console.error(\"Erro ao buscar carta \".concat(cardName, \":\"), error);\n                            return {\n                                success: false,\n                                card: cardName\n                            };\n                        }\n                    })());\n                }\n            }\n            // Aguardar todas as cartas serem processadas\n            const results = await Promise.allSettled(cardPromises);\n            const failedCards = results.filter((result)=>result.status === \"fulfilled\" && !result.value.success).map((result)=>result.status === \"fulfilled\" ? result.value.card : \"Unknown\");\n            if (failedCards.length > 0) {\n                console.warn(\"Algumas cartas n\\xe3o foram encontradas: \".concat(failedCards.join(\", \")));\n            }\n            return deckId;\n        } catch (error) {\n            console.error(\"Erro ao importar deck:\", error);\n            throw new Error(\"Falha ao importar deck. Verifique o formato da lista.\");\n        }\n    };\n    // ====== FUNÇÕES DE GERENCIAMENTO DE FAVORITOS ======\n    // Adicionar carta aos favoritos\n    const addFavorite = async (card)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.favoriteService.add(card);\n                if (response.success) {\n                    setFavorites((prev)=>[\n                            ...prev,\n                            card\n                        ]);\n                }\n            } catch (error) {\n                console.error(\"Erro ao adicionar favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>{\n                if (prev.some((c)=>c.id === card.id)) return prev;\n                return [\n                    ...prev,\n                    card\n                ];\n            });\n        }\n    };\n    // Remover carta dos favoritos\n    const removeFavorite = async (cardId)=>{\n        if (session) {\n            try {\n                const response = await _utils_apiService__WEBPACK_IMPORTED_MODULE_3__.favoriteService.removeCard(cardId);\n                if (response.success) {\n                    setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n                }\n            } catch (error) {\n                console.error(\"Erro ao remover favorito:\", error);\n                throw error;\n            }\n        } else {\n            // Fallback para localStorage\n            setFavorites((prev)=>prev.filter((card)=>card.id !== cardId));\n        }\n    };\n    // Verificar se uma carta está nos favoritos\n    const isFavorite = (cardId)=>{\n        return favorites.some((card)=>card.id === cardId);\n    };\n    // Função para exportar coleção para CSV no formato Manabox\n    const exportCollectionToCSV = (collection)=>{\n        // Formato Manabox: Name,Set,Quantity,Foil,Condition,Language\n        const csvContent = [\n            [\n                \"Name\",\n                \"Set\",\n                \"Quantity\",\n                \"Foil\",\n                \"Condition\",\n                \"Language\"\n            ],\n            ...collection.cards.map((c)=>[\n                    c.card.name,\n                    c.card.set_code,\n                    c.quantity.toString(),\n                    c.foil ? \"Foil\" : \"Non-foil\",\n                    c.condition || \"Near Mint\",\n                    c.language || \"English\"\n                ])\n        ].map((row)=>row.join(\",\")).join(\"\\n\");\n        const blob = new Blob([\n            csvContent\n        ], {\n            type: \"text/csv\"\n        });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.href = url;\n        a.download = \"\".concat(collection.name, \"_manabox.csv\");\n        a.click();\n        window.URL.revokeObjectURL(url);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: {\n            collections,\n            currentCollection,\n            setCurrentCollection: setCollections,\n            currentCollectionId,\n            setCurrentCollectionId,\n            createCollection,\n            updateCollection,\n            deleteCollection,\n            duplicateCollection,\n            adicionarCarta,\n            removerCarta,\n            getQuantidadeNaColecao,\n            decks,\n            setDecks,\n            criarDeck,\n            editarDeck,\n            deletarDeck,\n            duplicarDeck,\n            adicionarCartaAoDeck,\n            removerCartaDoDeck,\n            atualizarQuantidadeNoDeck,\n            getCartasUsadasEmDecks,\n            importarDeckDeLista,\n            favorites,\n            addFavorite,\n            removeFavorite,\n            isFavorite,\n            loading,\n            exportCollectionToCSV\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Rodrigo\\\\Downloads\\\\MTG HELP\\\\contexts\\\\AppContext.tsx\",\n        lineNumber: 857,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(AppProvider, \"P5slHoOyqMDp2BOUreOP8tfxRtM=\", false, function() {\n    return [\n        next_auth_react__WEBPACK_IMPORTED_MODULE_4__.useSession\n    ];\n});\n_c = AppProvider;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL0FwcENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRXlGO0FBQzdCO0FBRXlCO0FBQ3hDO0FBMEM3QyxNQUFNVSwyQkFBYVQsb0RBQWFBLENBQXdCO0FBRWpELE1BQU1VLGdCQUFnQjs7SUFDM0IsTUFBTUMsVUFBVVYsaURBQVVBLENBQUNRO0lBQzNCLElBQUksQ0FBQ0UsU0FBUztRQUNaLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9EO0FBQ1QsRUFBRTtHQU5XRDtBQVlOLE1BQU1HLGNBQTBDO1FBQUMsRUFBRUMsUUFBUSxFQUFFOztJQUNsRSxNQUFNLEVBQUVDLE1BQU1DLE9BQU8sRUFBRSxHQUFHUiwyREFBVUE7SUFDcEMsTUFBTSxDQUFDUyxhQUFhQyxlQUFlLEdBQUdoQiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUNuRSxNQUFNLENBQUNpQixxQkFBcUJDLHVCQUF1QixHQUFHbEIsK0NBQVFBLENBQWdCO0lBQzlFLE1BQU0sQ0FBQ21CLE9BQU9DLFNBQVMsR0FBR3BCLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDcUIsV0FBV0MsYUFBYSxHQUFHdEIsK0NBQVFBLENBQVksRUFBRTtJQUN4RCxNQUFNLENBQUN1QixTQUFTQyxXQUFXLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUV2QyxNQUFNeUIsb0JBQW9CNUIsb0RBQWEsQ0FBQztRQUN0QyxPQUFPa0IsWUFBWVksSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaO0lBQ3hDLEdBQUc7UUFBQ0Y7UUFBYUU7S0FBb0I7SUFFckMsNkRBQTZEO0lBQzdEaEIsZ0RBQVNBLENBQUM7UUFDUixNQUFNNkIsV0FBVztZQUNmLElBQUloQixTQUFTO2dCQUNYVSxXQUFXO2dCQUNYLElBQUk7b0JBQ0Ysb0JBQW9CO29CQUNwQixNQUFNTyxzQkFBc0IsTUFBTTVCLGdFQUFpQkEsQ0FBQzZCLE1BQU07b0JBQzFE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TTtZQUNBN0U7WUFDQUM7WUFDQThFO1lBQ0FJO1lBQ0FHO1lBQ0FDO1lBQ0FXO1lBQ0FDO1lBQ0FHO1lBQ0FFO1lBQ0FLO1lBQ0EzRztZQUNBdUk7WUFDQUc7WUFDQUM7WUFDQXpJO1lBQ0EwSTtRQUNGO2tCQUNHcko7Ozs7OztBQUdQLEVBQUU7SUE1ekJXRDs7UUFDZUwsdURBQVVBOzs7S0FEekJLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHRzL0FwcENvbnRleHQudHN4PzI1MGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzYWZlTG9jYWxTdG9yYWdlU2F2ZSB9IGZyb20gJ0AvdXRpbHMvc3RvcmFnZVV0aWxzJztcbmltcG9ydCB0eXBlIHsgTVRHQ2FyZCwgVXNlckNvbGxlY3Rpb24sIENvbGxlY3Rpb25DYXJkLCBEZWNrLCBEZWNrQ2FyZCB9IGZyb20gJ0AvdHlwZXMvbXRnJztcbmltcG9ydCB7IGNvbGxlY3Rpb25TZXJ2aWNlLCBkZWNrU2VydmljZSwgZmF2b3JpdGVTZXJ2aWNlIH0gZnJvbSAnQC91dGlscy9hcGlTZXJ2aWNlJztcbmltcG9ydCB7IHVzZVNlc3Npb24gfSBmcm9tICduZXh0LWF1dGgvcmVhY3QnO1xuXG5pbnRlcmZhY2UgQXBwQ29udGV4dFR5cGUge1xuICBjb2xsZWN0aW9uczogVXNlckNvbGxlY3Rpb25bXTtcbiAgY3VycmVudENvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uIHwgdW5kZWZpbmVkO1xuICBzZXRDdXJyZW50Q29sbGVjdGlvbjogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248VXNlckNvbGxlY3Rpb25bXT4+O1xuICBjdXJyZW50Q29sbGVjdGlvbklkOiBzdHJpbmcgfCBudWxsO1xuICBzZXRDdXJyZW50Q29sbGVjdGlvbklkOiAoaWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIGNyZWF0ZUNvbGxlY3Rpb246IChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIHVwZGF0ZUNvbGxlY3Rpb246IChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFVzZXJDb2xsZWN0aW9uPikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGVsZXRlQ29sbGVjdGlvbjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGR1cGxpY2F0ZUNvbGxlY3Rpb246IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhZGljaW9uYXJDYXJ0YTogKGNhcmQ6IE1UR0NhcmQsIHF1YW50aWRhZGU/OiBudW1iZXIpID0+IFByb21pc2U8dm9pZD47XG4gIHJlbW92ZXJDYXJ0YTogKGNhcmQ6IE1UR0NhcmQpID0+IFByb21pc2U8dm9pZD47XG4gIGdldFF1YW50aWRhZGVOYUNvbGVjYW86IChjYXJkSWQ6IHN0cmluZykgPT4gbnVtYmVyO1xuICBcbiAgLy8gR2VyZW5jaWFtZW50byBkZSBEZWNrc1xuICBkZWNrczogRGVja1tdO1xuICBzZXREZWNrczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248RGVja1tdPj47XG4gIGNyaWFyRGVjazogKGRlY2s6IE9taXQ8RGVjaywgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ2xhc3RNb2RpZmllZCc+KSA9PiBQcm9taXNlPHN0cmluZz47XG4gIGVkaXRhckRlY2s6IChkZWNrSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxEZWNrPikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGVsZXRhckRlY2s6IChkZWNrSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZHVwbGljYXJEZWNrOiAoZGVja0lkOiBzdHJpbmcsIG5ld05hbWU/OiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPjtcbiAgYWRpY2lvbmFyQ2FydGFBb0RlY2s6IChkZWNrSWQ6IHN0cmluZywgY2FyZDogTVRHQ2FyZCwgY2F0ZWdvcnk/OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicsIHF1YW50aXR5PzogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZW1vdmVyQ2FydGFEb0RlY2s6IChkZWNrSWQ6IHN0cmluZywgY2FyZElkOiBzdHJpbmcsIGNhdGVnb3J5PzogJ21haW5ib2FyZCcgfCAnc2lkZWJvYXJkJyB8ICdjb21tYW5kZXInKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBhdHVhbGl6YXJRdWFudGlkYWRlTm9EZWNrOiAoZGVja0lkOiBzdHJpbmcsIGNhcmRJZDogc3RyaW5nLCBub3ZhUXVhbnRpZGFkZTogbnVtYmVyLCBjYXRlZ29yeT86ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZ2V0Q2FydGFzVXNhZGFzRW1EZWNrczogKGNhcmRJZDogc3RyaW5nKSA9PiBBcnJheTx7ZGVjazogRGVjaywgcXVhbnRpdHk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZ30+O1xuICBpbXBvcnRhckRlY2tEZUxpc3RhOiAoZGVja0xpc3Q6IHN0cmluZywgZGVja0RhdGE6IGFueSkgPT4gUHJvbWlzZTxzdHJpbmc+O1xuICBcbiAgLy8gRmF2b3JpdG9zXG4gIGZhdm9yaXRlczogTVRHQ2FyZFtdO1xuICBhZGRGYXZvcml0ZTogKGNhcmQ6IE1UR0NhcmQpID0+IFByb21pc2U8dm9pZD47XG4gIHJlbW92ZUZhdm9yaXRlOiAoY2FyZElkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGlzRmF2b3JpdGU6IChjYXJkSWQ6IHN0cmluZykgPT4gYm9vbGVhbjtcbiAgXG4gIC8vIEVzdGFkbyBkZSBjYXJyZWdhbWVudG9cbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgXG4gIC8vIEV4cG9ydGHDp8Ojb1xuICBleHBvcnRDb2xsZWN0aW9uVG9DU1Y6IChjb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbikgPT4gdm9pZDtcbn1cblxuY29uc3QgQXBwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXBwQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuZXhwb3J0IGNvbnN0IHVzZUFwcENvbnRleHQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUFwcENvbnRleHQgZGV2ZSBzZXIgdXNhZG8gZGVudHJvIGRlIHVtIEFwcFByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5pbnRlcmZhY2UgQXBwUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBjb25zdCBBcHBQcm92aWRlcjogUmVhY3QuRkM8QXBwUHJvdmlkZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xuICBjb25zdCBbY29sbGVjdGlvbnMsIHNldENvbGxlY3Rpb25zXSA9IHVzZVN0YXRlPFVzZXJDb2xsZWN0aW9uW10+KFtdKTtcbiAgY29uc3QgW2N1cnJlbnRDb2xsZWN0aW9uSWQsIHNldEN1cnJlbnRDb2xsZWN0aW9uSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtkZWNrcywgc2V0RGVja3NdID0gdXNlU3RhdGU8RGVja1tdPihbXSk7XG4gIGNvbnN0IFtmYXZvcml0ZXMsIHNldEZhdm9yaXRlc10gPSB1c2VTdGF0ZTxNVEdDYXJkW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgY29uc3QgY3VycmVudENvbGxlY3Rpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY29sbGVjdGlvbnMuZmluZChjID0+IGMuaWQgPT09IGN1cnJlbnRDb2xsZWN0aW9uSWQpO1xuICB9LCBbY29sbGVjdGlvbnMsIGN1cnJlbnRDb2xsZWN0aW9uSWRdKTtcblxuICAvLyBDYXJyZWdhciBkYWRvcyBkYSBBUEkgcXVhbmRvIG8gdXN1w6FyaW8gZXN0aXZlciBhdXRlbnRpY2Fkb1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDYXJyZWdhciBjb2xlw6fDtWVzXG4gICAgICAgICAgY29uc3QgY29sbGVjdGlvbnNSZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEFsbCgpO1xuICAgICAgICAgIGlmIChjb2xsZWN0aW9uc1Jlc3BvbnNlLnN1Y2Nlc3MgJiYgY29sbGVjdGlvbnNSZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhjb2xsZWN0aW9uc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25zUmVzcG9uc2UuZGF0YS5sZW5ndGggPiAwICYmICFjdXJyZW50Q29sbGVjdGlvbklkKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQoY29sbGVjdGlvbnNSZXNwb25zZS5kYXRhWzBdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYXJyZWdhciBkZWNrc1xuICAgICAgICAgIGNvbnN0IGRlY2tzUmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5nZXRBbGwoKTtcbiAgICAgICAgICBpZiAoZGVja3NSZXNwb25zZS5zdWNjZXNzICYmIGRlY2tzUmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgc2V0RGVja3MoZGVja3NSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYXJyZWdhciBmYXZvcml0b3NcbiAgICAgICAgICBjb25zdCBmYXZvcml0ZXNSZXNwb25zZSA9IGF3YWl0IGZhdm9yaXRlU2VydmljZS5nZXRBbGwoKTtcbiAgICAgICAgICBpZiAoZmF2b3JpdGVzUmVzcG9uc2Uuc3VjY2VzcyAmJiBmYXZvcml0ZXNSZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICBzZXRGYXZvcml0ZXMoZmF2b3JpdGVzUmVzcG9uc2UuZGF0YS5tYXAoKGZhdjogYW55KSA9PiBmYXYuY2FyZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhcnJlZ2FyIGRhZG9zOicsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXN1w6FyaW8gbsOjbyBhdXRlbnRpY2FkbywgdXNhciBsb2NhbFN0b3JhZ2UgY29tbyBmYWxsYmFja1xuICAgICAgICBjb25zdCBzYXZlZENvbGxlY3Rpb25zID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ210Zy1jb2xsZWN0aW9ucycpO1xuICAgICAgICBpZiAoc2F2ZWRDb2xsZWN0aW9ucykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRDb2xsZWN0aW9ucyA9IEpTT04ucGFyc2Uoc2F2ZWRDb2xsZWN0aW9ucyk7XG4gICAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwYXJzZWRDb2xsZWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAocGFyc2VkQ29sbGVjdGlvbnMubGVuZ3RoID4gMCAmJiAhY3VycmVudENvbGxlY3Rpb25JZCkge1xuICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKHBhcnNlZENvbGxlY3Rpb25zWzBdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBjb2xlw6fDtWVzIHNhbHZhczonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENyaWFyIHVtYSBjb2xlw6fDo28gcGFkcsOjbyBzZSBuw6NvIGhvdXZlciBuZW5odW1hXG4gICAgICAgICAgY29uc3QgZGVmYXVsdENvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uID0ge1xuICAgICAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgICAgIG5hbWU6ICdNaW5oYSBDb2xlw6fDo28nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdDb2xlw6fDo28gcHJpbmNpcGFsIGRlIGNhcnRhcyBNYWdpYycsXG4gICAgICAgICAgICBjYXJkczogW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaXNQdWJsaWM6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhbZGVmYXVsdENvbGxlY3Rpb25dKTtcbiAgICAgICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKGRlZmF1bHRDb2xsZWN0aW9uLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNhdmVkRGVja3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXRnLWRlY2tzJyk7XG4gICAgICAgIGlmIChzYXZlZERlY2tzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERlY2tzID0gSlNPTi5wYXJzZShzYXZlZERlY2tzKTtcbiAgICAgICAgICAgIHNldERlY2tzKHBhcnNlZERlY2tzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYXJyZWdhciBkZWNrcyBzYWx2b3M6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNhdmVkRmF2b3JpdGVzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ210Zy1mYXZvcml0ZXMnKTtcbiAgICAgICAgaWYgKHNhdmVkRmF2b3JpdGVzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEZhdm9yaXRlcyA9IEpTT04ucGFyc2Uoc2F2ZWRGYXZvcml0ZXMpO1xuICAgICAgICAgICAgc2V0RmF2b3JpdGVzKHBhcnNlZEZhdm9yaXRlcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY2FycmVnYXIgZmF2b3JpdG9zIHNhbHZvczonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZERhdGEoKTtcbiAgfSwgW3Nlc3Npb25dKTtcblxuICAvLyBTYWx2YXIgZGFkb3Mgbm8gbG9jYWxTdG9yYWdlIHF1YW5kbyBuw6NvIGVzdGl2ZXIgYXV0ZW50aWNhZG9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHNhZmVMb2NhbFN0b3JhZ2VTYXZlKCdtdGctY29sbGVjdGlvbnMnLCBjb2xsZWN0aW9ucyk7XG4gICAgfVxuICB9LCBbY29sbGVjdGlvbnMsIHNlc3Npb25dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgc2FmZUxvY2FsU3RvcmFnZVNhdmUoJ210Zy1kZWNrcycsIGRlY2tzKTtcbiAgICB9XG4gIH0sIFtkZWNrcywgc2Vzc2lvbl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICBzYWZlTG9jYWxTdG9yYWdlU2F2ZSgnbXRnLWZhdm9yaXRlcycsIGZhdm9yaXRlcyk7XG4gICAgfVxuICB9LCBbZmF2b3JpdGVzLCBzZXNzaW9uXSk7XG5cbiAgLy8gRnVuw6fDtWVzIGRlIGdlcmVuY2lhbWVudG8gZGUgY29sZcOnw6NvXG4gIGNvbnN0IGNyZWF0ZUNvbGxlY3Rpb24gPSBhc3luYyAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nID0gJycpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmNyZWF0ZSh7IG5hbWUsIGRlc2NyaXB0aW9uIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBbLi4ucHJldiwgcmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQocmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvIGFvIGNyaWFyIGNvbGXDp8OjbycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjcmlhciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uID0ge1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgY2FyZHM6IFtdLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGlzUHVibGljOiBmYWxzZSxcbiAgICAgIH07XG4gICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdDb2xsZWN0aW9uXSk7XG4gICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkKG5ld0NvbGxlY3Rpb24uaWQpO1xuICAgICAgcmV0dXJuIG5ld0NvbGxlY3Rpb24uaWQ7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZUNvbGxlY3Rpb24gPSBhc3luYyAoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxVc2VyQ29sbGVjdGlvbj4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS51cGRhdGUoaWQsIHVwZGF0ZXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBpZCA/IHsgLi4uYywgLi4udXBkYXRlcyB9IDogYykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGF0dWFsaXphciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBpZCA/IHsgLi4uYywgLi4udXBkYXRlcywgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSA6IGMpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZGVsZXRlQ29sbGVjdGlvbiA9IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuZGVsZXRlKGlkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb25zID0gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBpZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbGxlY3Rpb25JZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudENvbGxlY3Rpb25JZChuZXdDb2xsZWN0aW9ucy5sZW5ndGggPiAwID8gbmV3Q29sbGVjdGlvbnNbMF0uaWQgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdDb2xsZWN0aW9ucztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBleGNsdWlyIGNvbGXDp8OjbzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb25zID0gcHJldi5maWx0ZXIoYyA9PiBjLmlkICE9PSBpZCk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sbGVjdGlvbklkID09PSBpZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uSWQobmV3Q29sbGVjdGlvbnMubGVuZ3RoID4gMCA/IG5ld0NvbGxlY3Rpb25zWzBdLmlkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0NvbGxlY3Rpb25zO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGR1cGxpY2F0ZUNvbGxlY3Rpb24gPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25Ub0R1cGxpY2F0ZSA9IGNvbGxlY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgaWYgKCFjb2xsZWN0aW9uVG9EdXBsaWNhdGUpIHJldHVybjtcblxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aW9uID0ge1xuICAgICAgICAgIG5hbWU6IGAke2NvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGNvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICBpc1B1YmxpYzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29sbGVjdGlvblNlcnZpY2UuY3JlYXRlKG5ld0NvbGxlY3Rpb24pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgLy8gQWRpY2lvbmFyIGNhcnRhcyDDoCBub3ZhIGNvbGXDp8Ojb1xuICAgICAgICAgIGZvciAoY29uc3QgY2FyZEl0ZW0gb2YgY29sbGVjdGlvblRvRHVwbGljYXRlLmNhcmRzKSB7XG4gICAgICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5hZGRDYXJkKHJlc3BvbnNlLmRhdGEuaWQsIHtcbiAgICAgICAgICAgICAgY2FyZDogY2FyZEl0ZW0uY2FyZCxcbiAgICAgICAgICAgICAgcXVhbnRpdHk6IGNhcmRJdGVtLnF1YW50aXR5LFxuICAgICAgICAgICAgICBjb25kaXRpb246IGNhcmRJdGVtLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgZm9pbDogY2FyZEl0ZW0uZm9pbCxcbiAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGNhcmRJdGVtLmxhbmd1YWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEJ5SWQocmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRSZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXRDb2xsZWN0aW9ucyhwcmV2ID0+IFsuLi5wcmV2LCB1cGRhdGVkUmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBkdXBsaWNhciBjb2xlw6fDo286JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IG5ld0NvbGxlY3Rpb246IFVzZXJDb2xsZWN0aW9uID0ge1xuICAgICAgICAuLi5jb2xsZWN0aW9uVG9EdXBsaWNhdGUsXG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IGAke2NvbGxlY3Rpb25Ub0R1cGxpY2F0ZS5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICB9O1xuICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBbLi4ucHJldiwgbmV3Q29sbGVjdGlvbl0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW7Dp8OjbyBwYXJhIGFkaWNpb25hciBjYXJ0YSDDoCBjb2xlw6fDo29cbiAgY29uc3QgYWRpY2lvbmFyQ2FydGEgPSBhc3luYyAoY2FyZDogTVRHQ2FyZCwgcXVhbnRpZGFkZTogbnVtYmVyID0gMSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghY3VycmVudENvbGxlY3Rpb25JZCkgcmV0dXJuO1xuICAgIFxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5hZGRDYXJkKGN1cnJlbnRDb2xsZWN0aW9uSWQsIHtcbiAgICAgICAgICBjYXJkLFxuICAgICAgICAgIHF1YW50aXR5OiBxdWFudGlkYWRlLFxuICAgICAgICAgIGNvbmRpdGlvbjogJ05lYXIgTWludCcsXG4gICAgICAgICAgZm9pbDogZmFsc2UsXG4gICAgICAgICAgbGFuZ3VhZ2U6ICdFbmdsaXNoJ1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dWFsaXphciBlc3RhZG8gbG9jYWxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5nZXRCeUlkKGN1cnJlbnRDb2xsZWN0aW9uSWQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBjdXJyZW50Q29sbGVjdGlvbklkID8gcmVzcG9uc2UuZGF0YSA6IGMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgY2FydGE6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiB7XG4gICAgICAgIGlmIChjLmlkICE9PSBjdXJyZW50Q29sbGVjdGlvbklkKSByZXR1cm4gYztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FyZCA9IGMuY2FyZHMuZmluZChjYyA9PiBjYy5jYXJkLmlkID09PSBjYXJkLmlkKTtcbiAgICAgICAgbGV0IG5ld0NhcmRzO1xuICAgICAgICBpZiAoZXhpc3RpbmdDYXJkKSB7XG4gICAgICAgICAgbmV3Q2FyZHMgPSBjLmNhcmRzLm1hcChjYyA9PlxuICAgICAgICAgICAgY2MuY2FyZC5pZCA9PT0gY2FyZC5pZFxuICAgICAgICAgICAgICA/IHsgLi4uY2MsIHF1YW50aXR5OiBjYy5xdWFudGl0eSArIHF1YW50aWRhZGUgfVxuICAgICAgICAgICAgICA6IGNjXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDYXJkcyA9IFsuLi5jLmNhcmRzLCB7XG4gICAgICAgICAgICBjYXJkLFxuICAgICAgICAgICAgcXVhbnRpdHk6IHF1YW50aWRhZGUsXG4gICAgICAgICAgICBjb25kaXRpb246ICdOZWFyIE1pbnQnLFxuICAgICAgICAgICAgZm9pbDogZmFsc2VcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5jLCBjYXJkczogbmV3Q2FyZHMsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH07XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bsOnw6NvIHBhcmEgcmVtb3ZlciBjYXJ0YSBkYSBjb2xlw6fDo29cbiAgY29uc3QgcmVtb3ZlckNhcnRhID0gYXN5bmMgKGNhcmQ6IE1UR0NhcmQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIWN1cnJlbnRDb2xsZWN0aW9uSWQpIHJldHVybjtcbiAgICBcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5jb250cmFyIG8gSUQgZGEgY2FydGEgbmEgY29sZcOnw6NvXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gY3VycmVudENvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FyZEluQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uY2FyZHMuZmluZChjYyA9PiBjYy5jYXJkLmlkID09PSBjYXJkLmlkKTtcbiAgICAgICAgaWYgKCFjYXJkSW5Db2xsZWN0aW9uKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FyZEluQ29sbGVjdGlvbi5xdWFudGl0eSA+IDEpIHtcbiAgICAgICAgICAvLyBBdHVhbGl6YXIgcXVhbnRpZGFkZVxuICAgICAgICAgIGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLnVwZGF0ZUNhcmQoY3VycmVudENvbGxlY3Rpb25JZCwgY2FyZEluQ29sbGVjdGlvbi5faWQsIHtcbiAgICAgICAgICAgIHF1YW50aXR5OiBjYXJkSW5Db2xsZWN0aW9uLnF1YW50aXR5IC0gMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZXIgY2FydGFcbiAgICAgICAgICBhd2FpdCBjb2xsZWN0aW9uU2VydmljZS5yZW1vdmVDYXJkKGN1cnJlbnRDb2xsZWN0aW9uSWQsIGNhcmRJbkNvbGxlY3Rpb24uX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbGxlY3Rpb25TZXJ2aWNlLmdldEJ5SWQoY3VycmVudENvbGxlY3Rpb25JZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0Q29sbGVjdGlvbnMocHJldiA9PiBwcmV2Lm1hcChjID0+IGMuaWQgPT09IGN1cnJlbnRDb2xsZWN0aW9uSWQgPyByZXNwb25zZS5kYXRhIDogYykpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlbW92ZXIgY2FydGE6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldENvbGxlY3Rpb25zKHByZXYgPT4gcHJldi5tYXAoYyA9PiB7XG4gICAgICAgIGlmIChjLmlkICE9PSBjdXJyZW50Q29sbGVjdGlvbklkKSByZXR1cm4gYztcblxuICAgICAgICBjb25zdCBleGlzdGluZ0NhcmQgPSBjLmNhcmRzLmZpbmQoY2MgPT4gY2MuY2FyZC5pZCA9PT0gY2FyZC5pZCk7XG4gICAgICAgIGxldCBuZXdDYXJkcztcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FyZCAmJiBleGlzdGluZ0NhcmQucXVhbnRpdHkgPiAxKSB7XG4gICAgICAgICAgbmV3Q2FyZHMgPSBjLmNhcmRzLm1hcChjYyA9PlxuICAgICAgICAgICAgY2MuY2FyZC5pZCA9PT0gY2FyZC5pZFxuICAgICAgICAgICAgICA/IHsgLi4uY2MsIHF1YW50aXR5OiBjYy5xdWFudGl0eSAtIDEgfVxuICAgICAgICAgICAgICA6IGNjXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDYXJkcyA9IGMuY2FyZHMuZmlsdGVyKGNjID0+IGNjLmNhcmQuaWQgIT09IGNhcmQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IC4uLmMsIGNhcmRzOiBuZXdDYXJkcywgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuw6fDo28gcGFyYSBvYnRlciBxdWFudGlkYWRlIGRlIHVtYSBjYXJ0YSBuYSBjb2xlw6fDo29cbiAgY29uc3QgZ2V0UXVhbnRpZGFkZU5hQ29sZWNhbyA9IChjYXJkSWQ6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgY29uc3QgY2FyZCA9IGN1cnJlbnRDb2xsZWN0aW9uPy5jYXJkcz8uZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZElkKTtcbiAgICByZXR1cm4gY2FyZCA/IGNhcmQucXVhbnRpdHkgOiAwO1xuICB9O1xuXG4gIC8vID09PT09PSBGVU7Dh8OVRVMgREUgR0VSRU5DSUFNRU5UTyBERSBERUNLUyA9PT09PT1cblxuICAvLyBDcmlhciBub3ZvIGRlY2tcbiAgY29uc3QgY3JpYXJEZWNrID0gYXN5bmMgKGRlY2tEYXRhOiBPbWl0PERlY2ssICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdsYXN0TW9kaWZpZWQnPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGVja1NlcnZpY2UuY3JlYXRlKGRlY2tEYXRhKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gWy4uLnByZXYsIHJlc3BvbnNlLmRhdGFdKTtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm8gYW8gY3JpYXIgZGVjaycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjcmlhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBuZXdEZWNrOiBEZWNrID0ge1xuICAgICAgICAuLi5kZWNrRGF0YSxcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIHNldERlY2tzKHByZXYgPT4gWy4uLnByZXYsIG5ld0RlY2tdKTtcbiAgICAgIHJldHVybiBuZXdEZWNrLmlkO1xuICAgIH1cbiAgfTtcblxuICAvLyBFZGl0YXIgZGVjayBleGlzdGVudGVcbiAgY29uc3QgZWRpdGFyRGVjayA9IGFzeW5jIChkZWNrSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxEZWNrPik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLnVwZGF0ZShkZWNrSWQsIHVwZGF0ZXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiBcbiAgICAgICAgICAgIGRlY2suaWQgPT09IGRlY2tJZCBcbiAgICAgICAgICAgICAgPyB7IC4uLmRlY2ssIC4uLnVwZGF0ZXMgfVxuICAgICAgICAgICAgICA6IGRlY2tcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBlZGl0YXIgZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IFxuICAgICAgICBkZWNrLmlkID09PSBkZWNrSWQgXG4gICAgICAgICAgPyB7IC4uLmRlY2ssIC4uLnVwZGF0ZXMsIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cbiAgICAgICAgICA6IGRlY2tcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWxldGFyIGRlY2tcbiAgY29uc3QgZGVsZXRhckRlY2sgPSBhc3luYyAoZGVja0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5kZWxldGUoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKGRlY2sgPT4gZGVjay5pZCAhPT0gZGVja0lkKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gZGVsZXRhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKGRlY2sgPT4gZGVjay5pZCAhPT0gZGVja0lkKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIER1cGxpY2FyIGRlY2tcbiAgY29uc3QgZHVwbGljYXJEZWNrID0gYXN5bmMgKGRlY2tJZDogc3RyaW5nLCBuZXdOYW1lPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbERlY2sgPSBkZWNrcy5maW5kKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkKTtcbiAgICBpZiAoIW9yaWdpbmFsRGVjaykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdEZWNrRGF0YSA9IHtcbiAgICAgICAgICBuYW1lOiBuZXdOYW1lIHx8IGAke29yaWdpbmFsRGVjay5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICAgICAgZGVzY3JpcHRpb246IG9yaWdpbmFsRGVjay5kZXNjcmlwdGlvbixcbiAgICAgICAgICBmb3JtYXQ6IG9yaWdpbmFsRGVjay5mb3JtYXQsXG4gICAgICAgICAgY29sb3JzOiBvcmlnaW5hbERlY2suY29sb3JzLFxuICAgICAgICAgIGlzUHVibGljOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNrU2VydmljZS5jcmVhdGUobmV3RGVja0RhdGEpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgLy8gQWRpY2lvbmFyIGNhcnRhcyBhbyBub3ZvIGRlY2tcbiAgICAgICAgICBmb3IgKGNvbnN0IGNhcmRJdGVtIG9mIG9yaWdpbmFsRGVjay5jYXJkcykge1xuICAgICAgICAgICAgYXdhaXQgZGVja1NlcnZpY2UuYWRkQ2FyZChyZXNwb25zZS5kYXRhLmlkLCB7XG4gICAgICAgICAgICAgIGNhcmQ6IGNhcmRJdGVtLmNhcmQsXG4gICAgICAgICAgICAgIHF1YW50aXR5OiBjYXJkSXRlbS5xdWFudGl0eSxcbiAgICAgICAgICAgICAgaXNTaWRlYm9hcmQ6IGNhcmRJdGVtLmNhdGVnb3J5ID09PSAnc2lkZWJvYXJkJyxcbiAgICAgICAgICAgICAgaXNDb21tYW5kZXI6IGNhcmRJdGVtLmNhdGVnb3J5ID09PSAnY29tbWFuZGVyJyxcbiAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhcmRJdGVtLmNhdGVnb3J5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQocmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRSZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IFsuLi5wcmV2LCB1cGRhdGVkUmVzcG9uc2UuZGF0YV0pO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRSZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBkdXBsaWNhciBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBkdXBsaWNhdGVkRGVjazogRGVjayA9IHtcbiAgICAgICAgLi4ub3JpZ2luYWxEZWNrLFxuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBuYW1lOiBuZXdOYW1lIHx8IGAke29yaWdpbmFsRGVjay5uYW1lfSAoQ8OzcGlhKWAsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgICBzZXREZWNrcyhwcmV2ID0+IFsuLi5wcmV2LCBkdXBsaWNhdGVkRGVja10pO1xuICAgICAgcmV0dXJuIGR1cGxpY2F0ZWREZWNrLmlkO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGljaW9uYXIgY2FydGEgYW8gZGVja1xuICBjb25zdCBhZGljaW9uYXJDYXJ0YUFvRGVjayA9IGFzeW5jIChcbiAgICBkZWNrSWQ6IHN0cmluZywgXG4gICAgY2FyZDogTVRHQ2FyZCwgXG4gICAgY2F0ZWdvcnk6ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnLFxuICAgIHF1YW50aXR5OiBudW1iZXIgPSAxXG4gICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBkZWNrU2VydmljZS5hZGRDYXJkKGRlY2tJZCwge1xuICAgICAgICAgIGNhcmQsXG4gICAgICAgICAgcXVhbnRpdHksXG4gICAgICAgICAgaXNTaWRlYm9hcmQ6IGNhdGVnb3J5ID09PSAnc2lkZWJvYXJkJyxcbiAgICAgICAgICBpc0NvbW1hbmRlcjogY2F0ZWdvcnkgPT09ICdjb21tYW5kZXInLFxuICAgICAgICAgIGNhdGVnb3J5XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkID8gcmVzcG9uc2UuZGF0YSA6IGRlY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhZGljaW9uYXIgY2FydGEgYW8gZGVjazonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RGVja3MocHJldiA9PiBwcmV2Lm1hcChkZWNrID0+IHtcbiAgICAgICAgaWYgKGRlY2suaWQgPT09IGRlY2tJZCkge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FyZCA9IGRlY2suY2FyZHMuZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZC5pZCAmJiBjLmNhdGVnb3J5ID09PSBjYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nQ2FyZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZGVjayxcbiAgICAgICAgICAgICAgY2FyZHM6IGRlY2suY2FyZHMubWFwKGMgPT4gXG4gICAgICAgICAgICAgICAgYy5jYXJkLmlkID09PSBjYXJkLmlkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICA/IHsgLi4uYywgcXVhbnRpdHk6IGMucXVhbnRpdHkgKyBxdWFudGl0eSB9XG4gICAgICAgICAgICAgICAgICA6IGNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmRlY2ssXG4gICAgICAgICAgICAgIGNhcmRzOiBbLi4uZGVjay5jYXJkcywgeyBjYXJkLCBxdWFudGl0eSwgY2F0ZWdvcnkgfV0sXG4gICAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaztcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlciBjYXJ0YSBkbyBkZWNrXG4gIGNvbnN0IHJlbW92ZXJDYXJ0YURvRGVjayA9IGFzeW5jIChcbiAgICBkZWNrSWQ6IHN0cmluZywgXG4gICAgY2FyZElkOiBzdHJpbmcsIFxuICAgIGNhdGVnb3J5OiAnbWFpbmJvYXJkJyB8ICdzaWRlYm9hcmQnIHwgJ2NvbW1hbmRlcicgPSAnbWFpbmJvYXJkJ1xuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5jb250cmFyIG8gSUQgZGEgY2FydGEgbm8gZGVja1xuICAgICAgICBjb25zdCBkZWNrID0gZGVja3MuZmluZChkID0+IGQuaWQgPT09IGRlY2tJZCk7XG4gICAgICAgIGlmICghZGVjaykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FyZEluRGVjayA9IGRlY2suY2FyZHMuZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZElkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KTtcbiAgICAgICAgaWYgKCFjYXJkSW5EZWNrKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBkZWNrU2VydmljZS5yZW1vdmVDYXJkKGRlY2tJZCwgY2FyZEluRGVjay5faWQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkID8gcmVzcG9uc2UuZGF0YSA6IGRlY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyByZW1vdmVyIGNhcnRhIGRvIGRlY2s6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgcGFyYSBsb2NhbFN0b3JhZ2VcbiAgICAgIHNldERlY2tzKHByZXYgPT4gcHJldi5tYXAoZGVjayA9PiB7XG4gICAgICAgIGlmIChkZWNrLmlkID09PSBkZWNrSWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGVjayxcbiAgICAgICAgICAgIGNhcmRzOiBkZWNrLmNhcmRzLmZpbHRlcihjID0+ICEoYy5jYXJkLmlkID09PSBjYXJkSWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpKSxcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjaztcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQXR1YWxpemFyIHF1YW50aWRhZGUgZGUgY2FydGEgbm8gZGVja1xuICBjb25zdCBhdHVhbGl6YXJRdWFudGlkYWRlTm9EZWNrID0gYXN5bmMgKFxuICAgIGRlY2tJZDogc3RyaW5nLCBcbiAgICBjYXJkSWQ6IHN0cmluZywgXG4gICAgbm92YVF1YW50aWRhZGU6IG51bWJlciwgXG4gICAgY2F0ZWdvcnk6ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnXG4gICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChub3ZhUXVhbnRpZGFkZSA8PSAwKSB7XG4gICAgICBhd2FpdCByZW1vdmVyQ2FydGFEb0RlY2soZGVja0lkLCBjYXJkSWQsIGNhdGVnb3J5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRW5jb250cmFyIG8gSUQgZGEgY2FydGEgbm8gZGVja1xuICAgICAgICBjb25zdCBkZWNrID0gZGVja3MuZmluZChkID0+IGQuaWQgPT09IGRlY2tJZCk7XG4gICAgICAgIGlmICghZGVjaykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FyZEluRGVjayA9IGRlY2suY2FyZHMuZmluZChjID0+IGMuY2FyZC5pZCA9PT0gY2FyZElkICYmIGMuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KTtcbiAgICAgICAgaWYgKCFjYXJkSW5EZWNrKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBkZWNrU2VydmljZS51cGRhdGVDYXJkKGRlY2tJZCwgY2FyZEluRGVjay5faWQsIHsgcXVhbnRpdHk6IG5vdmFRdWFudGlkYWRlIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR1YWxpemFyIGVzdGFkbyBsb2NhbFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRlY2tTZXJ2aWNlLmdldEJ5SWQoZGVja0lkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4gZGVjay5pZCA9PT0gZGVja0lkID8gcmVzcG9uc2UuZGF0YSA6IGRlY2spKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBhdHVhbGl6YXIgcXVhbnRpZGFkZSBubyBkZWNrOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXREZWNrcyhwcmV2ID0+IHByZXYubWFwKGRlY2sgPT4ge1xuICAgICAgICBpZiAoZGVjay5pZCA9PT0gZGVja0lkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRlY2ssXG4gICAgICAgICAgICBjYXJkczogZGVjay5jYXJkcy5tYXAoYyA9PiBcbiAgICAgICAgICAgICAgYy5jYXJkLmlkID09PSBjYXJkSWQgJiYgYy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICA/IHsgLi4uYywgcXVhbnRpdHk6IG5vdmFRdWFudGlkYWRlIH1cbiAgICAgICAgICAgICAgICA6IGNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY2s7XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE9idGVyIGNhcnRhcyBxdWUgZXN0w6NvIHNlbmRvIHVzYWRhcyBlbSBkZWNrc1xuICBjb25zdCBnZXRDYXJ0YXNVc2FkYXNFbURlY2tzID0gKGNhcmRJZDogc3RyaW5nKTogQXJyYXk8e2RlY2s6IERlY2ssIHF1YW50aXR5OiBudW1iZXIsIGNhdGVnb3J5OiBzdHJpbmd9PiA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBBcnJheTx7ZGVjazogRGVjaywgcXVhbnRpdHk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZ30+ID0gW107XG4gICAgXG4gICAgZGVja3MuZm9yRWFjaChkZWNrID0+IHtcbiAgICAgIGRlY2suY2FyZHMuZm9yRWFjaChkZWNrQ2FyZCA9PiB7XG4gICAgICAgIGlmIChkZWNrQ2FyZC5jYXJkLmlkID09PSBjYXJkSWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBkZWNrLFxuICAgICAgICAgICAgcXVhbnRpdHk6IGRlY2tDYXJkLnF1YW50aXR5LFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGRlY2tDYXJkLmNhdGVnb3J5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIFxuICAvLyBGdW7Dp8OjbyBwYXJhIGltcG9ydGFyIGRlY2sgYSBwYXJ0aXIgZGUgdW1hIGxpc3RhIGRlIHRleHRvXG4gIGNvbnN0IGltcG9ydGFyRGVja0RlTGlzdGEgPSBhc3luYyAoZGVja0xpc3Q6IHN0cmluZywgZGVja0RhdGE6IGFueSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyaWFyIG8gZGVjayB2YXppbyBwcmltZWlyb1xuICAgICAgY29uc3QgZGVja0lkID0gYXdhaXQgY3JpYXJEZWNrKHtcbiAgICAgICAgbmFtZTogZGVja0RhdGEubmFtZSxcbiAgICAgICAgZm9ybWF0OiBkZWNrRGF0YS5mb3JtYXQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZWNrRGF0YS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgY29sb3JzOiBkZWNrRGF0YS5jb2xvcnMgfHwgW10sXG4gICAgICAgIGNhcmRzOiBbXSxcbiAgICAgICAgaXNQdWJsaWM6IGRlY2tEYXRhLmlzUHVibGljIHx8IGZhbHNlLFxuICAgICAgICB0YWdzOiBkZWNrRGF0YS50YWdzIHx8IFtdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2Vzc2FyIGEgbGlzdGEgZGUgY2FydGFzXG4gICAgICBjb25zdCBsaW5lcyA9IGRlY2tMaXN0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgICBsZXQgY3VycmVudFNlY3Rpb246ICdtYWluYm9hcmQnIHwgJ3NpZGVib2FyZCcgfCAnY29tbWFuZGVyJyA9ICdtYWluYm9hcmQnO1xuICAgICAgY29uc3QgY2FyZFByb21pc2VzID0gW107XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZmljYXIgc2Ugw6kgdW1hIGxpbmhhIGRlIHNlw6fDo29cbiAgICAgICAgaWYgKHRyaW1tZWRMaW5lLmluY2x1ZGVzKCdzaWRlYm9hcmQnKSkge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gJ3NpZGVib2FyZCc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1tZWRMaW5lLmluY2x1ZGVzKCdjb21tYW5kZXInKSkge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gJ2NvbW1hbmRlcic7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaW1tZWRMaW5lLmluY2x1ZGVzKCdtYWluYm9hcmQnKSB8fCB0cmltbWVkTGluZS5pbmNsdWRlcygnbWFpbiBkZWNrJykpIHtcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9ICdtYWluYm9hcmQnO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZmljYXIgc2Ugw6kgdW1hIGxpbmhhIGRlIGNhcnRhXG4gICAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvXihcXGQrKXg/XFxzKyguKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGNvbnN0IHF1YW50aXR5ID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgIGNvbnN0IGNhcmROYW1lID0gbWF0Y2hbMl0udHJpbSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEJ1c2NhciBhIGNhcnRhIG5hIEFQSSBkbyBTY3J5ZmFsbFxuICAgICAgICAgIGNhcmRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5zY3J5ZmFsbC5jb20vY2FyZHMvbmFtZWQ/ZnV6enk9JHtlbmNvZGVVUklDb21wb25lbnQoY2FyZE5hbWUpfWApO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2FyZERhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAvLyBBZGljaW9uYXIgYSBjYXJ0YSBhbyBkZWNrXG4gICAgICAgICAgICAgICAgICBhd2FpdCBhZGljaW9uYXJDYXJ0YUFvRGVjayhkZWNrSWQsIGNhcmREYXRhLCBjdXJyZW50U2VjdGlvbiwgcXVhbnRpdHkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY2FyZDogY2FyZE5hbWUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ2FydGEgbsOjbyBlbmNvbnRyYWRhOiAke2NhcmROYW1lfWApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGNhcmQ6IGNhcmROYW1lIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm8gYW8gYnVzY2FyIGNhcnRhICR7Y2FyZE5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgY2FyZDogY2FyZE5hbWUgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWd1YXJkYXIgdG9kYXMgYXMgY2FydGFzIHNlcmVtIHByb2Nlc3NhZGFzXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNhcmRQcm9taXNlcyk7XG4gICAgICBjb25zdCBmYWlsZWRDYXJkcyA9IHJlc3VsdHNcbiAgICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgIShyZXN1bHQudmFsdWUgYXMgYW55KS5zdWNjZXNzKVxuICAgICAgICAubWFwKHJlc3VsdCA9PiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyAocmVzdWx0LnZhbHVlIGFzIGFueSkuY2FyZCA6ICdVbmtub3duJykpO1xuICAgICAgXG4gICAgICBpZiAoZmFpbGVkQ2FyZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEFsZ3VtYXMgY2FydGFzIG7Do28gZm9yYW0gZW5jb250cmFkYXM6ICR7ZmFpbGVkQ2FyZHMuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGRlY2tJZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBpbXBvcnRhciBkZWNrOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFsaGEgYW8gaW1wb3J0YXIgZGVjay4gVmVyaWZpcXVlIG8gZm9ybWF0byBkYSBsaXN0YS4nKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gPT09PT09IEZVTsOHw5VFUyBERSBHRVJFTkNJQU1FTlRPIERFIEZBVk9SSVRPUyA9PT09PT1cblxuICAvLyBBZGljaW9uYXIgY2FydGEgYW9zIGZhdm9yaXRvc1xuICBjb25zdCBhZGRGYXZvcml0ZSA9IGFzeW5jIChjYXJkOiBNVEdDYXJkKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmF2b3JpdGVTZXJ2aWNlLmFkZChjYXJkKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiBbLi4ucHJldiwgY2FyZF0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGFkaWNpb25hciBmYXZvcml0bzonLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBwYXJhIGxvY2FsU3RvcmFnZVxuICAgICAgc2V0RmF2b3JpdGVzKHByZXYgPT4ge1xuICAgICAgICBpZiAocHJldi5zb21lKGMgPT4gYy5pZCA9PT0gY2FyZC5pZCkpIHJldHVybiBwcmV2O1xuICAgICAgICByZXR1cm4gWy4uLnByZXYsIGNhcmRdO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbW92ZXIgY2FydGEgZG9zIGZhdm9yaXRvc1xuICBjb25zdCByZW1vdmVGYXZvcml0ZSA9IGFzeW5jIChjYXJkSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChzZXNzaW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZhdm9yaXRlU2VydmljZS5yZW1vdmVDYXJkKGNhcmRJZCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgc2V0RmF2b3JpdGVzKHByZXYgPT4gcHJldi5maWx0ZXIoY2FyZCA9PiBjYXJkLmlkICE9PSBjYXJkSWQpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyByZW1vdmVyIGZhdm9yaXRvOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbG9jYWxTdG9yYWdlXG4gICAgICBzZXRGYXZvcml0ZXMocHJldiA9PiBwcmV2LmZpbHRlcihjYXJkID0+IGNhcmQuaWQgIT09IGNhcmRJZCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBWZXJpZmljYXIgc2UgdW1hIGNhcnRhIGVzdMOhIG5vcyBmYXZvcml0b3NcbiAgY29uc3QgaXNGYXZvcml0ZSA9IChjYXJkSWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBmYXZvcml0ZXMuc29tZShjYXJkID0+IGNhcmQuaWQgPT09IGNhcmRJZCk7XG4gIH07XG5cbiAgLy8gRnVuw6fDo28gcGFyYSBleHBvcnRhciBjb2xlw6fDo28gcGFyYSBDU1Ygbm8gZm9ybWF0byBNYW5hYm94XG4gIGNvbnN0IGV4cG9ydENvbGxlY3Rpb25Ub0NTViA9IChjb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbikgPT4ge1xuICAgIC8vIEZvcm1hdG8gTWFuYWJveDogTmFtZSxTZXQsUXVhbnRpdHksRm9pbCxDb25kaXRpb24sTGFuZ3VhZ2VcbiAgICBjb25zdCBjc3ZDb250ZW50ID0gW1xuICAgICAgWydOYW1lJywgJ1NldCcsICdRdWFudGl0eScsICdGb2lsJywgJ0NvbmRpdGlvbicsICdMYW5ndWFnZSddLFxuICAgICAgLi4uY29sbGVjdGlvbi5jYXJkcy5tYXAoYyA9PiBbXG4gICAgICAgIGMuY2FyZC5uYW1lLFxuICAgICAgICBjLmNhcmQuc2V0X2NvZGUsXG4gICAgICAgIGMucXVhbnRpdHkudG9TdHJpbmcoKSxcbiAgICAgICAgYy5mb2lsID8gJ0ZvaWwnIDogJ05vbi1mb2lsJyxcbiAgICAgICAgYy5jb25kaXRpb24gfHwgJ05lYXIgTWludCcsXG4gICAgICAgIGMubGFuZ3VhZ2UgfHwgJ0VuZ2xpc2gnXG4gICAgICBdKVxuICAgIF0ubWFwKHJvdyA9PiByb3cuam9pbignLCcpKS5qb2luKCdcXG4nKTtcblxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICBhLmRvd25sb2FkID0gYCR7Y29sbGVjdGlvbi5uYW1lfV9tYW5hYm94LmNzdmA7XG4gICAgYS5jbGljaygpO1xuICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8QXBwQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xuICAgICAgY29sbGVjdGlvbnMsXG4gICAgICBjdXJyZW50Q29sbGVjdGlvbixcbiAgICAgIHNldEN1cnJlbnRDb2xsZWN0aW9uOiBzZXRDb2xsZWN0aW9ucyxcbiAgICAgIGN1cnJlbnRDb2xsZWN0aW9uSWQsXG4gICAgICBzZXRDdXJyZW50Q29sbGVjdGlvbklkLFxuICAgICAgY3JlYXRlQ29sbGVjdGlvbixcbiAgICAgIHVwZGF0ZUNvbGxlY3Rpb24sXG4gICAgICBkZWxldGVDb2xsZWN0aW9uLFxuICAgICAgZHVwbGljYXRlQ29sbGVjdGlvbixcbiAgICAgIGFkaWNpb25hckNhcnRhLFxuICAgICAgcmVtb3ZlckNhcnRhLFxuICAgICAgZ2V0UXVhbnRpZGFkZU5hQ29sZWNhbyxcbiAgICAgIGRlY2tzLFxuICAgICAgc2V0RGVja3MsXG4gICAgICBjcmlhckRlY2ssXG4gICAgICBlZGl0YXJEZWNrLFxuICAgICAgZGVsZXRhckRlY2ssXG4gICAgICBkdXBsaWNhckRlY2ssXG4gICAgICBhZGljaW9uYXJDYXJ0YUFvRGVjayxcbiAgICAgIHJlbW92ZXJDYXJ0YURvRGVjayxcbiAgICAgIGF0dWFsaXphclF1YW50aWRhZGVOb0RlY2ssXG4gICAgICBnZXRDYXJ0YXNVc2FkYXNFbURlY2tzLFxuICAgICAgaW1wb3J0YXJEZWNrRGVMaXN0YSxcbiAgICAgIGZhdm9yaXRlcyxcbiAgICAgIGFkZEZhdm9yaXRlLFxuICAgICAgcmVtb3ZlRmF2b3JpdGUsXG4gICAgICBpc0Zhdm9yaXRlLFxuICAgICAgbG9hZGluZyxcbiAgICAgIGV4cG9ydENvbGxlY3Rpb25Ub0NTVlxuICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXBwQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInNhZmVMb2NhbFN0b3JhZ2VTYXZlIiwiY29sbGVjdGlvblNlcnZpY2UiLCJkZWNrU2VydmljZSIsImZhdm9yaXRlU2VydmljZSIsInVzZVNlc3Npb24iLCJBcHBDb250ZXh0IiwidXNlQXBwQ29udGV4dCIsImNvbnRleHQiLCJFcnJvciIsIkFwcFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJkYXRhIiwic2Vzc2lvbiIsImNvbGxlY3Rpb25zIiwic2V0Q29sbGVjdGlvbnMiLCJjdXJyZW50Q29sbGVjdGlvbklkIiwic2V0Q3VycmVudENvbGxlY3Rpb25JZCIsImRlY2tzIiwic2V0RGVja3MiLCJmYXZvcml0ZXMiLCJzZXRGYXZvcml0ZXMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImN1cnJlbnRDb2xsZWN0aW9uIiwidXNlTWVtbyIsImZpbmQiLCJjIiwiaWQiLCJsb2FkRGF0YSIsImNvbGxlY3Rpb25zUmVzcG9uc2UiLCJnZXRBbGwiLCJzdWNjZXNzIiwibGVuZ3RoIiwiZGVja3NSZXNwb25zZSIsImZhdm9yaXRlc1Jlc3BvbnNlIiwibWFwIiwiZmF2IiwiY2FyZCIsImVycm9yIiwiY29uc29sZSIsInNhdmVkQ29sbGVjdGlvbnMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkQ29sbGVjdGlvbnMiLCJKU09OIiwicGFyc2UiLCJkZWZhdWx0Q29sbGVjdGlvbiIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImNhcmRzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZEF0IiwiaXNQdWJsaWMiLCJzYXZlZERlY2tzIiwicGFyc2VkRGVja3MiLCJzYXZlZEZhdm9yaXRlcyIsInBhcnNlZEZhdm9yaXRlcyIsImNyZWF0ZUNvbGxlY3Rpb24iLCJyZXNwb25zZSIsImNyZWF0ZSIsInByZXYiLCJuZXdDb2xsZWN0aW9uIiwibm93IiwidG9TdHJpbmciLCJ1cGRhdGVDb2xsZWN0aW9uIiwidXBkYXRlcyIsInVwZGF0ZSIsImRlbGV0ZUNvbGxlY3Rpb24iLCJkZWxldGUiLCJuZXdDb2xsZWN0aW9ucyIsImZpbHRlciIsImR1cGxpY2F0ZUNvbGxlY3Rpb24iLCJjb2xsZWN0aW9uVG9EdXBsaWNhdGUiLCJjYXJkSXRlbSIsImFkZENhcmQiLCJxdWFudGl0eSIsImNvbmRpdGlvbiIsImZvaWwiLCJsYW5ndWFnZSIsInVwZGF0ZWRSZXNwb25zZSIsImdldEJ5SWQiLCJhZGljaW9uYXJDYXJ0YSIsInF1YW50aWRhZGUiLCJleGlzdGluZ0NhcmQiLCJjYyIsIm5ld0NhcmRzIiwicmVtb3ZlckNhcnRhIiwiY29sbGVjdGlvbiIsImNhcmRJbkNvbGxlY3Rpb24iLCJ1cGRhdGVDYXJkIiwiX2lkIiwicmVtb3ZlQ2FyZCIsImdldFF1YW50aWRhZGVOYUNvbGVjYW8iLCJjYXJkSWQiLCJjcmlhckRlY2siLCJkZWNrRGF0YSIsIm5ld0RlY2siLCJsYXN0TW9kaWZpZWQiLCJlZGl0YXJEZWNrIiwiZGVja0lkIiwiZGVjayIsImRlbGV0YXJEZWNrIiwiZHVwbGljYXJEZWNrIiwibmV3TmFtZSIsIm9yaWdpbmFsRGVjayIsInVuZGVmaW5lZCIsIm5ld0RlY2tEYXRhIiwiZm9ybWF0IiwiY29sb3JzIiwiaXNTaWRlYm9hcmQiLCJjYXRlZ29yeSIsImlzQ29tbWFuZGVyIiwiZHVwbGljYXRlZERlY2siLCJhZGljaW9uYXJDYXJ0YUFvRGVjayIsInJlbW92ZXJDYXJ0YURvRGVjayIsImQiLCJjYXJkSW5EZWNrIiwiYXR1YWxpemFyUXVhbnRpZGFkZU5vRGVjayIsIm5vdmFRdWFudGlkYWRlIiwiZ2V0Q2FydGFzVXNhZGFzRW1EZWNrcyIsInJlc3VsdCIsImZvckVhY2giLCJkZWNrQ2FyZCIsInB1c2giLCJpbXBvcnRhckRlY2tEZUxpc3RhIiwiZGVja0xpc3QiLCJ0YWdzIiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJ0cmltIiwiY3VycmVudFNlY3Rpb24iLCJjYXJkUHJvbWlzZXMiLCJ0cmltbWVkTGluZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJtYXRjaCIsInBhcnNlSW50IiwiY2FyZE5hbWUiLCJmZXRjaCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm9rIiwiY2FyZERhdGEiLCJqc29uIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwiZmFpbGVkQ2FyZHMiLCJzdGF0dXMiLCJ2YWx1ZSIsIndhcm4iLCJqb2luIiwiYWRkRmF2b3JpdGUiLCJhZGQiLCJzb21lIiwicmVtb3ZlRmF2b3JpdGUiLCJpc0Zhdm9yaXRlIiwiZXhwb3J0Q29sbGVjdGlvblRvQ1NWIiwiY3N2Q29udGVudCIsInNldF9jb2RlIiwicm93IiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwid2luZG93IiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImNsaWNrIiwicmV2b2tlT2JqZWN0VVJMIiwiUHJvdmlkZXIiLCJzZXRDdXJyZW50Q29sbGVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/AppContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/storageUtils.ts":
/*!*******************************!*\
  !*** ./utils/storageUtils.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   safeLocalStorageSave: function() { return /* binding */ safeLocalStorageSave; },\n/* harmony export */   truncateCardData: function() { return /* binding */ truncateCardData; }\n/* harmony export */ });\n/**\n * Função para truncar dados de cartas para economizar espaço no localStorage\n * Remove informações não essenciais das cartas\n */ const truncateCardData = (card)=>{\n    return {\n        id: card.id,\n        name: card.name,\n        set: card.set,\n        set_code: card.set_code,\n        type_line: card.type_line,\n        cmc: card.cmc,\n        colors: card.colors,\n        rarity: card.rarity\n    };\n};\n/**\n * Função segura para salvar no localStorage com tratamento de quota excedida\n */ const safeLocalStorageSave = (key, data)=>{\n    try {\n        const serialized = JSON.stringify(data);\n        localStorage.setItem(key, serialized);\n        return true;\n    } catch (error) {\n        console.error(\"Erro ao salvar \".concat(key, \" no localStorage:\"), error);\n        // Se for erro de quota, tente limpar dados não essenciais\n        if (error instanceof DOMException && (error.name === \"QuotaExceededError\" || error.name === \"NS_ERROR_DOM_QUOTA_REACHED\")) {\n            console.warn(\"Quota excedida. Tentando salvar vers\\xe3o reduzida...\");\n            try {\n                // Para coleções, remova detalhes das cartas mantendo apenas IDs e quantidades\n                if (key === \"mtg-collections\") {\n                    const simplifiedCollections = data.map((collection)=>({\n                            ...collection,\n                            cards: collection.cards.map((card)=>({\n                                    quantity: card.quantity,\n                                    card: truncateCardData(card.card),\n                                    condition: card.condition,\n                                    foil: card.foil,\n                                    language: card.language\n                                }))\n                        }));\n                    localStorage.setItem(key, JSON.stringify(simplifiedCollections));\n                    return true;\n                }\n                // Para decks, também simplifique os dados das cartas\n                if (key === \"mtg-decks\") {\n                    const simplifiedDecks = data.map((deck)=>({\n                            ...deck,\n                            cards: deck.cards.map((card)=>({\n                                    quantity: card.quantity,\n                                    category: card.category,\n                                    card: truncateCardData(card.card)\n                                }))\n                        }));\n                    localStorage.setItem(key, JSON.stringify(simplifiedDecks));\n                    return true;\n                }\n                // Para favoritos, simplifique os dados das cartas\n                if (key === \"mtg-favorites\") {\n                    const simplifiedFavorites = data.map((card)=>truncateCardData(card));\n                    localStorage.setItem(key, JSON.stringify(simplifiedFavorites));\n                    return true;\n                }\n            } catch (innerError) {\n                console.error(\"Falha ao salvar vers\\xe3o reduzida:\", innerError);\n            }\n        }\n        return false;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3N0b3JhZ2VVdGlscy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUVBOzs7Q0FHQyxHQUNNLE1BQU1BLG1CQUFtQixDQUFDQztJQUMvQixPQUFPO1FBQ0xDLElBQUlELEtBQUtDLEVBQUU7UUFDWEMsTUFBTUYsS0FBS0UsSUFBSTtRQUNmQyxLQUFLSCxLQUFLRyxHQUFHO1FBQ2JDLFVBQVVKLEtBQUtJLFFBQVE7UUFDdkJDLFdBQVdMLEtBQUtLLFNBQVM7UUFDekJDLEtBQUtOLEtBQUtNLEdBQUc7UUFDYkMsUUFBUVAsS0FBS08sTUFBTTtRQUNuQkMsUUFBUVIsS0FBS1EsTUFBTTtJQUNyQjtBQUNGLEVBQUU7QUFFRjs7Q0FFQyxHQUNNLE1BQU1DLHVCQUF1QixDQUFDQyxLQUFhQztJQUNoRCxJQUFJO1FBQ0YsTUFBTUMsYUFBYUMsS0FBS0MsU0FBUyxDQUFDSDtRQUNsQ0ksYUFBYUMsT0FBTyxDQUFDTixLQUFLRTtRQUMxQixPQUFPO0lBQ1QsRUFBRSxPQUFPSyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxrQkFBc0IsT0FBSlAsS0FBSSxzQkFBb0JPO1FBRXhELDBEQUEwRDtRQUMxRCxJQUFJQSxpQkFBaUJFLGdCQUNoQkYsQ0FBQUEsTUFBTWYsSUFBSSxLQUFLLHdCQUF3QmUsTUFBTWYsSUFBSSxLQUFLLDRCQUEyQixHQUFJO1lBQ3hGZ0IsUUFBUUUsSUFBSSxDQUFDO1lBRWIsSUFBSTtnQkFDRiw4RUFBOEU7Z0JBQzlFLElBQUlWLFFBQVEsbUJBQW1CO29CQUM3QixNQUFNVyx3QkFBd0JWLEtBQUtXLEdBQUcsQ0FBQyxDQUFDQyxhQUFnQzs0QkFDdEUsR0FBR0EsVUFBVTs0QkFDYkMsT0FBT0QsV0FBV0MsS0FBSyxDQUFDRixHQUFHLENBQUN0QixDQUFBQSxPQUFTO29DQUNuQ3lCLFVBQVV6QixLQUFLeUIsUUFBUTtvQ0FDdkJ6QixNQUFNRCxpQkFBaUJDLEtBQUtBLElBQUk7b0NBQ2hDMEIsV0FBVzFCLEtBQUswQixTQUFTO29DQUN6QkMsTUFBTTNCLEtBQUsyQixJQUFJO29DQUNmQyxVQUFVNUIsS0FBSzRCLFFBQVE7Z0NBQ3pCO3dCQUNGO29CQUNBYixhQUFhQyxPQUFPLENBQUNOLEtBQUtHLEtBQUtDLFNBQVMsQ0FBQ087b0JBQ3pDLE9BQU87Z0JBQ1Q7Z0JBRUEscURBQXFEO2dCQUNyRCxJQUFJWCxRQUFRLGFBQWE7b0JBQ3ZCLE1BQU1tQixrQkFBa0JsQixLQUFLVyxHQUFHLENBQUMsQ0FBQ1EsT0FBZ0I7NEJBQ2hELEdBQUdBLElBQUk7NEJBQ1BOLE9BQU9NLEtBQUtOLEtBQUssQ0FBQ0YsR0FBRyxDQUFDdEIsQ0FBQUEsT0FBUztvQ0FDN0J5QixVQUFVekIsS0FBS3lCLFFBQVE7b0NBQ3ZCTSxVQUFVL0IsS0FBSytCLFFBQVE7b0NBQ3ZCL0IsTUFBTUQsaUJBQWlCQyxLQUFLQSxJQUFJO2dDQUNsQzt3QkFDRjtvQkFDQWUsYUFBYUMsT0FBTyxDQUFDTixLQUFLRyxLQUFLQyxTQUFTLENBQUNlO29CQUN6QyxPQUFPO2dCQUNUO2dCQUVBLGtEQUFrRDtnQkFDbEQsSUFBSW5CLFFBQVEsaUJBQWlCO29CQUMzQixNQUFNc0Isc0JBQXNCckIsS0FBS1csR0FBRyxDQUFDLENBQUN0QixPQUFrQkQsaUJBQWlCQztvQkFDekVlLGFBQWFDLE9BQU8sQ0FBQ04sS0FBS0csS0FBS0MsU0FBUyxDQUFDa0I7b0JBQ3pDLE9BQU87Z0JBQ1Q7WUFDRixFQUFFLE9BQU9DLFlBQVk7Z0JBQ25CZixRQUFRRCxLQUFLLENBQUMsdUNBQW9DZ0I7WUFDcEQ7UUFDRjtRQUNBLE9BQU87SUFDVDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvc3RvcmFnZVV0aWxzLnRzPzk3YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBNVEdDYXJkLCBVc2VyQ29sbGVjdGlvbiwgQ29sbGVjdGlvbkNhcmQsIERlY2sgfSBmcm9tICdAL3R5cGVzL210Zyc7XG5cbi8qKlxuICogRnVuw6fDo28gcGFyYSB0cnVuY2FyIGRhZG9zIGRlIGNhcnRhcyBwYXJhIGVjb25vbWl6YXIgZXNwYcOnbyBubyBsb2NhbFN0b3JhZ2VcbiAqIFJlbW92ZSBpbmZvcm1hw6fDtWVzIG7Do28gZXNzZW5jaWFpcyBkYXMgY2FydGFzXG4gKi9cbmV4cG9ydCBjb25zdCB0cnVuY2F0ZUNhcmREYXRhID0gKGNhcmQ6IE1UR0NhcmQpOiBQYXJ0aWFsPE1UR0NhcmQ+ID0+IHtcbiAgcmV0dXJuIHtcbiAgICBpZDogY2FyZC5pZCxcbiAgICBuYW1lOiBjYXJkLm5hbWUsXG4gICAgc2V0OiBjYXJkLnNldCxcbiAgICBzZXRfY29kZTogY2FyZC5zZXRfY29kZSxcbiAgICB0eXBlX2xpbmU6IGNhcmQudHlwZV9saW5lLFxuICAgIGNtYzogY2FyZC5jbWMsXG4gICAgY29sb3JzOiBjYXJkLmNvbG9ycyxcbiAgICByYXJpdHk6IGNhcmQucmFyaXR5XG4gIH07XG59O1xuXG4vKipcbiAqIEZ1bsOnw6NvIHNlZ3VyYSBwYXJhIHNhbHZhciBubyBsb2NhbFN0b3JhZ2UgY29tIHRyYXRhbWVudG8gZGUgcXVvdGEgZXhjZWRpZGFcbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVMb2NhbFN0b3JhZ2VTYXZlID0gKGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBzZXJpYWxpemVkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvIGFvIHNhbHZhciAke2tleX0gbm8gbG9jYWxTdG9yYWdlOmAsIGVycm9yKTtcbiAgICBcbiAgICAvLyBTZSBmb3IgZXJybyBkZSBxdW90YSwgdGVudGUgbGltcGFyIGRhZG9zIG7Do28gZXNzZW5jaWFpc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBcbiAgICAgICAgKGVycm9yLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1F1b3RhIGV4Y2VkaWRhLiBUZW50YW5kbyBzYWx2YXIgdmVyc8OjbyByZWR1emlkYS4uLicpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBQYXJhIGNvbGXDp8O1ZXMsIHJlbW92YSBkZXRhbGhlcyBkYXMgY2FydGFzIG1hbnRlbmRvIGFwZW5hcyBJRHMgZSBxdWFudGlkYWRlc1xuICAgICAgICBpZiAoa2V5ID09PSAnbXRnLWNvbGxlY3Rpb25zJykge1xuICAgICAgICAgIGNvbnN0IHNpbXBsaWZpZWRDb2xsZWN0aW9ucyA9IGRhdGEubWFwKChjb2xsZWN0aW9uOiBVc2VyQ29sbGVjdGlvbikgPT4gKHtcbiAgICAgICAgICAgIC4uLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICBjYXJkczogY29sbGVjdGlvbi5jYXJkcy5tYXAoY2FyZCA9PiAoe1xuICAgICAgICAgICAgICBxdWFudGl0eTogY2FyZC5xdWFudGl0eSxcbiAgICAgICAgICAgICAgY2FyZDogdHJ1bmNhdGVDYXJkRGF0YShjYXJkLmNhcmQpLFxuICAgICAgICAgICAgICBjb25kaXRpb246IGNhcmQuY29uZGl0aW9uLFxuICAgICAgICAgICAgICBmb2lsOiBjYXJkLmZvaWwsXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiBjYXJkLmxhbmd1YWdlXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShzaW1wbGlmaWVkQ29sbGVjdGlvbnMpKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUGFyYSBkZWNrcywgdGFtYsOpbSBzaW1wbGlmaXF1ZSBvcyBkYWRvcyBkYXMgY2FydGFzXG4gICAgICAgIGlmIChrZXkgPT09ICdtdGctZGVja3MnKSB7XG4gICAgICAgICAgY29uc3Qgc2ltcGxpZmllZERlY2tzID0gZGF0YS5tYXAoKGRlY2s6IERlY2spID0+ICh7XG4gICAgICAgICAgICAuLi5kZWNrLFxuICAgICAgICAgICAgY2FyZHM6IGRlY2suY2FyZHMubWFwKGNhcmQgPT4gKHtcbiAgICAgICAgICAgICAgcXVhbnRpdHk6IGNhcmQucXVhbnRpdHksXG4gICAgICAgICAgICAgIGNhdGVnb3J5OiBjYXJkLmNhdGVnb3J5LFxuICAgICAgICAgICAgICBjYXJkOiB0cnVuY2F0ZUNhcmREYXRhKGNhcmQuY2FyZClcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHNpbXBsaWZpZWREZWNrcykpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQYXJhIGZhdm9yaXRvcywgc2ltcGxpZmlxdWUgb3MgZGFkb3MgZGFzIGNhcnRhc1xuICAgICAgICBpZiAoa2V5ID09PSAnbXRnLWZhdm9yaXRlcycpIHtcbiAgICAgICAgICBjb25zdCBzaW1wbGlmaWVkRmF2b3JpdGVzID0gZGF0YS5tYXAoKGNhcmQ6IE1UR0NhcmQpID0+IHRydW5jYXRlQ2FyZERhdGEoY2FyZCkpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoc2ltcGxpZmllZEZhdm9yaXRlcykpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChpbm5lckVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhbGhhIGFvIHNhbHZhciB2ZXJzw6NvIHJlZHV6aWRhOicsIGlubmVyRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07Il0sIm5hbWVzIjpbInRydW5jYXRlQ2FyZERhdGEiLCJjYXJkIiwiaWQiLCJuYW1lIiwic2V0Iiwic2V0X2NvZGUiLCJ0eXBlX2xpbmUiLCJjbWMiLCJjb2xvcnMiLCJyYXJpdHkiLCJzYWZlTG9jYWxTdG9yYWdlU2F2ZSIsImtleSIsImRhdGEiLCJzZXJpYWxpemVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJlcnJvciIsImNvbnNvbGUiLCJET01FeGNlcHRpb24iLCJ3YXJuIiwic2ltcGxpZmllZENvbGxlY3Rpb25zIiwibWFwIiwiY29sbGVjdGlvbiIsImNhcmRzIiwicXVhbnRpdHkiLCJjb25kaXRpb24iLCJmb2lsIiwibGFuZ3VhZ2UiLCJzaW1wbGlmaWVkRGVja3MiLCJkZWNrIiwiY2F0ZWdvcnkiLCJzaW1wbGlmaWVkRmF2b3JpdGVzIiwiaW5uZXJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/storageUtils.ts\n"));

/***/ })

});