import { TABLES } from '@/lib/awsConfig';
import { fetchAuthSession } from '@/lib/auth-adapter';
import { getCurrentUser } from 'aws-amplify/auth';
import { getUserSession } from '@/lib/authHelper';
// Usar o servi√ßo de banco de dados universal que funciona tanto no cliente quanto no servidor
import { universalDbService as awsDbService } from '@/lib/universalDbService';

// Fun√ß√µes auxiliares locais para evitar depend√™ncias circulares
const generateId = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};

const getCurrentTimestamp = () => new Date().toISOString();

// Fun√ß√£o auxiliar para obter o ID do usu√°rio autenticado
async function getAuthenticatedUserId() {
  try {
    const currentUser = await getCurrentUser();
    return currentUser?.attributes?.sub || currentUser?.username;
  } catch (error) {
    console.error('Erro ao obter usu√°rio autenticado:', error);
    return null;
  }
}

// Fun√ß√£o para diagnosticar status da autentica√ß√£o
async function diagnoseAuthStatus() {
  try {
    console.log('üîç Diagnosticando status da autentica√ß√£o...');
    
    // Verificar se estamos no lado do cliente
    if (typeof window === 'undefined') {
      console.error('‚ùå Diagn√≥stico deve ser executado no lado do cliente');
      return { authenticated: false, error: 'Executando no servidor' };
    }
    
    // Verificar se o Amplify est√° configurado
    try {
      const { fetchAuthSession } = await import('aws-amplify/auth');
      const session = await fetchAuthSession();
      console.log('‚úÖ Amplify configurado, sess√£o obtida:', session);
      
      if (session.tokens?.idToken) {
        console.log('‚úÖ Token de ID presente');
      } else {
        console.log('‚ùå Token de ID ausente');
      }
      
      if (session.credentials?.accessKeyId) {
        console.log('‚úÖ Credenciais AWS presentes');
      } else {
        console.log('‚ùå Credenciais AWS ausentes');
      }
      
      return { authenticated: true, session };
    } catch (amplifyError) {
      console.error('‚ùå Erro ao verificar sess√£o do Amplify:', amplifyError);
      return { authenticated: false, error: amplifyError.message };
    }
  } catch (error) {
    console.error('‚ùå Erro no diagn√≥stico de autentica√ß√£o:', error);
    return { authenticated: false, error: error.message };
  }
}

// Fun√ß√£o para testar diferentes estruturas de dados
async function testTableStructure(tableName: string, testData: any) {
  console.log(`Testando estrutura da tabela ${tableName} com dados:`, JSON.stringify(testData, null, 2));
  
  try {
    const result = await awsDbService.create(tableName, testData);
    console.log(`‚úÖ Estrutura v√°lida para ${tableName}:`, result);
    return { success: true, data: testData };
  } catch (error) {
    console.error(`‚ùå Estrutura inv√°lida para ${tableName}:`);
    console.error('  - Mensagem:', error.message);
    console.error('  - Nome:', error.name);
    console.error('  - C√≥digo:', error.code);
    console.error('  - Stack:', error.stack);
    
    // Se for AccessDeniedException, √© problema de permiss√µes
    if (error.name === 'AccessDeniedException') {
      console.error('  - Erro de permiss√£o detectado');
      console.error('  - Verifique se o usu√°rio est√° autenticado e tem permiss√µes para acessar o DynamoDB');
      console.error('  - Estrutura completa do erro:', JSON.stringify(error, null, 2));
      
      // Tentar extrair mensagem espec√≠fica do DynamoDB
      if (error.message) {
        console.error('  - Mensagem espec√≠fica do DynamoDB:', error.message);
      }
      
      // Tentar acessar propriedades espec√≠ficas do erro
      try {
        if (error.$metadata) {
          console.error('  - Metadata do erro:', error.$metadata);
        }
        if (error.$fault) {
          console.error('  - Fault do erro:', error.$fault);
        }
      } catch (metadataError) {
        console.error('  - Erro ao acessar metadata:', metadataError);
      }
    }
    
    // Se for ValidationException, tentar extrair mais detalhes
    if (error.name === 'ValidationException') {
      console.error('  - Detalhes da valida√ß√£o:', error);
      console.error('  - Estrutura completa do erro:', JSON.stringify(error, null, 2));
      
      // Tentar extrair mensagem espec√≠fica do DynamoDB
      if (error.message) {
        console.error('  - Mensagem espec√≠fica do DynamoDB:', error.message);
      }
      
      // Tentar acessar propriedades espec√≠ficas do erro
      try {
        if (error.$metadata) {
          console.error('  - Metadata do erro:', error.$metadata);
        }
        if (error.$fault) {
          console.error('  - Fault do erro:', error.$fault);
        }
      } catch (metadataError) {
        console.error('  - Erro ao acessar metadata:', metadataError);
      }
    }
    
    return { success: false, error: error.message };
  }
}

// Servi√ßo para gerenciar cole√ß√µes
export const collectionService = {
  // Obter todas as cole√ß√µes do usu√°rio
  async getAll() {
    try {
      const currentUser = await getCurrentUser();
      if (!currentUser?.attributes?.sub) {
        return { success: false, error: 'Usu√°rio n√£o autenticado' };
      }
      
      return awsDbService.getByUserId(TABLES.COLLECTIONS, currentUser.attributes.sub);
    } catch (error) {
      return { success: false, error: 'Erro ao verificar autentica√ß√£o' };
    }
  },
  
  // Obter uma cole√ß√£o por ID
  async getById(id: string) {
    return awsDbService.getById(TABLES.COLLECTIONS, id);
  },
  
  // Fun√ß√£o para criar cole√ß√£o
  async create(collectionData: any) {
    console.log('üîÑ Tentando criar cole√ß√£o com dados:', JSON.stringify(collectionData, null, 2));
    
    try {
      // Executar diagn√≥stico de autentica√ß√£o primeiro
      const authDiagnostic = await diagnoseAuthStatus();
      console.log('üìä Resultado do diagn√≥stico de autentica√ß√£o:', authDiagnostic);
      
      if (!authDiagnostic.authenticated) {
        throw new Error(`Usu√°rio n√£o autenticado: ${authDiagnostic.error}`);
      }
      
      // Testar diferentes estruturas de dados
      const testResults = await Promise.all([
        testTableStructure('collections', collectionData),
        testTableStructure('collections', { ...collectionData, collectionId: collectionData.id }),
        testTableStructure('collections', { ...collectionData, id: collectionData.id, collectionId: collectionData.id }),
        testTableStructure('collections', { 
          id: collectionData.id, 
          name: collectionData.name, 
          description: collectionData.description || '',
          userId: collectionData.userId,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          cards: collectionData.cards || []
        })
      ]);
      
      console.log('üìä Resultados dos testes:', testResults);
      
      // Encontrar o primeiro sucesso
      const successResult = testResults.find(result => result.success);
      if (successResult) {
        console.log('‚úÖ Estrutura v√°lida encontrada:', successResult.data);
        return successResult.data;
      }
      
      // Se nenhum teste passou, mostrar todos os erros
      console.error('‚ùå Todas as estruturas falharam. Erros:');
      testResults.forEach((result, index) => {
        if (!result.success) {
          console.error(`  Teste ${index + 1}:`, result.error);
        }
      });
      
      throw new Error('Nenhuma estrutura de dados v√°lida encontrada para a tabela collections');
      
    } catch (error) {
      console.error('üí• Erro ao criar cole√ß√£o:', error);
      console.error('  - Tipo de erro:', error.constructor.name);
      console.error('  - Mensagem:', error.message);
      console.error('  - Stack:', error.stack);
      
      // Se for AccessDeniedException, √© problema de permiss√µes
      if (error.name === 'AccessDeniedException') {
        console.error('  - Erro de permiss√£o detectado');
        console.error('  - Verifique se o usu√°rio est√° autenticado e tem permiss√µes para acessar o DynamoDB');
        throw new Error('Acesso negado ao banco de dados. Verifique se voc√™ est√° logado e tem permiss√µes adequadas.');
      }
      
      // Se for erro de autentica√ß√£o
      if (error.message?.includes('n√£o autenticado') || error.message?.includes('Fa√ßa login')) {
        console.error('  - Erro de autentica√ß√£o detectado');
        throw new Error('Usu√°rio n√£o autenticado. Fa√ßa login primeiro.');
      }
      
      // Se for ValidationException, tentar extrair mais detalhes
      if (error.name === 'ValidationException') {
        console.error('  - Detalhes da valida√ß√£o:', error);
        console.error('  - Estrutura completa do erro:', JSON.stringify(error, null, 2));
        
        // Tentar extrair mensagem espec√≠fica do DynamoDB
        if (error.message) {
          console.error('  - Mensagem espec√≠fica do DynamoDB:', error.message);
        }
        
        // Tentar acessar propriedades espec√≠ficas do erro
        try {
          if (error.$metadata) {
            console.error('  - Metadata do erro:', error.$metadata);
          }
          if (error.$fault) {
            console.error('  - Fault do erro:', error.$fault);
          }
        } catch (metadataError) {
          console.error('  - Erro ao acessar metadata:', metadataError);
        }
      }
      
      throw error;
    }
  },
  
  // Atualizar uma cole√ß√£o
  async update(id: string, updates: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Verificar se a cole√ß√£o pertence ao usu√°rio
    const collection = await awsDbService.getById(TABLES.COLLECTIONS, id);
    if (!collection.success || !collection.data || collection.data.userId !== userId) {
      return { success: false, error: 'Cole√ß√£o n√£o encontrada ou acesso negado' };
    }
    
    return awsDbService.update(TABLES.COLLECTIONS, id, updates);
  },
  
  // Excluir uma cole√ß√£o
  async delete(id: string) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Verificar se a cole√ß√£o pertence ao usu√°rio
    const collection = await awsDbService.getById(TABLES.COLLECTIONS, id);
    if (!collection.success || !collection.data || collection.data.userId !== userId) {
      return { success: false, error: 'Cole√ß√£o n√£o encontrada ou acesso negado' };
    }
    
    return awsDbService.delete(TABLES.COLLECTIONS, id);
  },
  
  // Adicionar carta √† cole√ß√£o
  async addCard(collectionId: string, cardData: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Obter a cole√ß√£o atual
    const collection = await awsDbService.getById(TABLES.COLLECTIONS, collectionId);
    if (!collection.success || !collection.data) {
      return { success: false, error: 'Cole√ß√£o n√£o encontrada' };
    }
    
    // Verificar se a cole√ß√£o pertence ao usu√°rio
    if (collection.data.userId !== userId) {
      return { success: false, error: 'Acesso negado' };
    }
    
    // Preparar o novo card com ID gerado
    const newCard = {
      id: generateId(),
      ...cardData,
      addedAt: getCurrentTimestamp()
    };
    
    // Adicionar o card na cole√ß√£o
    const cards = collection.data.cards || [];
    cards.push(newCard);
    
    // Atualizar a cole√ß√£o
    return awsDbService.update(TABLES.COLLECTIONS, collectionId, {
      cards,
      updatedAt: getCurrentTimestamp()
    });
  },
  
  // Remover carta da cole√ß√£o
  async removeCard(collectionId: string, cardId: string) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Obter a cole√ß√£o atual
    const collection = await awsDbService.getById(TABLES.COLLECTIONS, collectionId);
    if (!collection.success || !collection.data) {
      return { success: false, error: 'Cole√ß√£o n√£o encontrada' };
    }
    
    // Verificar se a cole√ß√£o pertence ao usu√°rio
    if (collection.data.userId !== userId) {
      return { success: false, error: 'Acesso negado' };
    }
    
    // Remover o card da cole√ß√£o
    const cards = collection.data.cards || [];
    const updatedCards = cards.filter((card: any) => card.id !== cardId);
    
    // Atualizar a cole√ß√£o
    return awsDbService.update(TABLES.COLLECTIONS, collectionId, {
      cards: updatedCards,
      updatedAt: getCurrentTimestamp()
    });
  },
  
  // Atualizar carta na cole√ß√£o
  async updateCard(collectionId: string, cardId: string, updates: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Obter a cole√ß√£o atual
    const collection = await awsDbService.getById(TABLES.COLLECTIONS, collectionId);
    if (!collection.success || !collection.data) {
      return { success: false, error: 'Cole√ß√£o n√£o encontrada' };
    }
    
    // Verificar se a cole√ß√£o pertence ao usu√°rio
    if (collection.data.userId !== userId) {
      return { success: false, error: 'Acesso negado' };
    }
    
    // Atualizar o card na cole√ß√£o
    const cards = collection.data.cards || [];
    const updatedCards = cards.map((card: any) => {
      if (card.id === cardId) {
        return { ...card, ...updates };
      }
      return card;
    });
    
    // Atualizar a cole√ß√£o
    return awsDbService.update(TABLES.COLLECTIONS, collectionId, {
      cards: updatedCards,
      updatedAt: getCurrentTimestamp()
    });
  }
};

// Servi√ßo para gerenciar decks
export const deckService = {
  // Obter todos os decks do usu√°rio
  async getAll() {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    return awsDbService.getByUserId(TABLES.DECKS, userId);
  },
  
  // Obter um deck por ID
  async getById(id: string) {
    return awsDbService.getById(TABLES.DECKS, id);
  },
  
  // Criar um novo deck
  async create(deckData: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    console.log('Tentando criar deck com diferentes estruturas...');
    
    // Estrutura 1: B√°sica
    const structure1 = {
      id: generateId(),
      name: deckData.name,
      userId: userId,
      createdAt: getCurrentTimestamp()
    };
    
    let result = await testTableStructure(TABLES.DECKS, structure1);
    if (result.success) {
      return { success: true, data: result.data };
    }
    
    // Estrutura 2: Com mais campos
    const structure2 = {
      id: generateId(),
      name: deckData.name,
      description: deckData.description || '',
      format: deckData.format || 'Commander',
      userId: userId,
      createdAt: getCurrentTimestamp(),
      updatedAt: getCurrentTimestamp()
    };
    
    result = await testTableStructure(TABLES.DECKS, structure2);
    if (result.success) {
      return { success: true, data: result.data };
    }
    
    // Estrutura 3: Com deckId
    const structure3 = {
      id: generateId(),
      deckId: generateId(),
      name: deckData.name,
      userId: userId,
      createdAt: getCurrentTimestamp()
    };
    
    result = await testTableStructure(TABLES.DECKS, structure3);
    if (result.success) {
      return { success: true, data: result.data };
    }
    
    // Estrutura 4: Apenas campos essenciais
    const structure4 = {
      name: deckData.name,
      userId: userId
    };
    
    result = await testTableStructure(TABLES.DECKS, structure4);
    if (result.success) {
      return { success: true, data: result.data };
    }
    
    return { success: false, error: 'N√£o foi poss√≠vel encontrar uma estrutura v√°lida para a tabela' };
  },
  
  // Atualizar um deck
  async update(id: string, updates: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Verificar se o deck pertence ao usu√°rio
    const deck = await awsDbService.getById(TABLES.DECKS, id);
    if (!deck.success || !deck.data || deck.data.userId !== userId) {
      return { success: false, error: 'Deck n√£o encontrado ou acesso negado' };
    }
    
    const updatedData = {
      ...updates,
      updatedAt: getCurrentTimestamp()
    };
    
    return awsDbService.update(TABLES.DECKS, id, updatedData);
  },
  
  // Excluir um deck
  async delete(id: string) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Verificar se o deck pertence ao usu√°rio
    const deck = await awsDbService.getById(TABLES.DECKS, id);
    if (!deck.success || !deck.data || deck.data.userId !== userId) {
      return { success: false, error: 'Deck n√£o encontrado ou acesso negado' };
    }
    
    return awsDbService.delete(TABLES.DECKS, id);
  },
  
  // Adicionar carta ao deck
  async addCard(deckId: string, cardData: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Obter o deck atual
    const deck = await awsDbService.getById(TABLES.DECKS, deckId);
    if (!deck.success || !deck.data) {
      return { success: false, error: 'Deck n√£o encontrado' };
    }
    
    // Verificar se o deck pertence ao usu√°rio
    if (deck.data.userId !== userId) {
      return { success: false, error: 'Acesso negado' };
    }
    
    // Preparar o novo card com ID gerado
    const newCard = {
      id: generateId(),
      ...cardData,
      addedAt: getCurrentTimestamp()
    };
    
    // Adicionar o card ao deck
    const cards = deck.data.cards || [];
    cards.push(newCard);
    
    // Atualizar o deck
    return awsDbService.update(TABLES.DECKS, deckId, {
      cards,
      updatedAt: getCurrentTimestamp()
    });
  },
  
  // Remover carta do deck
  async removeCard(deckId: string, cardId: string) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Obter o deck atual
    const deck = await awsDbService.getById(TABLES.DECKS, deckId);
    if (!deck.success || !deck.data) {
      return { success: false, error: 'Deck n√£o encontrado' };
    }
    
    // Verificar se o deck pertence ao usu√°rio
    if (deck.data.userId !== userId) {
      return { success: false, error: 'Acesso negado' };
    }
    
    // Remover o card do deck
    const cards = deck.data.cards || [];
    const updatedCards = cards.filter((card: any) => card.id !== cardId);
    
    // Atualizar o deck
    return awsDbService.update(TABLES.DECKS, deckId, {
      cards: updatedCards,
      updatedAt: getCurrentTimestamp()
    });
  },
  
  // Atualizar carta no deck
  async updateCard(deckId: string, cardId: string, updates: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    // Obter o deck atual
    const deck = await awsDbService.getById(TABLES.DECKS, deckId);
    if (!deck.success || !deck.data) {
      return { success: false, error: 'Deck n√£o encontrado' };
    }
    
    // Verificar se o deck pertence ao usu√°rio
    if (deck.data.userId !== userId) {
      return { success: false, error: 'Acesso negado' };
    }
    
    // Atualizar o card no deck
    const cards = deck.data.cards || [];
    const updatedCards = cards.map((card: any) => {
      if (card.id === cardId) {
        return { ...card, ...updates };
      }
      return card;
    });
    
    // Atualizar o deck
    return awsDbService.update(TABLES.DECKS, deckId, {
      cards: updatedCards,
      updatedAt: getCurrentTimestamp()
    });
  }
};

// Servi√ßo para gerenciar favoritos
export const favoriteService = {
  // Obter todos os favoritos do usu√°rio
  async getAll() {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    return awsDbService.getByUserId(TABLES.FAVORITES, userId);
  },
  
  // Adicionar um favorito
  async add(cardData: any) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    const favorite = {
      id: generateId(),
      favoriteId: generateId(), // Campo obrigat√≥rio para a tabela
      userId: userId,
      ...cardData,
      createdAt: getCurrentTimestamp()
    };
    
    return awsDbService.create(TABLES.FAVORITES, favorite);
  },
  
  // Remover um favorito
  async remove(favoriteId: string) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    return awsDbService.delete(TABLES.FAVORITES, favoriteId);
  },
  
  // Verificar se uma carta est√° nos favoritos
  async checkCard(cardId: string) {
    const userId = await getAuthenticatedUserId();
    if (!userId) {
      return { success: false, error: 'Usu√°rio n√£o autenticado' };
    }
    
    const result = await awsDbService.query(TABLES.FAVORITES, 'userId', userId, {
      filterExpression: 'cardId = :cardId',
      expressionValues: {
        ':cardId': cardId
      }
    });
    
    return {
      success: result.success,
      data: {
        isFavorite: result.data && result.data.length > 0,
        favoriteId: result.data && result.data.length > 0 ? result.data[0].id : null
      },
      error: result.error
    };
  }
};
